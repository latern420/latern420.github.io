<html xmlns:fb="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:l="http://www.w3.org/1999/xlink">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Программирование на языке Пролог для искусственного интеллекта</title>
<style type="text/css" media="screen">
		A { color : #0002CC }
		A:HOVER { color : #BF0000 }
		BODY {font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; text-align : justify }
		H1{ font-size : 160%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize;  border : 1px solid Black;  background-color : #E7E7E7; text-transform : capitalize;  margin-left : 0px;  padding-left : 0.5em;  }
		H2{ font-size : 130%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize;  background-color : #EEEEEE;  border : 1px solid Gray; text-transform : capitalize;  padding-left : 1em; }
		H3{ font-size : 110%; font-style : normal; font-weight : bold; text-align : left;  background-color : #F1F1F1;  border : 1px solid Silver; text-transform : capitalize;  padding-left : 1.5em;}
		H4{ font-size : 100%; font-style : normal; font-weight : bold; text-align : left   padding-left : 0.5em; text-transform : capitalize;  border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2em;}
		H5{ font-size : 100%; font-style : italic; font-weight : bold; text-align : left; text-transform : capitalize;border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2.5em;}
		H6{ font-size : 100%; font-style : italic; font-weight : normal; text-align : left; text-transform : capitalize;border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2.5em;}
		SMALL{ font-size : 80% }
		BLOCKQUOTE{ margin : 0 1em 0.2em 4em }
		HR{ color : Black }
		UL{ padding-left : 1em; margin-left: 0}
		.epigraph{margin-right:5em; margin-left : 25%;}
		DIV{font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; text-align : justify}
	</style>
<style type="text/css" media="print">
		A { color : #0002CC }
		A:HOVER { color : #BF0000 }
		BODY {font-family : "Times New Roman", Times, serif; text-align : justify }
		H1{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 160%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize }
		H2{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 130%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize }
		H3{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 110%; font-style : normal; font-weight : bold; text-align : left }
		H4{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 100%; font-style : normal; font-weight : bold; text-align : left }
		H5,H6{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 100%; font-style : italic; font-weight : normal; text-align : left; text-transform : uppercase }
		SMALL{ font-size : 80% }
		BLOCKQUOTE{ margin : 0 1em 0.2em 4em }
		HR{ color : Black }
		DIV{font-family : "Times New Roman", Times, serif; text-align : justify}
	</style>
</head>
<body>
<p align="center">   Спасибо, что скачали книгу в <a href="http://royallib.ru" title="">бесплатной электронной библиотеке Royallib.ru</a><br>   <a href="http://royallib.ru/author/bratko_ivan.html" title="">Все книги автора</a><br>   <a href="http://royallib.ru/book/bratko_ivan/programmirovanie_na_yazike_prolog_dlya_iskusstvennogo_intellekta.html" title="">Эта же книга в других форматах</a><br>
		 <br>   Приятного чтения!<br>
		 <br>
		 <br>
		 <br></p>
<div align="center"><img border="1" src="_3.jpg"></div>
<h1>Программирование на языке Пролог для искусственного интеллекта<br></h1>
<h2><small><b>Иван  Братко<br></b></small></h2>
<hr>
<blockquote><ul>
<li><a href="#TOC_id3261048">От редактора перевода</a></li>
<li><a href="#TOC_id3577174">Предисловие</a></li>
<li><a href="#TOC_id3495328">Предисловие автора </a></li>
<li>
<a href="#TOC_id3426250">Часть 1</a><UL>
<li>
<a href="#TOC_id3399655">Глава 1</a><UL>
<li><a href="#TOC_id3399670">1.1. Пример программы: родственные отношения</a></li>
<li><a href="#TOC_id3499040">1.2. Расширение программы-примера с помощью правил</a></li>
<li><a href="#TOC_id3491356">1.3. Рекурсивное определение правил</a></li>
<li><a href="#TOC_id3425101">1.4. Как пролог-система отвечает на вопросы</a></li>
<li><a href="#TOC_id3575234">1.5. Декларативный и процедурный смысл программ</a></li>
<li><a href="#TOC_id3429316">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3486422">Глава 2</a><UL>
<li>
<a href="#TOC_id3417464">2.1.  Объекты данных</a><UL>
<li><a href="#TOC_id3417492">2.1.1. Атомы и числа</a></li>
<li><a href="#TOC_id3261781">2.1.2. Переменные</a></li>
<li><a href="#TOC_id3503333">2.1.3. Структуры</a></li>
</UL>
</li>
<li><a href="#TOC_id3382727">2.2. Сопоставление</a></li>
<li><a href="#TOC_id3578030">2.3. Декларативный смысл пролог-программ</a></li>
<li><a href="#TOC_id3502179">2.4. Процедурная семантика</a></li>
<li><a href="#TOC_id3417270">2.5. Пример: обезьяна и банан</a></li>
<li>
<a href="#TOC_id3494638">2.6. Порядок предложений и целей </a><UL>
<li><a href="#TOC_id3494644">2.6.1. Опасность бесконечного цикла</a></li>
<li><a href="#TOC_id3392094">2.6.2. Варианты программы, полученые путем переупорядочивания предложений и целей</a></li>
<li><a href="#TOC_id3306331">2.6.3. Сочетание декларативного и процедурного подходов</a></li>
</UL>
</li>
<li><a href="#TOC_id3306357">2.7. Замечания о взаимосвязи между Прологом и логикой</a></li>
<li><a href="#TOC_id3399238">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3399376">Глава 3</a><UL>
<li><a href="#TOC_id3399396">3.1. Представление списков</a></li>
<li>
<a href="#TOC_id3391224">3.2. Некоторые операции над списками</a><UL>
<li><a href="#TOC_id3391256">3.2.1. Принадлежность к списку</a></li>
<li><a href="#TOC_id3422638">3.2.2. Сцепление (конкатенация)</a></li>
<li><a href="#TOC_id3606860">3.2.3. Добавление элемента</a></li>
<li><a href="#TOC_id3606885">3.2.4. Удаление элемента</a></li>
<li><a href="#TOC_id3578007">3.2.5. Подсписок</a></li>
<li><a href="#TOC_id3390728">3.2.6. Перестановки</a></li>
</UL>
</li>
<li><a href="#TOC_id3606768">3.3. Операторная запись (нотация)</a></li>
<li><a href="#TOC_id3488143">3.4. Арифметические действия</a></li>
<li><a href="#TOC_id3501608">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3417198">Глава 4</a><UL>
<li><a href="#TOC_id3417218">4.1. Получение структурированной информации из базы данных</a></li>
<li><a href="#TOC_id3426822">4.2. Абстракция данных</a></li>
<li><a href="#TOC_id3609108">4.3. Моделирование недетерминированного автомата</a></li>
<li><a href="#TOC_id3419186">4.4. Планирование поездки</a></li>
<li>
<a href="#TOC_id3382322">4.5. Задача о восьми ферзях</a><UL>
<li><a href="#TOC_id3494272">4.5.1. Программа 1</a></li>
<li><a href="#TOC_id3578339">4.5.2. Программа 2</a></li>
<li><a href="#TOC_id3839524">4.5.3. Программа 3</a></li>
<li><a href="#TOC_id3583811">4.5.4. Заключительные замечания</a></li>
</UL>
</li>
<li><a href="#TOC_id3583922">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3583969">Глава 5</a><UL>
<li>
<a href="#TOC_id3583986">5.1. Ограничение перебора</a><UL>
<li><a href="#TOC_id3584075">5.1.1. Эксперимент 1</a></li>
<li><a href="#TOC_id3584203">5.1.2. Эксперимент 2</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3584444">5.2. Примеры, использующие отсечение </a><UL>
<li><a href="#TOC_id3584450">5.2.1.  Вычисление максимума</a></li>
<li><a href="#TOC_id3584499">5.2.2. Процедура проверки принадлежности списку, дающая единственное решение</a></li>
<li><a href="#TOC_id3584560">5.2.3. Добавление элемента к списку, если он в нем отсутствует (добавление без дублирования)</a></li>
<li><a href="#TOC_id3584672">5.2.4. Задача классификации объектов</a></li>
</UL>
</li>
<li><a href="#TOC_id3584929">5.3. Отрицание как неуспех</a></li>
<li><a href="#TOC_id3585465">5.4. Трудности с отсечением и отрицанием</a></li>
<li><a href="#TOC_id3585752">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3585865">Глава 6</a><UL>
<li><a href="#TOC_id3585882">6.1. Связь с файлами</a></li>
<li>
<a href="#TOC_id3586164">6.2. Обработка файлов термов </a><UL>
<li><a href="#TOC_id3586170">6.2.1. reаd и write</a></li>
<li><a href="#TOC_id3586594">6.2.2. Вывод списков</a></li>
<li><a href="#TOC_id3586773">6.2.3. Формирование термов</a></li>
<li><a href="#TOC_id3586988">6.2.4. Обработка произвольного файла термов</a></li>
</UL>
</li>
<li><a href="#TOC_id3587297">6.3. Обработка символов</a></li>
<li><a href="#TOC_id3587472">6.4. Создание и декомпозиция атомов</a></li>
<li><a href="#TOC_id3587954">6.5. Ввод программ: consult, reconsult</a></li>
<li><a href="#TOC_id3588074">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3588224">Глава 7</a><UL>
<li>
<a href="#TOC_id3588252">7.1. Проверка типов термов </a><UL>
<li><a href="#TOC_id3588258">7.1.1. Предикаты var, nоnvar, atom, integer, atomic</a></li>
<li><a href="#TOC_id3588660">7.1.2. Решение числового ребуса с использованием nonvar</a></li>
</UL>
</li>
<li><a href="#TOC_id3589329">7.2. Создание и декомпозиция термов: =.., functor, arg, name</a></li>
<li><a href="#TOC_id3590174">7.3. Различные виды равенства</a></li>
<li><a href="#TOC_id3590335">7.4. Работа с базой данных</a></li>
<li><a href="#TOC_id3590937">7.5. Средства управления</a></li>
<li><a href="#TOC_id3591073">7.6. bagof, setof и findall</a></li>
<li><a href="#TOC_id3591463">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3591593">Глава 8</a><UL>
<li><a href="#TOC_id3591610">8.1. Общие принципы хорошего программирования</a></li>
<li>
<a href="#TOC_id3591800">8.2. Как представлять себе программы на Прологе</a><UL>
<li><a href="#TOC_id3591821">8.2.1. Использование рекурсии</a></li>
<li><a href="#TOC_id3591969">8.2.2. Обобщение</a></li>
<li><a href="#TOC_id3592042">8.2.3. Использование рисунков</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3592081">8.3. Стиль программирования</a><UL>
<li><a href="#TOC_id3592105">8.3.1. Некоторые правила хорошего стиля</a></li>
<li><a href="#TOC_id3592362">8.3.2. Табличная организация длинных процедур</a></li>
<li><a href="#TOC_id3592385">8.3.3. Комментирование</a></li>
</UL>
</li>
<li><a href="#TOC_id3592441">8.4. Отладка</a></li>
<li>
<a href="#TOC_id3592554">8.5. Эффективность</a><UL>
<li><a href="#TOC_id3592644">8.5.1. Повышение эффективности решения задачи о восьми ферзях</a></li>
<li><a href="#TOC_id3592688">8.5.2. Повышение эффективности программы раскраски карты</a></li>
<li><a href="#TOC_id3593033">8.5.3. Повышение эффективности конкатенации списков за счет совершенствования структуры данных</a></li>
<li><a href="#TOC_id3593271">8.5.4. Повышение эффективности зa счет добавления вычисленных фактов к базе данных</a></li>
</UL>
</li>
<li><a href="#TOC_id3593724">Резюме</a></li>
</UL>
</li>
</UL>
</li>
<li>
<a href="#TOC_id3593816">Часть 2</a><UL>
<li>
<a href="#TOC_id3593828">Глава 9</a><UL>
<li>
<a href="#TOC_id3593852">9.1. Представление списков. Сортировка</a><UL>
<li><a href="#TOC_id3593858">9.1.1. Замечания в некоторых альтернативных способах представления списков</a></li>
<li><a href="#TOC_id3594142">9.1.2. Сортировка списков</a></li>
</UL>
</li>
<li><a href="#TOC_id3594853">9.2. Представление множеств двоичными деревьями</a></li>
<li><a href="#TOC_id3595469">9.3. Двоичные справочники: добавление и удаление элемента</a></li>
<li><a href="#TOC_id3595979">9.4. Отображение деревьев</a></li>
<li>
<a href="#TOC_id3596137">9.5. Графы </a><UL>
<li><a href="#TOC_id3596142">9.5.1. Представление графов</a></li>
<li><a href="#TOC_id3596319">9.5.2. Поиск пути в графе</a></li>
<li><a href="#TOC_id3596724">9.5.3. Построение остовного дерева</a></li>
</UL>
</li>
<li><a href="#TOC_id3597136">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3597248">Глава 10</a><UL>
<li><a href="#TOC_id3597270">10.1. Двоично-троичные справочники</a></li>
<li><a href="#TOC_id3598294">10.2. AVL-дерево: приближенно сбалансированное дерево</a></li>
<li><a href="#TOC_id3598804">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3598888">Глава 11.</a><UL>
<li><a href="#TOC_id3598916">11.1. Предварительные понятия и примеры</a></li>
<li><a href="#TOC_id3599292">11.2. Стратегия поиска в глубину</a></li>
<li>
<a href="#TOC_id3600005">11.3. Поиск в ширину</a><UL>
<li><a href="#TOC_id3600068">11.3.1. Списковое представление множества кандидатов</a></li>
<li><a href="#TOC_id3600371">11.3.2. Древовидное представление множества кандидатов</a></li>
</UL>
</li>
<li><a href="#TOC_id3444275">11.4.  Замечания относительно поиска в графах, оптимальности к сложности</a></li>
<li><a href="#TOC_id3444376">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3444506">Глава 12</a><UL>
<li><a href="#TOC_id3444536">12.1. Поиск с предпочтением</a></li>
<li><a href="#TOC_id3446118">12.2. Поиск c предпочтением применительно к головоломке "игра в восемь"</a></li>
<li><a href="#TOC_id3446816">12.3. Применение поиска с предпочтением к планированию выполнения задач</a></li>
<li><a href="#TOC_id3447546">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3447709">Глава 13</a><UL>
<li><a href="#TOC_id3447728">13.1. Представление задач в виде И/ИЛИ-графов</a></li>
<li>
<a href="#TOC_id3448157">13.2. Примеры И/ИЛИ-представления задач </a><UL>
<li><a href="#TOC_id3448163">13.2.1. И/ИЛИ-представление задачи поиска маршрута</a></li>
<li><a href="#TOC_id3448225">13.2.2. Задача о ханойской башне</a></li>
<li><a href="#TOC_id3448510">13.2.3. Формулировка игровых задач в терминах И/ИЛИ-графов</a></li>
</UL>
</li>
<li><a href="#TOC_id3448684">13.3. Базовые процедуры поиска в И/ИЛИ-графах</a></li>
<li>
<a href="#TOC_id3449407">13.4. Поиск с предпочтением в И/ИЛИ-графах </a><UL>
<li><a href="#TOC_id3449413">13.4.1. Эвристические оценки и алгоритм поиска</a></li>
<li><a href="#TOC_id3449918">13.4.2. Программа поиска</a></li>
<li><a href="#TOC_id3451066">13.4.3. Пример отношений, определяющих конкретную задачу: поиск маршрута</a></li>
</UL>
</li>
<li><a href="#TOC_id3451358">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3451473">Глава 14</a><UL>
<li><a href="#TOC_id3451500">14.1. Функции, выполняемые экспертной системой</a></li>
<li><a href="#TOC_id3451594">14.2. Грубая структура экспертной системы</a></li>
<li><a href="#TOC_id3451691">14.3. Правила типа "если-то" для представления знаний</a></li>
<li>
<a href="#TOC_id3452800">14.4. Разработка оболочки</a><UL>
<li><a href="#TOC_id3453262">14.4.1. Процесс рассуждений</a></li>
<li><a href="#TOC_id3453440">14.4.2. Формирование ответа на вопрос "почему"</a></li>
<li><a href="#TOC_id3453601">14.4.3. Формирование ответа на вопрос "как"</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3453676">14.5. Реализация</a><UL>
<li><a href="#TOC_id3453781">14.5.1. Процедура рассмотреть</a></li>
<li><a href="#TOC_id3454310">14.5.2. Процедура ответпольз</a></li>
<li><a href="#TOC_id3454900">14.5.3. Усовершенствование процедуры ответпольз</a></li>
<li><a href="#TOC_id3456046">14.5.4. Процедура  выдать</a></li>
<li><a href="#TOC_id3456084">14.5.5. Драйвер верхнего уровня</a></li>
<li><a href="#TOC_id3456305">14.5.6. Одно замечание по поводу программы-оболочки</a></li>
<li><a href="#TOC_id3456331">14.5.7. Цели с отрицанием</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3456865">14.6. Работа с неопределенностью </a><UL>
<li><a href="#TOC_id3456871">14.6.1. Степень достоверности</a></li>
<li><a href="#TOC_id3456966">14.6.2. Модель Prospector'а</a></li>
<li><a href="#TOC_id3457356">14.6.3. Принципы реализации</a></li>
</UL>
</li>
<li><a href="#TOC_id3457932">14.7. Заключительные замечания</a></li>
<li><a href="#TOC_id3458127">Резюме </a></li>
</UL>
</li>
<li>
<a href="#TOC_id3458291">Глава 15</a><UL>
<li><a href="#TOC_id3458314">15.1. Игры двух лиц с полной информацией</a></li>
<li><a href="#TOC_id3458569">15.2. Минимаксный принцип</a></li>
<li><a href="#TOC_id3458949">15.3. Альфа-бета алгоритм: эффективная реализация минимаксного принципа</a></li>
<li><a href="#TOC_id3459573">15.4. Минимаксные игровые программы: усовершенствования и ограничения</a></li>
<li>
<a href="#TOC_id3459744">15.5. Знания о типовых ситуациях и механизм "советов"</a><UL>
<li><a href="#TOC_id3459761">15.5.1. Цели и ограничения на ходы</a></li>
<li><a href="#TOC_id3459853">15.5.2. Выполнимость совета</a></li>
<li><a href="#TOC_id3459922">15.5.3. Правила и таблицы советов</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3460186">15.6. Программа на языке  AL0 для игры в шахматном эндшпиле</a><UL>
<li><a href="#TOC_id3460219">15.6.1. Миниатюрный интерпретатор языка AL0</a></li>
<li><a href="#TOC_id3460858">15.6.2. Программа на языке советов для эндшпиля "король и ладья против короля"</a></li>
</UL>
</li>
<li><a href="#TOC_id3462300">Резюме</a></li>
</UL>
</li>
<li>
<a href="#TOC_id3462564">Глава 16</a><UL>
<li>
<a href="#TOC_id3462582">16.1. Архитектура, ориентированная на типовые конфигурации </a><UL>
<li><a href="#TOC_id3462588">16.1.1. Основные понятия</a></li>
<li><a href="#TOC_id3462768">16.1.2. Прологовские программы как системы, управляемые образцами</a></li>
<li><a href="#TOC_id3462818">16.1.3. Пример составления программы</a></li>
</UL>
</li>
<li><a href="#TOC_id3463033">16.2. Простой интерпретатор программ, управляемых образцами</a></li>
<li><a href="#TOC_id3463319">16.3. Простая программа для автоматического доказательства теорем</a></li>
<li><a href="#TOC_id3464404">16.4. Заключительные замечания</a></li>
<li><a href="#TOC_id3464518">Резюме</a></li>
</UL>
</li>
</UL>
</li>
<li><a href="#TOC_id3464607">Ответы к некоторым упражнениям</a></li>
<br><li><a href="#TOC_notes_id3731494">Сноски</a></li>
</ul></blockquote>
<h1>Иван Братко <br>Программирование на языке Пролог для искусственного интеллекта<br></h1>
<blockquote class="epigraph">   Посвящается Бранке, Андрею и Тадею<br></blockquote>
<br><h1 align="center">
<a name="TOC_id3261048"></a>От редактора перевода<br></h1>
<div>   По существующей традиции предисловие редактора перевода — это своего рода рецензия, в которой обычно излагается история вопроса, а затем дается обзор содержания книги и оценка ее качества (как правило, рекламного характера). В данном случае моя задача несколько упрощается, так как все это читатель, перевернув страницу, найдет в предисловии известного американского ученого, специалиста по искусственному интеллекту П. Уинстона, а затем — в предисловии автора. Мне остается только присоединиться к авторитетному мнению П. Уинстона, что перед нами прекрасно написанный учебник до Прологу, ориентированный на практическое использование в области искусственного интеллекта. Добавлю также, что для советского читателя потребность в такой книге особенно велика, поскольку в нашей стране Пролог пока еще не получил того распространения, которого он заслуживает.<br>   Несколько замечаний относительно особенностей перевода. Кроме обычных терминологических трудностей, как правило возникающих при переводе книг по программированию, переводчикам пришлось преодолевать одну дополнительную сложность. Дело в том, что в Прологе идентификаторы (имена переменных, процедур и атомов) несут на себе значительно большую смысловую нагрузку, чем в традиционных языках программирования. Поэтому программные примеры пришлось излагать на некоей условной русской версии Пролога — в противном случае, для читателей, не владеющих английским языком, эти примеры стали бы значительно менее понятными. Мы оставили без перевода все имена встроенных операторов и процедур, все же остальные имена переводились на русский язык. Следует признать, что в ряде случаев русская версия этих имен оказалась менее эстетически привлекательной, чем исходный английский вариант. Пытаясь наиболее точно передать смысл того или иного имени, переводчик нередко оказывался перед нелегким выбором между громоздким идентификатором (иногда из нескольких слов) и неблагозвучной аббревиатурой. Впрочем, все эти проблемы хорошо известны любому "русскоязычному" программисту.<br>   Главы 1-8 перевел А.И. Лупенко, а предисловия и главы 9-16 — А.М. Степанов. Подготовку оригинала-макета книги на ЭВМ выполнили А.H. Черных и H.Г. Черных.<br>   Эту книгу можно рекомендовать как тем читателям, которые впервые приступают к изучению Пролога и искусственного интеллекта, так и программистам, уже имеющим опыт составления пролог-программ.<br><blockquote><blockquote><i>А. М. Степанов</i></blockquote></blockquote>
</div>
<h1 align="center">
<a name="TOC_id3577174"></a>Предисловие<br></h1>
<div>   В средние века знание латинского и греческого языков являлось существенной частью образования любого ученого. Ученый, владеющий только одним языком, неизбежно чувствовал себя неполноценным, поскольку он был лишен той полноты восприятия, которая возникает благодаря возможности посмотреть на мир сразу с двух точек зрения. Таким же неполноценным ощущает себя сегодняшний исследователь в области искусственного интеллекта, если он не обладает основательным знакомством как с Лиспом, так и с Прологом — с этими двумя основополагающими языками искусственного интеллекта, без знания которых невозможен более широкий взгляд на предмет исследования.<br>   Сам я приверженец Лиспа, так как воспитывался в Массачусетском технологическом институте, где этот язык был изобретен. Тем не менее, я никогда не забуду того волнения, которое я испытал, увидев в действии свою первую программу, написанную в прологовском стиле. Эта программа была частью знаменитой системы Shrdlu Терри Винограда. Решатель задач, встроенный в систему, работал в "мире кубиков" и заставлял руку робота (точнее, ее модель) перемещать кубики на экране дисплея, решая при этом хитроумные задачи, поставленные оператором.<br>   Решатель задач Винограда был написан на Микропленнере, языке, который, как мы теперь понимаем, был своего рода Прологом в миниатюре. Любой прологоподобный язык заставляет программиста мыслить в терминах целей, поэтому, несмотря на все недостатки Микропленнера, достоинством этой программы было то, что в ее структуре содержались многочисленные явные указания на те или иные цели. Процедуры-цели "схватить", "освободить", "избавиться", "переместить", "отпустить" и т.п. делали программу простой и компактной, а поведение ее казалось поразительно разумным.<br>   Решатель задач Винограда навсегда изменил мое программистское мышление. Я даже переписал его на Лиспе и привел в своем учебнике по Лиспу в качестве примера — настолько эта программа всегда поражала меня мощью заложенной в ней философии "целевого" программирования, да и само программирование в терминах целей всегда доставляло мне удовольствие.<br>   Однако учиться целевому программированию на примерах лисповских программ — это все равно, что читать Шекспира на языке, отличном от английского. Какое-то впечатление вы получите, но сила эстетического воздействия будет меньшей, чем при чтении оригинала. Аналогично этому, лучший способ научиться целевому программированию — это читать и писать программы на Прологе, поскольку сама сущность Пролога как раз и состоит в программировании в терминах целей.<br>   В самом широком смысле слова эволюция языков программирования — это движение от языков низкого уровня, пользуясь которыми, программист описывает, <i>как</i> что-либо следует делать, к языкам высокого уровня, на которых просто указывается, <i>что</i> необходимо сделать. Так, например, появление Фортрана освободило программистов от необходимости разговаривать с машиной на прокрустовом языке адресов и регистров. Теперь они уже могли говорить на своем (или почти на своем) языке, только изредка делая уступки примитивному миру 80-колонных перфокарт.<br>   Однако Фортран и почти все другие языки программирования все еще остаются языками типа "как". И чемпионом среди этих языков является, пожалуй, современный модернизированный Лисп. Так, скажем, Common Lisp, имея богатейшие выразительные возможности, разрешает программисту описывать наиболее "выразительно" именно то, <i>как</i> что-либо следует делать. В то же время очевидно, что Пролог порывает с традициями языков типа "как", поскольку он определенным образом направляет программистское мышление, заставляя программиста давать определения ситуаций и формулировать задачи вместо того, чтобы во всех деталях описывать способ решения этих задач.<br>   Отсюда следует, насколько важен вводный курс по Прологу для всех студентов, изучающих вычислительную технику и программирование — просто не существует лучшего способа понять, что из себя представляет программирование типа "что".<br>   Многие страницы этой книги могут служить хорошей иллюстрацией того различия, которое существует между этими двумя стилями программистского мышления. Например, в первой главе это различие иллюстрируется на задачах, относящихся к семейным отношениям. Прологовский программист дает простое и естественное описание понятия "дедушка": дедушка — это отец родителя. На Прологе это выглядит так:<br>   дедушка( X, Z) :- отец( X, Y), родитель( Y, Z).<br>   Как только пролог-система узнала, что такое дедушка, ей можно задать вопрос, например: кто является дедушкой Патрика? В обозначениях Пролога этот вопрос и типичный ответ имеют вид:<br>   ?-  дедушка( X, патрик).<br>   X = джеймс;<br>
		 <br>   X = карл.<br>   Каким образом решать эту задачу, как "прочесывать" базу данных, в которой записаны все известные отношения "отец" и "родитель", — это уже забота самой пролог-системы. Программист только сообщает системе то, что ему известно, и задает вопросы. Его в большей степени интересуют знания и в меньшей — алгоритмы, при помощи которых из этих знаний извлекается нужная информация.<br>   Поняв, что очень важно научиться Прологу, естественно задать себе следующий вопрос — как это сделать. Я убежден, что изучение языка программирования во многом сходно с изучением естественного языка. Так, например, в первом случае может пригодиться инструкция по программированию точно так же, как во втором — словарь. Но никто не изучает язык при помощи словаря, так как слова — это только часть знаний, необходимых для овладения языком. Изучающий язык должен кроме того узнать те соглашения, следуя которым, можно получать осмысленные сочетания слов, а затем научиться у мастеров слова искусству литературного стиля.<br>   Точно так же, никто не изучает язык программирования, пользуясь только инструкцией по программированию, так как в инструкциях очень мало или вообще ничего не говорится о том, как хорошие программисты используют элементарные конструкции языка. Поэтому необходим учебник, причем лучшие учебники обычно предлагают читателю богатый набор примеров. Ведь в хороших примерах сконцентрирован опыт лучших программистов, а именно на опыте мы, в основном, и учимся.<br>   В этой книге первый пример появляется уже на первой странице, а далее на читателя как из рога изобилия обрушивается поток примеров прологовских программ, написанных программистом-энтузиастом, горячим приверженцем прологовской идеологии программирования. После тщательного изучения этих примеров читатель не только узнает, как "работает" Пролог, но и станет обладателем личной коллекции программ-прецедентов, готовых к употреблению: он может разбирать эти программы на части, приспосабливать каждую часть к своей задаче, а затем снова собирать их вместе, получая при этом новые программы. Такое усвоение предшествующего опыта можно считать первым шагом на пути от новичка к программисту-мастеру.<br>   Изучение хороших программных примеров дает, как правило, один полезный побочный эффект: мы узнаем из них не только очень многое о самом программировании, но и кое-что - о какой-нибудь интересной научной области. В данной книге такой научной областью, стоящей за большинством примеров, является искусственный интеллект. Читатель узнает о таких идеях в области автоматического решения задач, как сведение задач к подзадачам, прямое и обратное построение цепочки рассуждений, ответы на вопросы "как" и "почему", а также разнообразные методы поиска.<br>   Одним из замечательных свойств Пролога является то, что это достаточно простой язык, и студенты могли бы использовать его непосредственно в процессе изучения вводного курса по искусственному интеллекту. Я не сомневаюсь, что многие преподаватели включат эту книгу в свои курсы искусственного интеллекта с тем, чтобы студенты смогли увидеть, как при помощи Пролога абстрактные идеи приобретают конкретные и действенные формы.<br>   Полагаю, что среди учебников по Прологу эта книга окажется особенно популярной, и не только из-за своих хороших примеров, но также из-за целого ряда других своих привлекательных черт:<br>   • тщательно составленные резюме появляются на всем протяжении книги;<br>   • все вводимые понятия подкрепляются многочисленными упражнениями;<br>   • процедуры выборки элементов структур подводят нас к понятию абстракции данных;<br>   • обсуждение вопросов стиля и методологии программирования занимает целую главу;<br>   • автор не только показывает приятные свойства языка, но и со всей откровенностью обращает наше внимание на трудные проблемы, возникающие при программировании на Прологе.<br>   Все это говорит о том, что перед нами прекрасно написанная, увлекательная и полезная книга.<br><blockquote>
<blockquote><i>Патрик Г. Уинстон</i></blockquote>
<blockquote><i>Кеймбридж, Массачусетс </i></blockquote>
</blockquote>
</div>
<h1 align="center">
<a name="TOC_id3495328"></a>Предисловие автора <br></h1>
<div>   Язык программирования Пролог базируется на ограниченном наборе механизмов, включающих в себя сопоставление образцов, древовидное представление структур данных и автоматический возврат. Этот небольшой набор образует удивительно мощный и гибкий программный аппарат. Пролог особенно хорошо приспособлен для решения задач, в которых фигурируют объекты (в частности, структуры) и отношения между ними. Например, в качестве легкого упражнения, можно попробовать выразить на Прологе пространственные отношения между объектами, изображенными на обложке этой книги. Пример такого отношения: верхний шар расположен дальше, чем левый шар. Нетрудно также сформулировать и более общее положение в виде следующего правила: если X ближе к наблюдателю, чем Y, a Y — ближе, чем Z, то объект X находится ближе, чем Z. Пользуясь правилами и фактами, пролог-система может проводить рассуждения относительно имеющихся пространственных отношений и, в частности, проверить, насколько они согласуются с вышеуказанным общим правилом. Все эти возможности придают Прологу черты мощного языка для решения задач искусственного интеллекта, а также любых задач, требующих нечислового программирования.<br>   Само название <i>Пролог</i> есть сокращение, означающее <i>программирование в терминах логики</i>. Идея использовать логику в качестве языка программирования возникла впервые в начале 70-x годов. Первыми исследователями, разрабатывавшими эту идею, были Роберт Ковальский из Эдинбурга (теоретические аспекты), Маартен ван Эмден из Эдинбурга (экспериментальная демонстрационная система) и Ален Колмероэ из Марселя (реализация). Сегодняшней своей популярности Пролог во многом обязан эффективной реализации этого языка, полученной в Эдинбурге Дэвидом Уорреном в середине 70-x годов.<br>   Поскольку Пролог уходит своими корнями в математическую логику, его преподавание часто начинают с изложения логики. Однако такое введение в Пролог, насыщенное математическими понятиями, приносит мало пользы в том случае, когда Пролог изучается в качестве практического инструмента программирования. Поэтому в данной книге мы не будем заниматься математическими аспектами этого языка, вместо этого мы сосредоточим свое внимание на навыках использования базовых механизмов Пролога, для решения целого ряда содержательных задач. В то время, как традиционные языки программирования являются процедурно-ориентированными, Пролог основан на описательной или <i>декларативной</i> точке зрения на программирование. Это свойство Пролога коренным образом меняет программистское мышление и делает обучение программированию на Прологе увлекательным занятием, требующим определенных интеллектуальных усилий.<br>   В первой части книги содержится введение в Пролог, в ней показано, как составлять программы на Прологе. Во второй части демонстрируется, как мощные средства языка применяются в некоторых областях искусственного интеллекта, таких как, например, решение задач, эвристический поиск, экспертные системы, машинные игры и системы, управляемые образцами. В этой части излагаются фундаментальные методы в области искусственного интеллекта. Далее они прорабатываются достаточно глубоко для того, чтобы реализовать их на Прологе и получить готовые программы. Эти программы можно использовать в качестве "кирпичиков" для построения сложных прикладных систем. В книге рассматриваются также вопросы обработки таких сложных структур данных, как графы и деревья, хотя эти вопросы, строго говоря, и не имеют прямого отношения к искусственному интеллекту. В программах искусственного интеллекта методы обработки структур применяются довольно часто, и, реализуя их, читатель приобретет самые общие навыки программирования на Прологе. В книге особое внимание уделяется простоте и ясности составляемых программ. Повсеместно мы стремились избегать программистских "хитростей", повышающих эффективность за счет учета особенностей конкретной реализации Пролога.<br>   Эта книга предназначена для тех, кто изучает Пролог и искусственный интеллект. Материал книги можно использовать в курсе лекций по искусственному интеллекту, ориентированном на прологовскую реализацию. Предполагается, что читатель имеет общее представление о вычислительных машинах, но предварительные знания в области искусственного интеллекта необязательны. От читателя не требуется также какого-либо программистского опыта. Дело в том, что богатый программистский опыт вместе с приверженностью к традиционному процедурному программированию (например, на Паскале) может стать помехой при изучении Пролога, требующего свежего программистского мышления.<br>   Среди различных диалектов Пролога наиболее широко распространен так называемый эдинбургский синтаксис (или синтаксис DEC-10), который мы я принимаем в данной книге. Для того, чтобы обеспечить совместимость с различными реализациями Пролога, мы используем в книге сравнительно небольшое подмножество встроенных средств, имеющихся во многих вариантах Пролога.<br>   Как читать эту книгу? В первой части порядок чтения естественным образом совпадает с порядком изложения, принятым в книге. Впрочем, часть разд. 2.4, в которой дается более формальное описание процедурной семантики Пролога, можно опустить. В главе 4 приводятся примеры программ, которые можно читать только выборочно. Вторая часть книги допускает более гибкий порядок чтения, поскольку различные главы этой части предполагаются взаимно независимыми. Однако некоторые из тем было бы естественным прочесть раньше других - это относится к основным понятиям, связанным со структурами данных (гл. 9), и к базовым стратегиям поиска (гл. 11 и 13). В приведенной ниже диаграмме показана наиболее естественная последовательность чтения глав.<br>   <img border="0" src="_4.png"><br>   Существует целый ряд исторически сложившихся и противоречащих друг другу взглядов на Пролог. Пролог быстро завоевал популярность в Европе как практический инструмент программирования. В Японии Пролог оказался в центре разработки компьютеров пятого поколения. С другой стороны, в связи с определенными историческими факторами, в США Пролог получил признание несколько позднее. Один из этих факторов был связан с предварительным знакомством с Микропленнером, языком, близким к логическому программированию, но реализованным не эффективно. Этот отрицательный опыт, относящийся к Микропленнеру, был неоправданно распространен и на Пролог, но позднее, после появления эффективной реализации, предложенной Дэвидом Уорреном, это предубеждение было убедительно снято. Определенная сдержанность по отношению к Прологу объяснялась также существованием "ортодоксальной школы" логического программирования, сторонники которой настаивали на использовании чистой логики, не запятнанной добавлением практически полезных внелогических средств. Практикам в области применения Пролога удалось изменить эту бескомпромиссную позицию и принять более прагматический подход, позволивший удачно сочетать декларативный принцип с традиционным - процедурным. И наконец, третьим фактором, приведшим к задержке признания Пролога, явилось то обстоятельство, что в США в течение долгого времени Лисп не имел серьезных конкурентов среди языков искусственного интеллекта. Понятно поэтому, что в исследовательских центрах с сильными лисповскими традициями возникало естественное противодействие Прологу. Но со временем соперничество между Прологом и Лиспом потеряло свою остроту, и в настоящее время многие считают, что оптимальный подход состоит в сочетании идей, лежащих в основе этих двух языков.<br><h5>Благодарности</h5>   Интерес к Прологу впервые возник у меня под влиянием Дональда Мики. Я благодарен также Лоренсу Берду, Фернандо Перейра и Дэвиду Г. Уоррену, входившим в свое время в эдинбургскую группу разработчиков Пролога, за их советы по составлению программ и многочисленные дискуссии. Чрезвычайно полезными были замечания и предложения, высказанные Эндрью Макгеттриком и Патриком Уинстоном. Среди прочитавших рукопись книги и сделавших ценные замечания были также Игорь Кононенко, Таня Маярон, Игорь Мозетик, Тимоти Ниблетт и Фрэнк Зердин. Мне бы хотелось также поблагодарить Дебру Майсон-Этерингтон и Саймона Пламтри из издательства Эддисон-Уэсли за труд, вложенный в издание этой книги. И наконец, эта книга не могла бы появиться на свет без стимулирующего влияния творческой деятельности всего международного сообщества специалистов по логическому программированию.<br><blockquote>
<blockquote><i>Иван Братко</i></blockquote>
<blockquote><i>Институт Тьюринга, Глазго</i></blockquote>
<blockquote><i>Январь 1986 </i></blockquote>
</blockquote>
</div>
<h1 align="center">
<a name="TOC_id3426250"></a>Часть 1<br>Язык Пролог<br></h1>
<div>
<div align="center"><img border="1" src="_5.png"></div>
<h2 align="center">
<a name="TOC_id3399655"></a>Глава 1<br>Общий обзор языка Пролог<br></h2>
<div>
<div>   В этой главе на примере конкретной программы рассматриваются основные механизмы Пролога. Несмотря на то, что материал излагается в основном неформально, здесь вводятся многие важные понятия.<br></div>
<h3 align="center">
<a name="TOC_id3399670"></a>1.1. Пример программы: родственные отношения<br></h3>
<div>   Пролог — это язык программирования, предназначенный для обработки символьной нечисловой информации. Особенно хорошо он приспособлен для решения задач, в которых фигурируют объекты и отношения между ними. На рис. 1.1 представлен пример — родственные отношения. Тот факт, что Том является родителем Боба, можно записать на Прологе так:<br>   родитель( том, боб).<br>   Здесь мы выбрали родитель в качестве имени отношения, том и боб — в качестве аргументов этого отношения. По причинам, которые станут понятны позднее, мы записываем такие имена, как том, начиная со строчной буквы. Все дерево родственных отношений рис. 1.1 описывается следующей пролог-программой:<br>   родитель( пам, боб).<br>   родитель( том, боб).<br>   родитель( том, лиз).<br>   родитель( боб, энн).<br>   родитель( боб, пат).<br>   родитель( пам, джим).<br><div align="center"><img border="1" src="_6.png"></div>   <b>Рис. 1.1.</b>  Дерево родственных отношений.<br>   Эта программа содержит шесть <i>предложений</i>. Каждое предложение объявляет об одном факте наличия отношения родитель.<br>   После ввода такой программы в пролог-систему последней можно будет задавать вопросы, касающиеся отношения <b><b>родитель</b></b>. Например, является ли Боб родителем Пат? Этот вопрос можно передать пролог-системе, набрав на клавиатуре терминала:<br>   ?-  родитель( боб, пат).<br>   Найдя этот факт в программе, система ответит<br>   yes         (да)<br>   Другим вопросом мог бы быть такой:<br>   ?-  родитель( лиз, пат).<br>   Система ответит<br>   no             (нет),<br>   поскольку в программе ничего не говорится о том, является ли Лиз родителем Пат. Программа ответит "нет" и на вопрос<br>   ?-  родитель( том, бен).<br>   потому, что имя Бен в программе даже не упоминается.<br>   Можно задавать и более интересные вопросы. Например:"Кто является родителем Лиз?"<br>   ?-  родитель( X, лиз).<br>   На этот раз система ответит не просто "да" или "нет". Она скажет нам, каким должно быть значение X (ранее неизвестное), чтобы вышеприведенное утверждение было истинным. Поэтому мы получим ответ:<br>   X  =  том<br>   Вопрос "Кто дети Боба?" можно передать пролог-системе в такой форме:<br>   ?-  родитель( боб, X).<br>   В этом случае возможно несколько ответов. Сначала система сообщит первое решение:<br>   X  =  энн<br>   Возможно, мы захотим увидеть и другие решения. О нашем желании мы можем сообщить системе (во многих реализациях для этого надо набрать точку с запятой), и она найдет другой ответ:<br>   X  =  пат<br>   Если мы потребуем дальнейших решений, система ответит "нет", поскольку все решения исчерпаны.<br>   Нашей программе можно задавать и более общие вопросы: "Кто чей родитель?" Приведем другую формулировку этого вопроса:<br>   Найти X и Y такие, что X — родитель Y.<br>   На Прологе это записывается так:<br>   ?-  родитель( X, Y).<br>   Система будет по очереди находить все пары вида "родитель-ребенок". По мере того, как мы будем требовать от системы новых решений, они будут выводиться на экран одно за другим до тех пор, пока все они не будут найдены. Ответы выводятся следующим образом:<br>   X  =  пам<br>   Y  =  боб;<br>
		 <br>   X  =  том<br>   Y  =  боб;<br>
		 <br>   X  =  том<br>   Y  =  лиз;<br>   ...<br>   Мы можем остановить поток решений, набрав, например, точку вместо точки с запятой (выбор конкретного символа зависит от реализации).<br>   Нашей программе можно задавать и еще более сложные вопросы, скажем, кто является родителем родителя Джима? Поскольку в нашей программе прямо не сказано, что представляет собой отношение родительродителя, такой вопрос следует задавать в два этапа, как это показано на рис. 1.2.<br>   (1)    Кто родитель Джима?   Предположим, что это некоторый Y.<br>   (2)    Кто родитель Y?   Предположим, что это некоторый X.<br>   Такой составной вопрос на Прологе записывается в виде последовательности двух простых вопросов:<br>   ?-  родитель( Y, джим), родитель( X, Y).<br>   Ответ будет:<br>   X  =  боб<br>   Y  =  пат<br>
		 <br><div align="center"><img border="1" src="_7.png"></div>   <b>Рис. 1.2.</b> Отношение родительродителя, выраженное через композицию двух отношений родитель.<br>   Наш составной вопрос можно интерпретировать и так: "Найти X и Y, удовлетворяющие следующим двум требованиям":<br>   родитель( Y, джим) и родитель( X, Y)<br>   Если мы поменяем порядок этих двух требований, то логический смысл останется прежним:<br>   родитель( X, Y) и родитель( Y, джим)<br>   Этот вопрос можно задать нашей пролог-системе и в такой форме:<br>   ?-  родитель( X, Y), родитель( Y, джим).<br>   При этом результат будет тем же. Таким же образом можно спросить: "Кто внуки Тома?"<br>   ?-  родитель( том, X), родитель( X, Y).<br>   Система ответит так:<br>   X  =  боб<br>   Y  =  энн;<br>
		 <br>   X  =  боб<br>   Y  =  пат<br>   Следующим вопросом мог бы быть такой: "Есть ли у Энн и Пат общий родитель?" Его тоже можно выразить в два этапа:<br>   (1)    Какой X является родителем Энн?<br>   (2)    Является ли (тот же) X родителем Пат?<br>   Соответствующий запрос к пролог-системе будет тогда выглядеть так:<br>   ?-  родитель( X, энн), родитель( X, пат).<br>   Ответ:<br>   X  =  боб<br>   Наша программа-пример помогла проиллюстрировать некоторые важные моменты:<br>   • На Прологе легко определить отношение, подобное отношению родитель, указав <i>n</i>-ку объектов, для которых это отношение выполняется.<br>   • Пользователь может легко задавать пролог-системе вопросы, касающиеся отношений, определенных в программе.<br>   • Пролог-программа состоит из предложений. Каждое предложение заканчивается точкой.<br>   • Аргументы отношения могут быть (среди прочего): конкретными объектами, или константами (такими, как том и энн), или абстрактными объектами, такими, как X и Y. Объекты первого типа называются <i>атомами</i>. Объекты второго типа — <i>переменными</i>.<br>   • Вопросы к системе состоят из одного или более целевых утверждений (или кратко <i>целей</i>). Последовательность целей, такая как<br>   родитель( X, энн), родитель( X, пат)<br>   означает конъюнкцию этих целевых утверждений:<br>   X  —  родитель Энн <i>  и</i><br>   X  —  родитель Пат.<br>   Пролог-система рассматривает вопросы как цели, к достижению которых нужно стремиться.<br>   • Ответ на вопрос может оказаться или положительным или отрицательным в зависимости от того, может ли быть соответствующая цель достигнута или нет. В случае положительного ответа мы говорим, что соответствующая цель <i>достижима</i> и <i>успешна</i>. В противном случае цель <i>  недостижима</i>, <i>  имеет неуспех</i>   или   <i>терпит неудачу</i>.<br>   • Если на вопрос существует несколько ответов, пролог-система найдет столько из них, сколько пожелает пользователь.<br><h5>Упражнения</h5>   <b>1.1.</b> Считая, что отношение родитель определено так же, как и раньше в данном разделе (см. рис. 1.1), найдите, какими будут ответы пролог-системы на следующие вопросы:<br>   (a)  ?-  родитель( джим, X).<br>   (b)  ?-  родитель( X, джим).<br>   (c)  ?-  родитель( пам,X), родитель( X, пат).<br>   (d)  ?-  родитель( пам, X), родитель( X, Y),<br>          родитель( Y, джим).<br>   <b>1.2.</b>  Сформулируйте на Прологе следующие вопросы об отношении родитель:<br>   (a)  Кто родитель Пат?<br>   (b)  Есть ли у Лиз ребенок?<br>   (c)  Кто является родителем родителя Пат? <br></div>
<h3 align="center">
<a name="TOC_id3499040"></a>1.2. Расширение программы-примера с помощью правил<br></h3>
<div>   Нашу программу-пример можно легко расширить многими интересными способами. Давайте сперва добавим информацию о том, каков пол людей, участвующих в отношении родитель. Это можно сделать, просто добавив в нее следующие факты:<br>   женщина( пам).<br>   мужчина( том).<br>   мужчина( боб).<br>   женщина( лиз).<br>   женщина( пат).<br>   женщина( энн).<br>   мужчина( джим).<br>   Мы ввели здесь два новых отношения — мужчина и женщина. Эти отношения — унарные (или одноместные). Бинарное отношение, такое как родитель, определяет отношение между <i>двумя</i> объектами; унарные же можно использовать для объявления наличия (отсутствия) простых свойств у объектов. Первое из приведенных выше предложений читается так: Пам — женщина. Можно было бы выразить информацию, представляемую этими двумя унарными отношениями (мужчина и женщина), по-другому - с помощью одного бинарного отношения пол. Тогда новый фрагмент нашей программы выглядел бы так:<br>   пол( пам, женский).<br>   пол( том, мужской).<br>   пол( боб, мужской).<br>   ...<br>   В качестве дальнейшего расширения нашей программы-примера давайте введем отношение отпрыск, которое обратно отношению родитель. Можно было бы определить отпрыск тем же способом, что и родитель, т.е. представив список простых фактов наличия этого отношения для конкретных пар объектов, таких, что один является отпрыском другого. Например:<br>   отпрыск( лиз, том).<br>   Однако это отношение можно определить значительно элегантнее, использовав тот факт, что оно обратно отношению родитель, которое уже определено. Такой альтернативный способ основывается на следующем логическом утверждении:<br>   Для всех X и Y<br>    Y является отпрыском X, если<br>    X является родителем Y.<br>   Эта формулировка уже близка к формализму, принятому в Прологе. Вот соответствующее прологовское предложение, имеющее тот же смысл:<br>   отпрыск( Y, X) :- родитель( X, Y).<br>   Это предложение можно прочитать еще и так:<br>   Для всех X и Y,<br>     если X — родитель Y, то<br>     Y — отпрыск X.<br>   Такие предложения Пролога, как<br>   отпрыск( Y, X) :- родитель( X, Y).<br>   называются <i>правилами</i>. Есть существенное различие между фактами и правилами. Факт, подобный факту<br>   родитель( том, лиз).<br>   это нечто такое, что всегда, безусловно истинно. Напротив, правила описывают утверждения, которые могут быть истинными, только если выполнено некоторое условие. Поэтому можно сказать, что правила имеют<br>   • условную часть (правая половина правила) и<br>   • часть вывода (левая половина правила).<br>   Вывод называют также <i>головой</i> предложения, а условную часть — его <i>телом</i>. Например:<br>   отпрыск( Y, X) :- родитель( X, Y).<br>   <i>голова            тело</i><br>   Если условие родитель( X, Y) выполняется (оно истинно), то логическим следствием из него является утверждение отпрыск( Y, X).<br>   На приведенном ниже примере проследим, как в действительности правила используются Прологом. Спросим нашу программу, является ли Лиз отпрыском Тома:<br>   ?- отпрыск( лиз, том).<br>   В программе нет фактов об отпрысках, поэтому единственный способ ответить на такой вопрос — это применить правило о них. Правило универсально в том смысле, что оно применимо к любым объектам X и Y, следовательно, его можно применить и к таким конкретным объектам, как лиз и том. Чтобы это сделать, нужно вместо Y подставить в него лиз, а вместо X — том. В этом случае мы будем говорить, что переменные X и Y конкретизируются:<br>   X = том и Y = лиз<br>   После конкретизации мы получаем частный случай нашего общего правила. Вот он:<br>   отпрыск( лиз, том) :- родитель( том, лиз).<br>   Условная часть приняла вид:<br>   родитель( том, лиз)<br>   Теперь пролог-система попытается выяснить, выполняется ли это условие (является ли оно истинным). Для этого исходная цель<br>   отпрыск( лиз, том)<br>   заменяется подцелью<br>   родитель( том, лиз)<br>   Эта (новая) цель достигается тривиально, поскольку такой факт можно найти в нашей программе. Это означает, что утверждение, содержащееся в выводе правила, также истинно, и система ответит на вопрос yes (да).<br>   Добавим теперь в нашу программу-пример еще несколько родственных отношений. Определение отношения мать может быть основано на следующем логическом утверждении:<br>   Для всех X и Y<br>     X является матерью Y, если<br>     X является родителем Y и<br>     X — женщина.<br>   На Пролог это переводится в виде такого правила:<br>   мать( X, Y) :- родитель( X, Y), женщина( X).<br>   Запятая между двумя условиями указывает на конъюнкцию условий. Это означает, что они должны быть выполнены оба одновременно.<br><div align="center"><img border="1" src="_8.png"></div>   <b>Рис. 1.3.</b>  Графы отношений родительродителя, мать и отпрыск, определенных через другие отношения.<br>   Такие отношения как родитель, отпрыск и мать можно изобразить в виде диаграмм, приведенных на рис. 1.3. Они нарисованы с учетом следующих соглашений. Вершины графа соответствуют объектам, т.е. аргументам отношений. Дуги между вершинами соответствуют бинарным (двуместным) отношениям. Дуги направлены от первого аргумента к второму. Унарные отношения на диаграмме изображаются просто пометкой соответствующих объектов именем отношения. Отношения, определяемые через другие отношения, представлены штриховыми дугами. Таким образом, любую диаграмму следует понимать так: если выполнены отношения, изображенные сплошными дугами, тогда и отношение, изображенное штриховой дугой, тоже выполнено. В соответствии с рис. 1.3, отношение родительродителя можно сразу записать на Прологе:<br>   родительродителя( X, Z) :- родитель( X, Y),<br>                              родитель( Y, Z).<br>   Здесь уместно сделать несколько замечаний о внешнем виде нашей программы. Пролог дает почти полную свободу расположения текста на листе. Так что можно вставлять пробелы и переходить к новой строке в любом месте текста по вкусу. Вообще мы хотим сделать так, чтобы наша программа имела красивый и аккуратный вид, а самое главное, легко читалась. Для этого мы часто будем помещать голову предложения и каждую цель на отдельной строке. При этом цели мы будем писать с отступом, чтобы сделать разницу между головой и целями более заметной. Например, правило родительродителя в соответствии с этими соглашениями запишется так:<br>   родительродителя( X, Z) :-<br>    родитель( X, Y),<br>    родитель( Y, Z).<br>   На рис. 1.4 показано отношение сестра:<br>   Для любых X и Y<br>     X является сестрой Y, если<br>     (1)  у X и Y есть общий родитель, и<br>     (2)  X — женщина.<br><div align="center"><img border="1" src="_5.png"></div>   <b>Рис. 1.4.</b> Определение отношения сестра.<br>   Граф на рис. 1.4 можно перевести на Пролог так:<br>   сестра( X, Y) :-<br>    родитель( Z, X),<br>    родитель( Z, Y),<br>    женщина( X).<br>   Обратите внимание на способ, с помощью которого выражается требование "у X и Y есть общий родитель". Была использована следующая логическая формулировка: "некоторый Z должен быть родителем X и <i>этот же самый</i> Z должен быть родителем Y". По-другому, менее красиво, можно было бы сказать так: "Z1 - родитель X, Z2 - родитель Y и Z1 равен Z2".<br>   Теперь можно спросить:<br>   ?- сестра( энн, пат).<br>   Как и ожидается, ответ будет "yes" (да) (см. рис. 1.1). Мы могли бы заключить отсюда, что определенное нами отношение сестра работает правильно. Тем не менее в нашей программе есть маленькое упущение, которое обнаружится, если задать вопрос: "Кто является сестрой Пат?"<br>   ?-  сестра( X, пат).<br>   Система найдет два ответа, один из которых может показаться неожиданным:<br>   X = энн;<br>   X = пат<br>   Получается, что Пат — сестра себе самой?! Наверное, когда мы определяли отношение сестра, мы не имели этого ввиду. Однако ответ Пролога совершенно логичен, поскольку он руководствовался нашим правилом, а это правило ничего не говорит о том, что, если X — сестра Y, то X и Y не должны совпадать. Пролог (с полным правом) считает, что X и Y могут быть одним и тем же объектом и в качестве следствия из этого делает вывод, что любая женщина, имеющая родителя, является сестрой самой себе.<br>   Чтобы исправить наше правило о сестрах, его нужно дополнить утверждением, что X и Y должны различаться. В следующих главах мы увидим, как это можно сделать, в данный же момент мы предположим, что отношение различны уже известно пролог-системе и что цель<br>   различны( X, Y)<br>   достигается тогда и только тогда, когда X и Y не равны. Усовершенствованное правило для отношения сестра примет тогда следующий вид:<br>   сестра( X, Y) :-<br>    родитель( Z, X),<br>    родители( Z, Y),<br>    женщина( X),<br>    различны( X, Y).<br>   Некоторые важные моменты этого раздела:<br>   • Пролог-программы можно расширять, добавляя в них новые предложения.<br>   • Прологовские предложения бывают трех типов: <i>факты</i>, <i>правила </i>и <i>вопросы</i>.<br>   • <i>Факты</i> содержат утверждения, которые являются всегда, безусловно верными.<br>   • <i>Правила</i> содержат утверждения, истинность которых зависит от некоторых условий.<br>   • С помощью <i>вопросов</i> пользователь может спрашивать систему о том, какие утверждения являются истинными.<br>   • Предложения Пролога состоят из <i>головы </i>и <i>тела</i>. Тело — это список <i>целей</i>, разделенных запятыми. Запятая понимается как конъюнкция.<br>   • Факты — это предложения, имеющие пустое тело. Вопросы имеют только тело. Правила имеют голову и (непустое) тело.<br>   • По ходу вычислений вместо переменной может быть подставлен другой объект. Мы говорим в этом случае, что переменная <i>конкретизирована</i>.<br>   Предполагается, что на переменные действует квантор всеобщности, читаемый как "для всех…". Однако для переменных, появляющихся только в теле, возможны и другие формулировки. Например,<br>   имеетребенка( X) :- родитель( X, Y).<br>   можно прочитать двумя способами:<br>   (а) <i>Для всех</i> X и Y,<br>        если X — отец Y, то<br>        X имеет ребенка.<br>   (б) <i>Для всех</i> X,<br>        X имеет ребенка, если<br>        существует <i>некоторый</i> Y, такой, что<br>        X — родитель Y.<br><h5>Упражнения</h5>   <b>1.3.</b> Оттранслируйте следующие утверждения в правила на Прологе:<br>   (a) Всякий, кто имеет ребенка, — счастлив (введите одноаргументное отношение счастлив).<br>   (b) Всякий X, имеющий ребенка, у которого есть сестра, имеет двух детей (введите новое отношение иметьдвухдетей).<br>   <b>1.4.</b> Определите отношение внук, используя отношение родитель. Указание: оно будет похоже на отношение родительродителя (см. рис. 1.3).<br>   <b>1.5.</b> Определите отношение тетя( X, Y) через отношение родитель и сестра. Для облегчения работы можно сначала изобразить отношение тетя в виде диаграммы по типу тех, что изображены на рис. 1.3. <br></div>
<h3 align="center">
<a name="TOC_id3491356"></a>1.3. Рекурсивное определение правил<br></h3>
<div>   Давайте добавим к нашей программе о родственных связях еще одно отношение — <b>предок</b>. Определим его через отношение родитель. Все отношение можно выразить с помощью двух правил. Первое правило будет определять непосредственных (ближайших) предков, а второе — отдаленных. Будем говорить, что некоторый является отдаленным предком некоторого Z, если между X и Z существует цепочка людей, связанных между собой отношением родитель-ребенок, как показано на рис.1.5. В нашем примере на рис. 1.1 Том — ближайший предок Лиз и отдаленный предок Пат.<br><div align="center"><img border="1" src="_10.jpg_0"></div>   <b>Рис. 1.5.</b> Пример отношения предок: (а) X — <i>ближайший</i> предок Z; (b) X — отдаленный предок Z.<br>   Первое правило простое и его можно сформулировать так:<br>   Для всех X и Z,<br>     X — предок Z, если<br>     X — родитель Z.<br>   Это непосредственно переводится на Пролог как<br>   предок( X, Z) :-<br>    родитель( X, Z).<br>   Второе правило сложнее, поскольку построение цепочки отношений родитель может вызвать некоторые трудности. Один из способов определения отдаленных родственников мог бы быть таким, как показано на рис. 1.6. В соответствии с ним отношение предок определялось бы следующим множеством предложений:<br>   предок( X, Z) :-<br>    родитель( X, Z).<br>
		 <br>   предок( X, Z) :-<br>    родитель( X, Y),<br>    родитель( Y, Z).<br>
		 <br>   предок( X, Z) :-<br>    родитель( X, Y1),<br>    родитель( Yl, Y2),<br>    родитель( Y2, Z).<br>
		 <br>   предок( X, Z) :-<br>    родитель( X, Y1),<br>    родитель( Y1, Y2),<br>    родитель( Y2, Y3),<br>    родитель( Y3, Z).<br>
		 <br>   ...<br><div align="center"><img border="1" src="_11.png"></div>   <b>Рис. 1.6.</b> Пары предок-потомок, разделенных разным числом поколений.<br>   Эта программа длинна и, что более важно, работает только в определенных пределах. Она будет обнаруживать предков лишь до определенной глубины фамильного дерева, поскольку длина цепочки людей между предком и потомком ограничена длиной наших предложений в определении отношения.<br>   Существует, однако, корректная и элегантная формулировка отношения предок — корректная в том смысле, что будет работать для предков произвольной отдаленности. Ключевая идея здесь — определить отношение предок через него самого. Рис 1.7 иллюстрирует эту идею:<br>   Для всех X и Z,<br>     X — предок Z, если<br>    существует Y, такой, что<br>    (1)  X — родитель Y и<br>    (2)  Y — предок Z.<br>   Предложение Пролога, имеющее тот же смысл, записывается так:<br>   предок( X, Z) :-<br>    родитель( X, Y),<br>    предок( Y, Z).<br>   Теперь мы построили полную программу для отношения предок, содержащую два правила: одно для ближайших предков и другое для отдаленных предков. Здесь приводятся они оба вместе:<br>   предок( X, Z) :-<br>    родитель( X, Z).<br>
		 <br>   предок( X, Z) :-<br>    родитель( X, Y),<br>    предок( Y, Z).<br>
		 <br><div align="center"><img border="1" src="_12.png"></div>   <b>Рис. 1.7.</b>  Рекурсивная формулировка отношения предок.<br>   Ключевым моментом в данной формулировке было использование самого отношения предок в его определении. Такое определение может озадачить - допустимо ли при определении какого-либо понятия использовать его же, ведь оно определено еще не полностью. Такие определения называются <i>рекурсивными</i>. Логически они совершенно корректны и понятны; интуитивно это ясно, если посмотреть на рис. 1.7. Но будет ли в состоянии пролог-система использовать рекурсивные правила? Оказывается, что пролог-система очень легко может обрабатывать рекурсивные определения. На самом деле, рекурсия — один из фундаментальных приемов программирования на Прологе. Без рекурсии с его помощью невозможно решать задачи сколько-нибудь ощутимой сложности.<br>   Возвращаясь к нашей программе, можно теперь задать системе вопрос: "Кто потомки Пам?" То есть: "Кто тот человек, чьим предком является Пам?"<br>   ?-  предок( пам, X).<br>
		 <br>   X  =  боб;<br>   X  =  энн;<br>   X  =  пат;<br>   X  =  джим<br>   Ответы системы, конечно, правильны, и они логически вытекают из наших определений отношений предок и родитель. Возникает, однако, довольно важный вопрос: "<i>Как</i> в действительности система использует программу для отыскания этих ответов?"<br>   Неформальное объяснение того, как система это делает, приведено в следующем разделе. Но сначала давайте объединим все фрагменты нашей программы о родственных отношениях, которая постепенно расширялась по мере того, как мы вводили в нее новые факты и правила. Окончательный вид программы показан на рис. 1.8.<br>   При рассмотрении рис. 1.8 следует учесть два новых момента: первый касается понятия "процедура", второй — комментариев в программах. Программа, приведенная на рис. 1.8, определяет несколько отношений — родитель, мужчина, женщина, предок и т.д. Отношение предок, например, определено с помощью двух предложений. Будем говорить, что эти два предложения входят в состав отношения предок. Иногда бывает удобно рассматривать в целом все множество предложений, входящих в состав одного отношения. Такое множество называется <i>процедурой</i>.<br>   родитель( пам, боб). % Пам - родитель Боба<br>   родитель( том, боб).<br>   родитель( том, лиз).<br>   родитель( бoб, энн).<br>   родитель( боб, пат).<br>   родитель( пат, джим).<br>
		 <br>   женщина( пам).       % Пам - женщина<br>   мужчина( том).       % Том - мужчина<br>   мужчина( боб).<br>   женщина( лиз).<br>   женщина( энн).<br>   женщина( пат).<br>   мужчина( джим).<br>
		 <br>   отпрыск( Y, X) :-    % Y - отпрыск X, если<br>    родитель( X, Y).    % X - родитель Y<br>
		 <br>   мать( X, Y) :-       % X - мать Y, если<br>    родитель( X, Y),    % X - родитель Y и<br>    женщина( X).        % X - женщина<br>
		 <br>   родительродителя( X, Z) :-<br>    % X - родитель родителя Z, если<br>    родитель( X, Y),    % X - родитель Y и<br>    родитель( Y, Z).    % Y - родитель Z<br>
		 <br>   сестра( X, Y) :-     % X - сестра Y<br>    родитель( Z, X),<br>    родитель( Z, Y)     % X и Y имеют общего родителя<br>    женщина( X, Y),     % X - женщина и<br>    различны( X, Y).    % X отличается от Y<br>
		 <br>   предок( X, Z) :-     % Правило пр1:  X - предок Z<br>    родитель( X, Z).<br>   предок( X, Z) :-     % Правило пр2:  X - предок Z<br>    родитель( X, Y),<br>    предок( Y, Z).<br>   <b>Рис. 1.8.</b> Программа о родственных отношениях.<br>
		 <br>   На рис. 1.8 два предложения, входящие в состав отношения предок, выделены именами "пр1" и "пр2", добавленными в программу в виде <i>комментариев</i>. Эти имена будут использоваться в дальнейшем для ссылок на соответствующие правила. Вообще говоря, комментарии пролог-системой игнорируются. Они нужны лишь человеку, который читает программу. В Прологе комментарии отделяются от остального текста программы специальными скобками "/*" и "*/". Таким образом, прологовский комментарий выглядит так<br>   /* Это комментарий */<br>   Другой способ, более практичный для коротких комментариев, использует символ процента %. Все, что находится между % и концом строки, расценивается как комментарии:<br>   % Это тоже комментарий<br><h5>Упражнение</h5>   <b>1.6.</b> Рассмотрим другой вариант отношения предок:<br>   предок( X, Z) :-<br>    родитель( X, Z).<br>   предок( X, Z) :-<br>    родитель( Y, Z),<br>    предок( X, Y).<br>   Верно ли и такое определение? Сможете ли Вы изменить диаграмму на рис. 1.7 таким образом, чтобы она соответствовала новому определению?<br></div>
<h3 align="center">
<a name="TOC_id3425101"></a>1.4. Как пролог-система отвечает на вопросы<br></h3>
<div>   В данном разделе приводится неформальное объяснение того, <i>как</i> пролог-система отвечает на вопросы.<br>   Вопрос к системе — это всегда последовательность, состоящая из одной или нескольких целей. Для того, чтобы ответить на вопрос, система пытается достичь всех целей. Что значит достичь цели? Достичь цели — это значит показать, что утверждения, содержащиеся в вопросе, истинны в предположении, что все отношения программы истинны. Другими словами, достичь цели - это значит показать, что она <i>логически</i> следует из фактов и правил программы. Если вопрос содержит переменные, система должна к тому же найти конкретные объекты, которые (будучи подставленными вместо переменных) обеспечивают достижение цели. Найденные конкретизации сообщаются пользователю. Если для некоторой конкретизации система не в состоянии вывести цель из остальных предложений программы, то ее ответом на вопрос будет "нет".<br>   Таким образом, подходящей интерпретацией пролог-программы в математических терминах будет следующая: пролог-система рассматривает факты и правила в качестве множества аксиом, а вопрос пользователя — как <i>теорему</i>; затем она пытается доказать эту теорему, т.е. показать, что ее можно логически вывести из аксиом.<br>   Проиллюстрируем этот подход на классическом примере. Пусть имеются следующие аксиомы:<br>    Все люди смертны.<br>    Сократ — человек.<br>   Теорема, логически вытекающая из этих двух аксиом:<br>    Сократ смертен.<br>   Первую из вышеуказанных аксиом можно переписать так:<br>    Для всех X, если X — человек, то X смертен.<br>   Соответственно наш пример можно перевести на Пролог следующим образом:<br>   смертен( X) :- человек( X). % Все люди смертны<br>   человек( сократ).           % Сократ - человек<br>   ?-  смертен( сократ).       % Сократ смертен?<br>   yes                   (да)<br>   Более сложный пример из программы о родственных отношениях, приведенной на рис. 1.8:<br>   ?- предок( том, пат)<br>   Мы знаем, что родитель( боб, пат) — это факт. Используя этот факт и правило <i>пр1</i>, мы можем сделать вывод, что утверждение предок( боб, пат) истинно. Этот факт получен в результате <i>вывода</i> — его нельзя найти непосредственно в программе, но можно вывести, пользуясь содержащимися в ней фактами и правилами. Подобный шаг вывода можно коротко записать<br>   родитель( боб, пат) ==&gt; предок( боб, пат)<br>   Эту запись можно прочитать так: из родитель( боб, пат) следует предок( боб, пат) на основании правила <i>пр1</i>. Далее, нам известен факт родитель( том, боб). На основании этого факта и выведенного факта предок( боб, пат) можно заключить, что, в силу правила <i>пр2</i>, наше целевое утверждение предок( том, пат) истинно. Весь процесс вывода, состоящий из двух шагов, можно записать так:<br>   родитель(боб, пат) ==&gt; предок( боб, пат)<br>   родитель(том, боб)<i>и</i>   предок( боб, пат) ==&gt;<br>    предок( том, пат)<br>   Таким образом, мы показали, <i>какой</i> может быть последовательность шагов для достижения цели, т.е. для демонстрации истинности целевого утверждения. Назовем такую последовательность цепочкой доказательства. Однако мы еще не показали как пролог-система в действительности строит такую цепочку.<br>   Пролог-система строит цепочку доказательства в порядке, обратном по отношению к тому, которым мы только что воспользовались. Вместо того, чтобы начинать с простых фактов, приведенных в программе, система начинает с целей и, применяя правила, подменяет текущие цели новыми, до тех пор, пока эти новые цели не окажутся простыми фактами. Если задан вопрос<br>   ?-  предок( том, пат).<br>   система попытается достичь этой цели. Для того, чтобы это сделать, она пробует найти такое предложение в программе, из которого немедленно следует упомянутая цель. Очевидно, единственными подходящими для этого предложениями являются <i>пр1</i> и <i>пр2</i>.<br><div align="center"><img border="1" src="_13.png"></div>   <b>Рис. 1.9.</b>  Первый шаг вычислений. Верхняя цель истинна, если истинна нижняя.<br>   Это правила, входящие в отношение предок. Будем говорить, что головы этих правил сопоставимы с целью.<br>   Два предложения <i>пр1</i> и <i>пр2</i> описывают два варианта продолжения рассуждений для пролог-системы. Вначале система пробует предложение, стоящее в программе первым:<br>   предок( X, Z) :- родитель( X, Z).<br>   Поскольку цель — предок( том, пат), значения переменным должны быть приписаны следующим образом:<br>   X = том, Z = пат<br>   Тогда исходная цель предок( том, пат) заменяется новой целью:<br>   родитель( том, пат)<br>   Такое действие по замене одной цели на другую на основании некоторого правила показано на рис. 1.9. В программе нет правила, голова которого была бы сопоставима с целью родитель(том, пат), поэтому такая цель оказывается неуспешной. Теперь система делает <i>возврат</i> к исходной цели, чтобы попробовать второй вариант вывода цели верхнего уровня предок( том, пат). То есть, пробуется правило <i>пр2</i>:<br>   предок( X, Z) :-<br>    родитель( X, Y),<br>    предок( Y, Z).<br>   Как и раньше, переменным X и Z приписываются значения:<br>   X = том, Z = пат<br>   В этот момент переменной Y еще не приписано никакого значения. Верхняя цель предок( том, пат) заменяется двумя целями:<br>   родитель( том, Y),<br>   предок( Y, пат)<br>   Этот шаг вычислений показан на рис. 1.10, который представляет развитие ситуации, изображенной на рис. 1.9.<br><div align="center"><img border="1" src="_14.png"></div>   <b>Рис. 1.10.</b> Продолжение процесса вычислений, показанного на рис. 1.9.<br>   Имея теперь перед собой <i>две </i>цели, система пытается достичь их в том порядке, каком они записаны. Достичь первой из них легко, поскольку она соответствует факту из программы. Процесс установления соответствия — сопоставление (унификация) вызывает приписывание переменной Y значения боб. Тем самым достигается первая цель, а оставшаяся превращается в<br>   предок( боб, пат)<br>   Для достижения этой цели вновь применяется правило <i>пр1</i>. Заметим, — что это (второе) применение правила никак не связано с его первым применением. Поэтому система использует новое множество переменных правила всякий раз, как оно применяется. Чтобы указать это, мы переименуем переменные правила <i>пр1</i> для нового его применения следующим образом:<br>   предок( X', Z') :-<br>    родитель( X', Z').<br>   Голова этого правила должна соответствовать нашей текущей цели предок( боб, пат). Поэтому<br>   X' = боб, Z' = пат<br>   Текущая цель заменяется на<br>   родитель( боб, пат)<br>   Такая цель немедленно достигается, поскольку встречается в программе в качестве факта. Этот шаг завершает вычисление, что графически показано на рис. 1.11.<br><div align="center"><img border="1" src="_15.png"></div>   <b>Рис. 1.11.</b>  Все шаги достижения цели предок( том, пат). Правая ветвь демонстрирует, что цель достижима.<br>   Графическое представление шагов вычисления на рис. 1.11 имеет форму дерева. Вершины дерева соответствуют целям или спискам целей, которые требуется достичь. Дуги между вершинами соответствуют применению (альтернативных) предложений программы, которые преобразуют цель, соответствующую одной вершине, в цель, соответствующую другой вершине. Корневая (верхняя) цель достигается тогда, когда находится путь от корня дерева (верхней вершины) к его листу, помеченному меткой "да". Лист помечается меткой "да", если он представляет собой простой факт. Выполнение пролог-программы состоит в поиске таких путей. В процессе такого поиска система может входить и в ветви, приводящие к неуспеху. В тот момент, когда она обнаруживает, что ветвь не приводит к успеху, происходит автоматический <i>возврат</i> к предыдущей вершине, и далее следует попытка применить к ней альтернативное предложение.<br><h5>Упражнение</h5>   <b>1.7.</b> Постарайтесь понять, как пролог-система, используя программу, приведенную на рис. 1.8, выводит ответы на указанные ниже вопросы. Попытайтесь нарисовать соответствующие диаграммы вывода по типу тех, что изображены на рис.1.9–1.11. Будут ли встречаться возвраты при выводе ответов на какие-либо из этих вопросов?<br>   (a)  ?- родитель( пам, боб).<br>   (b)  ?- мать( пам, боб).<br>   (с)  ?- родительродителя( пам, энн).<br>   (d)  ?- родительродителя( боб, джим). <br></div>
<h3 align="center">
<a name="TOC_id3575234"></a>1.5. Декларативный и процедурный смысл программ<br></h3>
<div>   До сих пор во всех наших примерах всегда можно было понять результаты работы программы, точно не зная, <i>как</i> система в действительности их нашла. Поэтому стоит различать два уровня смысла программы на Прологе, а именно:<br>   • <i>декларативный смысл</i> и<br>   • <i>процедурный смысл</i>.<br>   Декларативный смысл касается только <i>отношений</i>, определенных в программе. Таким образом, декларативный смысл определяет, <i>что</i> должно быть результатом работы программы. С другой стороны, процедурный смысл определяет еще и <i>как</i> этот результат был получен, т.е. как отношения реально обрабатываются пролог-системой.<br>   Способность пролог-системы прорабатывать многие процедурные детали самостоятельно считается одним из специфических преимуществ Пролога. Это свойство побуждает программиста рассматривать декларативный смысл программы относительно независимо от ее процедурного смысла. Поскольку результаты работы программы в принципе определяются ее декларативным смыслом, последнего (Опять же в принципе) достаточно для написания программ. Этот факт имеет практическое значение, поскольку декларативные аспекты программы являются, обычно, более легкими для понимания, нежели процедурные детали. Чтобы извлечь из этого обстоятельства наибольшую пользу, программисту следует сосредоточиться главным образом на декларативном смысле и по возможности не отвлекаться на детали процесса вычислений. Последние следует в возможно большей мере предоставить самой пролог-системе.<br>   Такой декларативный подход и в самом деле часто делает программирование на Прологе более легким, чем на таких типичных процедурно-ориентированных языках, как Паскаль. К сожалению, однако, декларативного подхода не всегда оказывается, достаточно. Далее станет ясно, что, особенно в больших программах, программист не может полностью игнорировать процедурные аспекты по соображениям эффективности вычислений. Тем не менее следует поощрять декларативный стиль мышления при написании пролог-программ, а процедурные аспекты игнорировать в тех пределах, которые устанавливаются практическими ограничениями.<br></div>
<h3 align="center">
<a name="TOC_id3429316"></a>Резюме<br></h3>
<div>   • Программирование на Прологе состоит в определении отношений и в постановке вопросов, касающихся этих отношений.<br>   • Программа состоит из предложений. Предложения бывают трех типов: <i>факты</i>, <i>правила</i> и <i>вопросы.</i><br>   • Отношение может определяться <i>фактами</i>, перечисляющими <i>n</i>-ки объектов, для которых это отношение выполняется, или же оно может определяться <i>правилами</i>.<br>   • <i>Процедура</i> — это множество предложений об одном и том же отношении.<br>   • <i>Вопросы</i> напоминают запросы к некоторой базе данных. Ответ системы на вопрос представляет собой множество объектов, которые удовлетворяют запросу.<br>   • Процесс, в результате которого пролог-система устанавливает, удовлетворяет ли объект запросу, часто довольно сложен и включает в себя логический вывод, исследование различных вариантов и, возможно, <i>возвраты</i>. Все это делается автоматически самой пролог-системой и по большей части скрыто от пользователя.<br>   • Различают два типа смысла пролог-программ: декларативный и процедурный. Декларативный подход предпочтительнее с точки зрения программирования. Тем не менее, программист должен часто учитывать также и процедурные детали.<br>   • В данной главе были введены следующие понятия:<br>     предложение, факт, правило, вопрос<br>     голова предложения, тело предложения<br>     рекурсивное правило<br>     рекурсивное определение<br>     процедура<br>     атом, переменная<br>     конкретизация переменной<br>     цель<br>     цель достижима, цель успешна<br>     цель недостижима,<br>     цель имеет неуспех, цель терпит неудачу<br>     возврат<br>     декларативный смысл, процедурный смысл.<br><h5>Литература</h5>   Различные реализации Пролога используют разные синтаксические соглашения. В данной книге мы применяем так называемый Эдинбургский синтаксис (его называют также синтаксисом DEC-10, поскольку он принят в известной реализации Пролога для машины DEC-10; см. Pereira и др. 1978), он используется во многих популярных пролог-системах, таких как Quintus Prolog, Poplog, CProlog, Arity/Prolog, Prolog-2 и т.д.<br>   Bowen D. L. (1981). <i>DECsystem-10 Prolog User's Manual.</i> University of Edinburgh: Department of Artificial Intelligence.<br>   Mellish С. and Hardy S. (1984). <i>Integrating Prolog in the POPLOG environment. Implementations of Prolog (J. A. Campbell, ed.).</i> Ellis Horwood.<br>   Pereira F. (1982). <i>C-Prolog User's Manual.</i> University of Edinburgh: Department of Computer-Aided Architectural Design.<br>   Pereira L. M., Pereira F., Warren D. H. D. (1978). <i>User's Guide to DECsystem-10 Prolog.</i> University of Edinburgh: Department of Artificial Intelligence.<br>   <i>Quintus Prolog User's Guide and Reference Manual.</i> Palo Alto: Quintus Computer System Inc. (1985).<br>   <i>The Arity/Prolog Programming Language.</i> Concord, Massachusetts: Arity Corporation (1986). <br></div>
</div>
<h2 align="center">
<a name="TOC_id3486422"></a>Глава 2<br>Синтаксис и семантика Пролог-программ<br></h2>
<div>
<div>   В данной главе дается систематическое изложение синтаксиса и семантики основных понятий Пролога, а также вводятся структурные объекты данных. Рассматриваются следующие темы:<br>   • простые объекты данных (атомы, числа, переменные)<br>   • структурные объекты<br>   • сопоставление как основная операция над объектами<br>   • декларативная (или непроцедурная) семантика программ<br>   • взаимосвязь между декларативным и процедурным смыслами программ<br>   • изменение процедурного смысла путем изменения порядка следования предложений и целей<br>   Большая часть этих тем уже была затронута в гл. 1. Теперь их изложение будет более формальным и детализированным.<br></div>
<h3 align="center">
<a name="TOC_id3417464"></a>2.1.  Объекты данных<br></h3>
<div>
<div>   На рис. 2.1 приведена классификация объектов данных Пролога. Пролог-система распознает тип объекта по его синтаксической форме в тексте программы. Это возможно благодаря тому, что синтаксис Пролога предписывает различные формы записи для различных типов объектов данных. В гл. 1 мы уже видели способ, с помощью которого можно отличить атомы от переменных: переменные начинаются с прописной буквы, тогда как атомы — со строчной. Для того, чтобы пролог-система распознала тип объекта, ей не требуется сообщать больше никакой дополнительной информации (такой, например, как объявление типа данных).<br><div align="center"><img border="1" src="_16.png"></div>   <b>Рис. 2.1.</b> Обьекты данных Пролога.<br></div>
<h4 align="center">
<a name="TOC_id3417492"></a>2.1.1. Атомы и числа<br></h4>
<div>   В гл. 1 мы уже видели несколько простых примеров атомов и переменных. Вообще же они могут принимать более сложные формы, а именно представлять собой цепочки следующих символов:<br>   • прописные буквы А, В, …, Z<br>   • строчные буквы а, b, …, z<br>   • цифры 0, 1, 2, …, 9<br>   • специальные символы, такие как <br>      +  -  *  /   =  :  .  &amp;  _  ~<br>   Атомы можно создавать тремя способами:<br>   (1) из цепочки букв, цифр и символа подчеркивания _, начиная такую цепочку со строчной буквы:<br>   анна<br>   nil<br>   х25<br>   x_25<br>   x_25AB<br>   x_<br>   x__y<br>   альфа_бета_процедура<br>   мисс_Джонс<br>   сара_джонс<br>   (2) из специальных символов:<br>   &lt;---&gt;<br>   ======&gt;<br>   ...<br>   .:.<br>   ::=<br>   Пользуясь атомами такой формы, следует соблюдать некоторую осторожность, поскольку часть цепочек специальных символов имеют в Прологе заранее определенный смысл. Примером может служить :- .<br>   (3) из цепочки символов, заключенной в одинарные кавычки. Это удобно, если мы хотим, например, иметь атом, начинающийся с прописной буквы. Заключая его в кавычки, мы делаем его отличным от переменной:<br>   'Том'<br>   'Южная_Америка'<br>   'Сара Джонс'<br>   Числа в Прологе бывают целыми и вещественными. Синтаксис целых чисел прост, как это видно из следующих примеров: 1, 1313, 0, -97. Не все целые числа могут быть представлены в машине, поэтому диапазон целых чисел ограничен интервалом между некоторыми минимальным и максимальным числами, определяемыми конкретной реализацией Пролога. Обычно реализация допускает диапазон хотя бы от -16 383 до 16 383, а часто, и значительно более широкий.<br>   Синтаксис вещественных чисел зависит от реализации. Мы будем придерживаться простых правил, видных из следующих примеров: 3.14, -0.0035, 100.2. При обычном программировании на Прологе вещественные числа используются редко. Причина этого кроется в том, что Пролог — это язык, предназначенный в первую очередь для обработки символьной, а не числовой информации, в противоположность языкам типа Фортрана, ориентированным на числовую обработку. При символьной обработке часто используются целые числа, например, для подсчета количества элементов списка; нужда же в вещественных числах невелика.<br>   Кроме отсутствия необходимости в использовании вещественных чисел в обычных применениях Пролога, существует и другая причина избегать их. Мы всегда стремимся поддерживать наши программы в таком виде, чтобы их смысл был предельно ясен. Введение вещественных чисел в некоторой степени нарушает эту ясность из-за ошибок вычислений, связанных с округлением во время выполнения арифметических действий. Например, результатом вычисления выражения 10000 + 0.0001 - 10000 может оказаться 0 вместо правильного значения 0.0001.<br></div>
<h4 align="center">
<a name="TOC_id3261781"></a>2.1.2. Переменные<br></h4>
<div>   Переменные — это цепочки, состоящие из букв, цифр и символов подчеркивания. Они начинаются с прописной буквы или с символа подчеркивания:<br>   X<br>   Результат<br>   Объект2<br>   Список_участников<br>   СписокПокупок<br>   _x23<br>   _23<br>   Если переменная встречается в предложения только один раз, то нет необходимости изобретать ей имя. Можно использовать так называемую "анонимную" переменную, которая записывается в виде одного символа подчеркивания. Рассмотрим, например, следующее правило:<br>   имеетребенка( X) :- родитель( X, Y).<br>   Это правило гласит: "Для всех X,  X имеет ребенка, если X является родителем некоторого Y". Здесь мы определяем свойство имеетребенка таким образом, что оно не зависит от имени ребенка. Следовательно, это как раз тот случай, когда уместно использовать анонимную переменную. Поэтому вышеприведенное правило можно переписать так:<br>   имеетребенка( X) :- родитель( X, _).<br>   Всякий раз, когда в предложения появляется одиночный символ подчеркивания, он обозначает новую анонимную переменную. Например, можно сказать, что существует некто, кто имеет ребенка, если существуют два объекта, такие, что один из них является родителем другого:<br>   некто_имеет_ребенка :- родитель( _, _).<br>   Это предложение эквивалентно следующему:<br>   некто_имеет_ребенка :- родитель( X, Y).<br>   Однако оно имеет совершенно другой смысл, нежели<br>   некто_имеет_ребенка :- родитель( X, X).<br>   Если анонимная переменная встречается в вопросе, то ее значение не выводится при ответе системы на этот вопрос. Если нас интересуют люди, имеющие детей, но не имена этих детей, мы можем просто спросить:<br>   ?-  родитель( X, _ ).<br>   Лексический диапазон имени — одно предложение. Это значит, что если, например, имя X15 встречается в двух предложениях, то оно обозначает две разные переменные. Однако внутри одного предложения каждое его появлений обозначает одну и ту же переменную. Для констант ситуация другая: один и тот же атом обозначает один и тот же объект в любом предложении, иначе говоря, — во всей программе.<br></div>
<h4 align="center">
<a name="TOC_id3503333"></a>2.1.3. Структуры<br></h4>
<div>   Структурные объекты (или просто структуры) — это объекты, которые состоят из нескольких компонент. Эти компоненты, в свою очередь, могут быть структурами. Например, дату можно рассматривать как структуру, состоящую из трех компонент: день, месяц, год. Хотя они и составлены из нескольких компонент, структуры в программе ведут себя как единые объекты. Для того, чтобы объединить компоненты в структуру, требуется выбрать <i>функтор</i>. Для нашего примера подойдет функтор дата. Тогда дату 1-e мая 1983 г. можно записать так:<br>   дата( 1, май, 1983)<br>   (см. рис. 2.2).<br>   Все компоненты в данном примере являются константами (две компоненты — целые числа и одна — атом). Компоненты могут быть также переменными или структурами. Произвольный день в мае можно представить структурой:<br>   дата( День, май, 1983)<br>   Заметим, что День является переменной и ей можно приписать произвольное значение на некотором более позднем этапе вычислений.<br>   Такой метод структурирования данных прост и эффективен. Это является одной из причин того, почему Пролог естественно использовать для решения задач обработки символьной информации.<br>   Синтаксически все объекты данных в Прологе представляют собой <i>термы</i>. Например,<br>   май<br>   и<br>   дата( 1, май, 1983)<br>   суть термы.<br>   Все структурные объекты можно изображать в виде деревьев (пример см. на рис. 2.2). Корнем дерева служит функтор, ветвями, выходящими из него, — компоненты. Если некоторая компонента тоже является структурой, тогда ей соответствует поддерево в дереве, изображающем весь структурный объект.<br>   Наш следующий пример показывает, как можно использовать структуры для представления геометрических объектов (см. рис. 2.3). Точка в двумерном пространстве определяется двумя координатами; отрезок определяется двумя точками, а треугольник можно задать тремя точками. Введем следующие функторы:<br>   точка        для точек<br>   отрезок      для отрезков и<br>   треугольник  для треугольников.<br><div align="center"><img border="1" src="_17.png"></div>   <b>Рис. 2.2.</b> Дата — пример структурного объекта: (а) его представление в виде дерева; (б) запись на Прологе.<br>   Тогда объекты, приведенные на рис. 2.3, можно представить следующими прологовскими термами:<br>   P1 = точка( 1, 1)<br>
		 <br>   P2 = точка( 2, 3)<br>
		 <br>   S = отрезок( P1, P2) =<br>    отрезок( точка( 1, 1), точка( 2, 3) )<br>
		 <br>   T = треугольник( точка( 4, 2), точка( 6, 4),<br>    точка( 7, 1) )<br><div align="center"><img border="1" src="Bezymjannyjj.png"></div>   <b>Рис. 2.3.</b> Простые геометрические объекты.<br>   Соответствующее представление этих объектов в виде деревьев приводится на рис. 2.4. Функтор, служащий корнем дерева, называется <i>главным функтором</i> терма.<br><div align="center"><img border="1" src="_19.png"></div>   <b>Рис. 2. 4.</b>  Представление объектов с рис. 2.3  в виде деревьев.<br>   Если бы в такой же программе фигурировали точки трехмерного пространства, то можно было бы для их представления использовать другой функтор, скажем точка3:<br>   точка3( X, Y, Z)<br>   Можно, однако, воспользоваться одним и тем же именем точка одновременно и для точек двумерного и трехмерного пространств и написать, например, так:<br>   точка( XI, Y1) и точка( X, Y, Z)<br>   Если одно и то же имя появляется в программе в двух различных смыслах, как в вышеупомянутом примере с точкой, то пролог-система будет различать их по числу аргументов и интерпретировать это имя как два функтора: один — двухаргументный; второй — трех. Это возможно потому, что каждый функтор определяется двумя параметрами:<br>   (1) именем, синтаксис которого совпадает с синтаксисом атомов;<br>   (2) <i>арностью</i> — т.е. числом аргументов.<br>   Как уже объяснялось, все структурные объекты в Прологе — это деревья, представленные в программе термами. Рассмотрим еще два примера, чтобы показать, насколько удобно сложные объекты данных представляются с помощью прологовских термов. На рис. 2.5 показана древовидная структура, соответствующая арифметическому выражению<br>   <i> (a + b)*(c - 5)</i><br>   В соответствии с введенным к настоящему моменту синтаксисом, такое выражение, используя символы *,  +  и  -  в качестве функторов, можно записать следующим образом:<br>   *( +( a, b), -( c, 5))<br>
		 <br><div align="center"><img border="1" src="_20.png"></div>   <b>Рис. 2.5.</b> Древовидная структура, соответствующая арифметическому выражению <i>(a + b)*(c - 5)</i>.<br>   Это, конечно, совершенно правильный прологовский терм, однако это не та форма, которую нам хотелось бы иметь, при записи арифметических выражений. Хотелось бы применять обычную инфиксную запись, принятую в математике. На самом деле Пролог допускает использование инфиксной нотации, при которой символы *,  +   и  -  записываются как инфиксные операторы. Детали того, как программист может определять свои собственные операторы, мы приведем в гл. 3.<br>   В качестве последнего примера рассмотрим некоторые простые электрические цепи, изображенные на рис. 2.6. В правой части рисунка помещены древовидные представления этих цепей. Атомы r1, r2, r3 и r4 — имена резисторов. Функторы пар и посл обозначают соответственно параллельное и последовательное соединение резисторов. Вот соответствующие прологовские термы:<br>   посл( r1, r2)<br>   пар( r1, r2)<br>   паp( rl, пap( r2, r3))<br>   пар( r1, посл( пар( r2, r3), r4))<br><div align="center"><img border="1" src="_21.png"></div>   <b>Рис. 2.6.</b> Некоторые простые электрические цепи и их представление: (а) последовательное соединение резисторов r1 и r2; (b) параллельное соединение двух резисторов; (с) параллельное соединение трех резисторов; (d) параллельное соединение r1 и еще одной цепи.<br><h5>Упражнения</h5>   <b>2.1.</b> Какие из следующих выражений представляют собой правильные объекты в смысле Пролога? Что это за объекты (атомы, числа, переменные, структуры)?<br>   (а)  Диана<br>   (b)  диана<br>   (с)  'Диана'<br>   (d)  _диана<br>   (e)  'Диана едет на юг'<br>   (f)  едет( диана, юг)<br>   (g)  45<br>   (h)  5( X, Y)<br>   (i)  +( север, запад)<br>   (j)  три( Черные( Кошки))<br>   <b>2.2.</b> Предложите представление для прямоугольников, квадратов и окружностей в виде структурных объектов Пролога. Используйте подход, аналогичный приведенному на рис. 2.4. Например, прямоугольник можно представить четырьмя точками (а может быть, только тремя точками). Напишите несколько термов конкретных объектов такого типа с использованием предложенного вами представления. <br></div>
</div>
<h3 align="center">
<a name="TOC_id3382727"></a>2.2. Сопоставление<br></h3>
<div>   В предыдущем разделе мы видели, как используются термы для представления сложных объектов данных. Наиболее важной операцией над термами является <i>сопоставление</i>. Сопоставление само по себе может производить содержательные вычисления.<br>   Пусть даны два терма. Будем говорить, что они <i>сопоставимы</i>, если:<br>   (1) они идентичны или<br>   (2) переменным в обоих термах можно приписать в качестве значений объекты (т.е. конкретизировать их) таким образом, чтобы после подстановки этих объектов в термы вместо переменных, последние стали идентичными.<br>   Например, термы дата( Д, М, 1983) и дата( Д1, май, Y1) сопоставимы. Одной из конкретизации, которая делает эти термы идентичными, является следующая:<br>   • Д  заменяется на Д1<br>   • М  заменяется на май<br>   <b>• </b>Y1 заменяется на 1983<br>   Более компактно такая подстановка записывается в привычной форме, т.е. в той, в которой пролог-система выводит результаты:<br>   Д = Д1<br>   М = май<br>   Y1 = 1983<br>   С другой стороны, дата( Д, М, 1983) и дата( Д1, M1, 1944) не сопоставимы, как и термы дата( X, Y, Z) и точка( X, Y, Z).<br>   <i>Сопоставление</i> — это процесс, на вход которого подаются два терма, а он проверяет, соответствуют ли эти термы друг другу. Если термы не сопоставимы, будем говорить, что этот процесс терпит <i>неуспех</i>. Если же они сопоставимы, тогда процесс находит конкретизацию переменных, делающую эти термы тождественными, и завершается <i>успешно</i>.<br>   Рассмотрим еще раз сопоставление двух дат. Запрос на проведение такой операции можно передать системе, использовав оператор '=':<br>   ?- дата( Д, М, 1983) = дата( Д1, май, Y1).<br>   Мы уже упоминали конкретизацию Д = Д1, М = май, Y1 = 1983, на которой достигается сопоставление. Существуют, однако, и другие конкретизации, делающие оба терма идентичными. Вот две из них:<br>   Д  = 1<br>   Д1 = 1<br>   М  = май<br>   Y1 = 1983<br>
		 <br>   Д  = третий<br>   Д1 = третий<br>   М  = май<br>   Y1 = 1983<br>   Говорят, что эти конкретизации являются <i>менее общими</i> по сравнению с первой, поскольку они ограничивают значения переменных Д и Д1 в большей степени, чем это необходимо. Для того, чтобы сделать оба терма нашего примера идентичными, важно лишь, чтобы Д и Д1 имели одно и то же значение, однако само это значение может быть произвольным. Сопоставление в Прологе всегда дает <i>наиболее общую конкретизацию</i>. Таковой является конкретизация, которая ограничивает переменные в наименьшей степени, оставляя им, тем самым, наибольшую свободу для дальнейших конкретизаций, если потребуются новые сопоставления. В качестве примера рассмотрим следующий вопрос:<br>   ?- дата( Д, М, 1983) =  дата( Д1, май, Y1),<br>      дата( Д, М, 1983) = дата( 15, М, Y).<br>   Для достижения первой цели система припишет переменным такие значения:<br>   Д  = Д1<br>   М  = май<br>   Y1 = 1983<br>   После достижения второй цели, значения переменных станут более конкретными, а именно:<br>   Д  = 15<br>   Д1 = 15<br>   М  = май<br>   Y1 = 1983<br>   Y  = 1983<br>   Этот пример иллюстрирует также и тот факт, что переменным по мере вычисления последовательности целей приписываются обычно все более и более конкретные значения.<br>   Общие правила выяснения, сопоставимы ли два терма S и T, таковы:<br><blockquote>   (1) Если S и T — константы, то S и T сопоставимы, только если они являются одним и тем же объектом.<br>   (2) Если S — переменная, а T — произвольный объект, то они сопоставимы, и S приписывается значение T. Наоборот, если T —переменная, а S — произвольный объект, то T приписывается значение S.<br>   (3) Если S и T — структуры, то они сопоставимы, только если<br>     (а) S и T имеют одинаковый главный функтор<br>          и<br>     (б) все их соответствующие компоненты сопоставимы.<br>          Результирующая конкретизация определяется сопоставлением компонент.<br></blockquote>   Последнее из этих правил можно наглядно представить себе, рассмотрев древовидное изображение термов, такое, например, как на рис. 2.7. Процесс сопоставления начинается от корня (главных функторов). Поскольку оба функтора сопоставимы, процесс продолжается и сопоставляет соответствующие пары аргументов. Таким образом, можно представить себе, что весь процесс сопоставления состоит из следующей последовательности (более простых) операций сопоставления:<br>   треугольник = треугольник,<br>   точка( 1, 1) = X,<br>   А = точка( 4, Y),<br>   точка( 2, 3) = точка( 2, Z).<br>   Весь процесс сопоставления успешен, поскольку все сопоставления в этой последовательности успешны. Результирующая конкретизация такова:<br>   X = точка( 1, 1)<br>   A = точка( 4, Y)<br>   Z = 3<br>   В приведенном ниже примере показано, как сопоставление само по себе можно использовать для содержательных вычислений. Давайте вернемся к простым геометрическим объектам с рис. 2.4 и напишем фрагмент программы для распознавания горизонтальных и вертикальных отрезков. "Вертикальность" — это свойство отрезка, поэтому его можно формализовать в Прологе в виде унарного отношения. Рис. 2.8 помогает сформулировать это отношение. Отрезок является вертикальным, если <i>x</i>-координаты его точек-концов совпадают; никаких других ограничений на отрезок не накладывается. Свойство "горизонтальности" формулируется аналогично, нужно только в этой формулировке <i>x</i> и <i>y</i> поменять местами. Следующая программа, содержащая два факта, реализует эти формулировки:<br>   верт( отр( точка( X, Y), точка( X, Y1) ) ).<br>   гор( отр( точка( X, Y), точка( X1, Y) ) ).<br><div align="center"><img border="1" src="_22.png"></div>   <b>Рис. 2.7.</b> Сопоставление треугольник(( точка( 1, 1), А, точка( 2, 3)) = треугольник( X, точка( 4, Y), точка( 2, Z))<br>   С этой программой возможен такой диалог:<br>   ?- верт( отр( точка( 1, 1), точка( 1, 2) ) ).<br>   да<br>
		 <br>   ?- верт( отр( точка( 1, 1), точка( 2, Y) ) ).<br>   нет<br>
		 <br>   ?- гор( отр( точка( 1, 1), точка( 2, Y) ) ).<br>   Y = 1<br>   На первый вопрос система ответила "да", потому. что цель, поставленная в вопросе, сопоставима с одним из фактов программы. Для второго вопроса сопоставимых фактов не нашлось. Во время ответа на третий вопрос при сопоставлении с фактом о горизонтальных отрезках Y получил значение 1.<br><div align="center"><img border="1" src="_23.png"></div>   <b>Рис. 2.8.</b> Пример вертикальных и горизонтальных отрезков прямых.<br>   Сформулируем более общий вопрос к программе: "Существуют ли какие-либо вертикальные отрезки, начало которых лежит в точке (2,3)?"<br>   ?- верт( отр( точка( 2, 3), P) ).<br>   P = точка( 2, Y)<br>   Такой ответ означает: "Да, это любой отрезок, с концом в точке (2,Y), т.е. в произвольной точке вертикальной прямой <i>x</i> = 2". Следует заметить, что ответ пролог-системы возможно будет выглядеть не так красиво, как только что описано, а (в зависимости от реализации) приблизительно следующим образом:<br>   P = точка( 2, _136)<br>   Впрочем, разница здесь чисто внешняя. В данном случае _136 — это неинициализированная переменная. Имя _136 — законное имя прологовской переменной, которое система построила сама во время вычислений. Ей приходится генерировать новые имена, для того чтобы переименовывать введенные пользователем переменные в программе. Это необходимо по двум причинам: первая — одинаковые имена обозначают в разных предложениях разные переменные; и вторая — при последовательном применении одного и того же предложения используется каждый раз его "копия" с новым набором переменных.<br>   Другим содержательным вопросом к нашей программe является следующий: "Существует ли отрезок, который одновременно и горизонтален в вертикален?"<br>   ?- верт( S), гор( S).<br>   S = отр( точка( X, Y), точка( X, Y) )<br>   Такой ответ пролог-системы следует, понимать так: "да, любой отрезок, выродившийся в точку, обладает как свойством вертикальности, так и свойством горизонтальности одновременно". Этот ответ снова получен лишь из сопоставления. Как и раньше, в ответе вместо X и Y могут появиться некоторые имена, сгенерированные системой.<br><h5>Упражнения</h5>   <b>2.3.</b> Будут ли следующие операции сопоставления успешными или неуспешными? Если они будут успешными, то какова будет результирующая конкретизация переменных?<br>   (а) точка( А, В) = точка( 1, 2)<br>   (b) точка( А, В) = точка( X, Y, Z)<br>   (c) плюс( 2, 2) = 4<br>   (d) +( 2, D)= +( E, 2)<br>   (e) треугольник( точка( -1, 0), Р2, Р3) =<br>        треугольник( P1, точка( 1, 0), точка( 0, Y)<br>   Результирующая конкретизация определяет семейство треугольников. Как бы Вы описали это семейство?<br>   <b>2.4.</b> Используя представление отрезков, применявшееся в данной разделе, напишите терм, соответствующий любому отрезку на вертикальной прямой <i>x = 5</i>.<br>   <b>2.5.</b> Предположим, что прямоугольник представлен термом прямоугольник( P1, P2, P3, Р4), где P — вершины прямоугольника, положительно упорядоченные. Определите отношение<br>   регулярный( R)<br>   которое имеет место, если R — прямоугольник с вертикальными и горизонтальными сторонами.<br></div>
<h3 align="center">
<a name="TOC_id3578030"></a>2.3. Декларативный смысл пролог-программ<br></h3>
<div>   В главе 1 мы уже видели, что пролог-программу можно понимать по-разному: с декларативной и процедурной точек зрения. В этом и следующем разделах мы рассмотрим более формальное определение декларативного и процедурного смыслов программ базисного Пролога. Но сначала давайте еще раз взглянем на различия между этими двумя семантиками.<br>   Рассмотрим предложение<br>   P :- Q, R.<br>   где P, Q и R имеют синтаксис термов. Приведем некоторые способы декларативной интерпретации этого предложения:<br>    P — истинно, если Q и R истинны.<br>    Из Q и R следует  P.<br>   А вот два варианта его "процедурного" прочтения:<br>    Чтобы решить задачу P, <i>сначала</i> реши подзадачу Q, а <i>затем</i> — подзадачу R.<br>    Чтобы достичь P, <i>сначала</i> достигни Q, а <i>затем</i> R.<br>   Таким образом, различие между "декларативным" и "процедурным" прочтениями заключается в том, что последнее определяет не только логические связи между головой предложения и целями в его теле, но еще и <i>порядок</i>, в котором эти цели обрабатываются.<br>   Формализуем теперь декларативный смысл.<br>   Декларативный смысл программы определяет, является ли данная цель истинной (достижимой) и, если да, при каких значениях переменных она достигается. Для точного определения декларативного смысла нам потребуется понятие <i>конкретизации</i> предложения. Конкретизацией предложения С называется результат подстановки в него на место каждой переменной некоторого терма. <i>Вариантом</i> предложения С называется такая конкретизация С, при которой каждая переменная заменена на другую переменную. Например, рассмотрим предложение:<br>   имеетребенка( X) :- родитель( X, Y).<br>   Приведем два варианта этого предложения:<br>   имеетребенка( А) :- родитель( А, В).<br>   имеетребенка( X1) :- родитель( X1, Х2).<br>   Примеры конкретизаций этого же предложения:<br>   имеетребенка( питер) :- родитель( питер, Z).<br>   имеетребенка( барри) :- родитель( барри,<br>                           маленькая( каролина) ).<br>   Пусть дана некоторая программа и цель G, тогда, в соответствии с декларативной семантикой, можно утверждать, что<br><blockquote>   Цель G истинна (т.е. достижима или логически следует из программы) тогда и только тогда, когда<br>   (1) в программе существует предложение С, такое, что<br>   (2) существует такая его (С) конкретизация I, что<br>     (a) голова I совпадает с G и<br>     (б) все цели в теле I истинны.<br></blockquote>   Это определение можно распространить на вопросы следующим образом. В общем случае вопрос к пролог-системе представляет собой <i>список</i> целей, разделенных запятыми. Список целей называется <i>истинным</i> (достижимым), если <i>все</i> цели в этом списке истинны (достижимы) при <i>одинаковых</i> конкретизациях переменных. Значения переменных получаются из наиболее общей конкретизации.<br>   Таким образом, запятая между целями обозначает <i>конъюнкцию</i> целей: они <i>все</i> должны быть истинными. Однако в Прологе возможна и <i>дизъюнкция</i> целей: должна быть истинной, <i>по крайней мере одна</i> из целей. Дизъюнкция обозначается точкой с запятой. Например:<br>   P :- Q; R.<br>   читается так: P — истинно, если истинно Q <i>или</i> истинно R. То есть смысл такого предложения тот же, что и смысл следующей пары предложений:<br>   P :- Q.<br>   P :- R.<br>   Запятая связывает (цели) сильнее, чем точка с запятой. Таким образом, предложение<br>   P :- Q, R; S, T, U.<br>   понимается как:<br>   P :- ( Q, R); (S, T, U).<br>   и имеет тот же смысл, что и два предложения<br>   P :- Q, R.<br>   P :- S, T, U.<br><h5>Упражнения</h5>   <b>2.6.</b> Рассмотрим следующую программу:<br>   f( 1, один).<br>   f( s(1), два).<br>   f( s(s(1)), три).<br>   f( s(s(s(X))), N) :-<br>    f(X, N).<br>   Как пролог-система ответит на следующие вопросы? Там, где возможны несколько ответов, приведите по крайней мере два.<br>   (a) ?- f( s( 1), A).<br>   (b) ?- f( s(s(1)), два). <br>   (c) ?- f( s(s(s(s(s(s(1)))))), С). <br>   (d) ?- f( D, три).<br>   <b>2.7.</b> В следующей программе говорится, что два человека являются родственниками, если<br>   (a) один является предком другого, или<br>   (b) у них есть общий предок, или<br>   (c) у них есть общий потомок.<br>   родственники( X, Y) :-<br>    предок( X, Y).<br>
		 <br>   родственники( X, Y) :-<br>    предок( Y, X).<br>
		 <br>   родственники( X, Y) :-<br>    % X и Y имеют общего предка<br>    предок( Z, X),<br>    предок( Z, Y).<br>
		 <br>   родственники( X, Y) :-<br>    % X и Y имеют общего потомка<br>    предок( X, Z),<br>    предок( Y, Z).<br>   Сможете ли вы сократить эту программу, используя запись с точками с запятой?<br>   <b>2.8.</b> Перепишите следующую программу, не пользуясь точками с запятой.<br>   преобразовать( Число, Слово) :-<br>    Число = 1, Слово = один;<br>    Число = 2, Слово = два;<br>    Число = 3, Слово = три.<br></div>
<h3 align="center">
<a name="TOC_id3502179"></a>2.4. Процедурная семантика<br></h3>
<div>   Процедурная семантика определяет, <i>как</i> пролог-система отвечает на вопросы. Ответить на вопрос — это значит удовлетворить список целей. Этого можно добиться, приписав встречающимся переменным значения таким образом, чтобы цели логически следовали из программы. Можно сказать, что процедурная семантика Пролога — это процедура вычисления списка целей с учетом заданной программы. "Вычислить цели" это значит попытаться достичь их.<br>   Назовем эту процедуру вычислить. Как показано на рис. 2.9, входом и выходом этой процедуры являются:<br>    входом — программа и список целей,<br>    выходом — признак успех/неуспех и подстановка переменных.<br><div align="center"><img border="1" src="_24.png"></div>   <b>Рис. 2.9.</b> Входы и выходы процедуры вычисления списка целей.<br>   Смысл двух составляющих выхода такой:<br>   (1)  Признак успех/неуспех принимает значение "да", если цели достижимы, и "нет" — в противном случае. Будем говорить, что "да" сигнализирует об <i>успешном</i> завершении и "нет" — о <i>неуспехе</i>.<br>   (2)  Подстановка переменных порождается только в случае успешного завершения; в случае неуспеха подстановка отсутствует.<br><h5>ПРОГРАММА</h5>   большой( медведь).     % Предложение 1<br>   большой( слон).        % Предложение 2<br>   маленький( кот).       % Предложение 3<br>   коричневый ( медведь). % Предложение 4<br>   черный ( кот).         % Предложение 5<br>   серый( слон).          % Предложение 6<br>
		 <br>   темный( Z) :-          % Предложение 7:<br>    черный( Z).           % любой черный<br>                          % объект является темным<br>   темный( Z) :-          % Предложение 8:<br>    коричневый( Z).       % Любой коричневый<br>                          % объект является темным<br><h5>ВОПРОС</h5>   ?- темный( X), большой( X) % Кто одновременно темный<br>                              % и большой?<br><h5>ШАГИ  ВЫЧИСЛЕНИЯ</h5>   (1) Исходный список целевых утверждений:<br>   темный( X),  большой( X).<br>   (2) Просмотр всей программы от начала к концу и поиск предложения, у которого голова сопоставима с первым целевым утверждением<br>   темный( X).<br>   Найдена формула 7:<br>   темный( Z) :- черный( Z).<br>   Замена первого целевого утверждения конкретизированным телом предложения 7 — порождение нового списка целевых утверждений.<br>   черный( X),  большой( X)<br>   (3) Просмотр программы для нахождения предложения, сопоставимого с черный( X). Найдено предложение 5: черный ( кот). У этого предложения нет тела, поэтому список целей при соответствующей конкретизации сокращается до<br>   большой( кот)<br>   (4) Просмотр программы в поисках цели большой( кот). Ни одно предложение не найдено. Поэтому происходит возврат к шагу (3) и отмена конкретизации X = кот. Список целей теперь снова<br>   черный( X),  большой( X)<br>   Продолжение просмотра программы ниже предложения 5. Ни одно предложение не найдено. Поэтому возврат к шагу (2) и продолжение просмотра ниже предложения 7. Найдено предложение (8):<br>   темный( Z) :- коричневый( Z).<br>   Замена первой цели в списке на коричневый( X), что дает<br>   коричневый( X), большой( X)<br>   (5) Просмотр программы для обнаружения предложения, сопоставимого коричневый( X). Найдено предложение коричневый( медведь). У этого предложения нет тела, поэтому список целей уменьшается до<br>   большой( медведь)<br>   (6) Просмотр программы и обнаружение предложения большой( медведь). У него нет тела, поэтому список целей становится пустым. Это указывает на успешное завершение, а соответствующая конкретизация переменных такова:<br>   <b>Рис. 2.10.</b>  Пример, иллюстрирующий процедурную семантику Пролога: шаги вычислений, выполняемых процедурой вычислить.<br>
		 <br>   В главе 1 в разд. "Как пролог-система отвечает на вопросы" мы уже фактически рассмотрели, что делает процедура вычислить. В оставшейся части данного раздела приводится несколько более формальное и систематическое описание этого процесса, которое можно пропустить без серьезного ущерба для понимания остального материала книги.<br>   Конкретные операции, выполняемые в процессе вычисления целевых утверждений, показаны на рис. 2.10. Возможно, следует изучить этот рисунок прежде, чем знакомиться с последующим общим описанием.<br>   Чтобы вычислить список целевых утверждений<br>    G1, G2, …, Gm<br>   процедура вычислить делает следующее:<br><blockquote>   • Если список целей пуст - завершает работу <i>успешно</i>.<br>   • Если список целей не пуст, продолжает работу, выполняя (описанную далее) операцию 'ПРОСМОТР'.<br>   • <i>ПРОСМОТР</i>: Просматривает предложения программы от начала к концу до обнаружения первого предложения С, такого, что голова С сопоставима с первой целью G1. Если такого предложения обнаружить не удается, то работа заканчивается <i>неуспехом</i>.<br>   Если С найдено и имеет вид<br>   H :- B1, ..., Вn.<br>   то переменные в С переименовываются, чтобы получить такой вариант С' предложения С, в котором нет общих переменных со списком  G1, …, Gm. Пусть С' — это<br>   Н' :- B1', ..., Вn'.<br>   Сопоставляется G1 с H'; пусть S — результирующая конкретизация переменных. В списке целей G1, G2, …, Gm, цель G1 заменяется на список В1', …, Вn', что порождает новый список целей:<br>   В1', …, Вn', G2, …, Gm<br>   (Заметим, что, если С — факт, тогда n=0, и в этом случае новый список целей оказывается короче, нежели исходный; такое уменьшение списка целей может в определенных случаях превратить его в пустой, а следовательно, — привести к успешному завершению.)<br>   Переменные в новом списке целей заменяются новыми значениями, как это предписывает конкретизация S, что порождает еще один список целей<br>   В1'', …, Вn", G2', …, Gm'<br>   • Вычисляет (используя рекурсивно ту же самую процедуру) этот новый список целей. Если его вычисление завершается успешно, то и вычисление исходного списка целей тоже завершается успешно. Если же его вычисление порождает неуспех, тогда новый список целей отбрасывается и происходит возврат к просмотру программы. Этот просмотр продолжается, начиная с предложения, непосредственно следующего за предложением С (С — предложение, использовавшееся последним) и делается попытка достичь успешного завершения с помощью другого предложения.<br></blockquote>   Более компактная запись этой процедуры в обозначениях, близких к Паскалю, приведена на рис. 2.11.<br>   Здесь следует сделать несколько дополнительных замечаний, касающихся процедуры вычислить в том виде, в котором она приводится. Во-первых, в ней явно не указано, как порождается окончательная результирующая конкретизация переменных. Речь идет о конкретизации S, которая приводит к успешному завершению и которая, возможно, уточнялась последующими конкретизациями во время вложенных рекурсивных вызовов вычислить.<br>   <b>procedure</b><i>вычислить (Прогр, СписокЦелей, Успех)</i><br>
		 <br>   Входные параметры: <br>    <i>Прогр:</i> список предложений <br>    <i>СписокЦелей:</i> список целей <br>
		 <br>   Выходной параметр: <br>    <i>Успех:</i> истинностное значение; <i>Успех</i> принимает значение <br>           истина, если список целевых утверждений <br>           (их конъюнкция) истиннен с точки зрения <i>Прогр</i> <br>
		 <br>   Локальные переменные: <br>    <i>Цель:</i> цель <br>    <i>ДругиеЦели</i>: список целей <br>    <i>Достигнуты:</i> истинностное значение <br>    <i>Сопоставились:</i> истинностное значение <br>    <i>Конкрет:</i> конкретизация переменных <br>             <i>H, Н', B1, B1', …, В<sub>n</sub>, В<sub>n</sub>':</i> цели <br>
		 <br>   Вспомогательные функции: <br>    <i>пycтой( L):</i> возвращает истину, если L — пустой список <br>    <i>голoвa( L):</i> возвращает первый элемент списка L <br>    <i>хвост( L):</i> возвращает остальную часть списка L <br>    <i>конкат( L1, L2):</i> создает конкатенацию списков — присоединяет <br>     список L2 к концу списка L1 <br>    <i>сопоставление( T1, T2, Сопоставились, Конкрет):</i> пытается <br>     сопоставить термы Т1 и T2; если они сопоставимы, то <br>     <i>Сопоставились</i> — истина, а <i>Конкрет</i> представляет <br>     собой конкретизацию переменных <br>    <i>подставить( Конкрет, Цели):</i> производит подстановку переменных <br>     в <i>Цели</i> согласно <i>Конкрет</i> <br>
		 <br>   <b>begin</b><br>    <b>if</b> <i>пустой( СписокЦелей)</i> <b>then</b> <i>Успех </i>: =<i> истина</i> <br>    <b>else</b> <br>   <b>  begin</b><br>      <i>Цель</i> : = <i>голова( СписокЦелей)</i>; <br>      <i>ДругиеЦели</i> : = <i>хвост( СписокЦелей)</i>; <br>      <i>Достигнута</i> : = <i>ложь;</i> <br>      <b>while not</b> <i>Достигнута</i> <b>and</b> <br>       "в программе есть еще предложения" <b>do</b> <br>       <b>begin</b> <br>        <i>Пусть следующее предложение в Прогр есть</i> <br>   <i>      H :- B1, …, Вn.</i><br>   <i>     Создать вариант этого предложения</i><br>   <i>      Н' :- В1', …, Вn'.</i><br>   <i>     сопоставление( Цель, Н',</i><br>   <i>      Сопоставились, Конкрет)</i><br>        <b>if</b> <i>Сопоставились</i> <b>then</b> <br>         <b>begin</b> <br>          <i>НовыеЦели</i> := <br>           <i>конкат( </i>[<i>В1', …, Вn'</i> ]<i>, Другие Цели</i>); <br>          <i>НовыеЦели</i> : = <br>           <i>подставить( Конкрет, НовыеЦели);</i> <br>   <i>       вычислить( Прогр, НовыеЦели, Достигнуты)</i><br>         <b>end</b> <br>   <b>    end;</b><br>       <i>Успех </i>: =<i> Достигнуты</i> <br>     <b>end</b> <br>   <b>end;</b><br>   <b>Рис. 2.11.</b>  Вычисление целевых утверждений Пролога.<br>
		 <br>   Всякий раз, как рекурсивный вызов процедуры вычислить приводят к неуспеху, процесс вычислений возвращается к ПРОСМОТРУ и продолжается с того предложения  С,  которое использовалось последним. Поскольку применение предложения  С  не привело к успешному завершению, пролог-система должна для продолжения вычислений попробовать альтернативное предложение. В действительности система аннулирует результаты части вычислений, приведших к неуспеху, и осуществляет возврат в ту точку (предложение  С),  в которой эта неуспешная ветвь начиналась. Когда процедура осуществляет возврат в некоторую точку, все конкретизации переменных, сделанные после этой точки, аннулируются. Такой порядок обеспечивает систематическую проверку пролог-системой всех возможных альтернативных путей вычисления до тех пор, пока не будет найден путь, ведущий к успеху, или же до тех пор, пока не окажется, что все пути приводят к неуспеху.<br>   Мы уже знаем, что даже после успешного завершения пользователь может заставить систему совершить возврат для поиска новых решений. В нашем описании процедуры вычислить эта деталь была опущена.<br>   Конечно, в настоящих реализациях Пролога в процедуру вычислить добавлены и еще некоторые усовершенствования. Одно из них — сокращение работы по просмотрам программы с целью повышения эффективности. Поэтому на практике пролог-система не просматривает все предложения программы, а вместо этого рассматривает только те из них, которые касаются текущего целевого утверждения.<br><h5>Упражнение</h5>   <b>2.9.</b> Рассмотрите программу на рис. 2.10 и по типу того, как это сделано на рис. 2.10, проследите процесс вычисления пролог-системой вопроса<br>   ?- большой( X), темный( X).<br>   Сравните свое описание шагов вычисления с описанием на рис. 2.10, где вычислялся, по существу, тот же вопрос, но с другой последовательностью целей:<br>   ?- темный( X), большой( X).<br>   В каком из этих двух случаев системе приходится производить б<i>о</i>льшую работу для нахождения ответа?<br></div>
<h3 align="center">
<a name="TOC_id3417270"></a>2.5. Пример: обезьяна и банан<br></h3>
<div>   Задача об обезьяне и банане часто используется в качестве простого примера задачи из области искусственного интеллекта. Наша пролог-программа, способная ее решить, показывает, как механизмы сопоставления и автоматических возвратов могут применяться для подобных целей. Мы сначала составим программу, не принимая во внимание процедурную семантику, а затем детально изучим ее процедурное поведение. Программа будет компактной и наглядной.<br>   Рассмотрим следующий вариант данной задачи. Возле двери комнаты стоит обезьяна. В середине этой комнаты к потолку подвешен банан. Обезьяна голодна и хочет съесть банан, однако она не может дотянуться до него, находясь на полу. Около окна этой же комнаты на полу лежит ящик, которым обезьяна может воспользоваться. Обезьяна может предпринимать следующие действия: ходить по полу, залезать на ящик, двигать ящик (если она уже находится около него) и схватить банан, если она стоит на ящике прямо под бананом. Может ли обезьяна добраться до банана?<br>   Одна из важных проблем при программировании состоит в выборе (адекватного) представления решаемой задачи в терминах понятий используемого языка программирования. В нашем случае мы можем считать, что "обезьяний мир" всегда находится в некотором <i>состоянии</i>, и оно может изменяться со временем. Текущее состояние определяется взаиморасположением объектов. Например, исходное состояние мира определяется так:<br>   (1) Обезьяна у двери.<br>   (2) Обезьяна на полу.<br>   (3) Ящик у окна.<br>   (4) Обезьяна не имеет банана.<br>   Удобно объединить все эти четыре информационных фрагмента в один структурный объект. Давайте в качестве такого объединяющего функтора выберем слово "состояние". На рис. 2.12 в виде структурного объекта изображено исходное состояние.<br>   Нашу задачу можно рассматривать как игру для одного игрока. Давайте, формализуем правила этой игры. Первое, целью игры является ситуация, в которой обезьяна имеет банан, т.е. любое состояние, у которого в качестве четвертой компоненты стоит "имеет":<br>   состояние( _, _, _, имеет)<br>   Второе, каковы разрешенные ходы, переводящие мир из одного состояния в другое? Существуют четыре типа ходов:<br>   (1) схватить банан,<br>   (2) залезть на ящик,<br>   (3) подвинуть ящик,<br>   (4) перейти в другое место.<br><div align="center"><img border="1" src="_25.png"></div>   <b>Рис. 2.12.</b> Исходное состояние обезьяньего мира, представленное в виде структурного объекта. Его четыре компоненты суть горизонтальная позиция обезьяны, вертикальная позиция обезьяны, позиция ящика, наличие или отсутствие у обезьяны банана.<br>   Не всякий ход допустим при всех возможных состояниях мира. Например, ход "схватить" допустим, только если обезьяна стоит на ящике прямо под бананом (т.е. в середине комнаты) и еще не имеет банана. Эти правила можно формализовать в Прологе в виде трехместного отношения ход:<br>   ход( Состояние1, М, Состояние2)<br>   Три аргумента этого отношения определяют ход, следующим образом:<br>   Состояние1 --------&gt; Состояние2<br>                   М<br>   Состояние1 это состояние до хода, М — выполняемый ход, и Состояние2 — состояние после хода.<br>   Ход "схватить", вместе с необходимыми ограничениями на состояние перед этим ходом, можно выразить такой формулой:<br>   ход( состояние( середина, наящике, середина, неимеет),<br>              % Перед ходом<br>    схватить, % Ход<br>    состояние( середина, наящике, середина, имеет) ).<br>              % После хода<br>   В этом факте говорится о том, что после хода у обезьяны уже есть банан и что она осталась на ящике в середине комнаты.<br>   Таким же способом можно выразить и тот факт, что обезьяна, находясь на полу, может перейти из любой горизонтальной позиции P1 в любую позицию Р2. Обезьяна может это сделать независимо от позиции ящика, а также независимо от того, есть у нее банан или нет. Все это можно записать в виде следующего прологовского факта:<br>   ход( состояние( P1, наполу, В, H),<br>    перейти( P1, Р2), % Перейти из P1 в Р2<br>    состояние( Р2, наполу, В, H) ).<br>   Заметим, что в этом предложении делается много утверждений и, в частности:<br>   • выполненный ход состоял в том, чтобы "перейти из некоторой позиции P1 в некоторую позицию Р2";<br>   • обезьяна находится на полу, как до, так и после хода;<br>   • ящик находится в некоторой точке В, которая осталась неизменной после хода;<br>   • состояние "имеет банан" остается неизменным после хода.<br><div align="center"><img border="1" src="_26.png"></div>   <b>Рис. 2.13.</b> Рекурсивная формулировка отношения можетзавладеть.<br>   Данное предложение на самом деле определяет все множество возможных ходов указанного типа, так как оно применимо к любой ситуации, сопоставимой с состоянием, имеющим место перед входом. Поэтому такое предложение иногда называют <i>схемой</i> хода. Благодаря понятию переменной, имеющемуся в Прологе, такие схемы легко на нем запрограммировать.<br>   Два других типа ходов: "подвинуть" и "залезть" — легко определить аналогичным способом.<br>   Главный вопрос, на который должна ответить наша программа, это вопрос: "Может ли обезьяна, находясь в некотором начальном состоянии S, завладеть бананом?" Его можно сформулировать в виде предиката<br>   можетзавладеть( S)<br>   где аргумент S — состояние обезьяньего мира. Программа для можетзавладеть может основываться на двух наблюдениях:<br>   (1) Для любого состояния S, в которой обезьяна уже имеет банан, предикат можетзавладеть должен, конечно, быть истинным; в этом случае никаких ходов не требуется. Вот соответствующий прологовский факт:<br>   можетзавладеть( состояние( _, _, _, имеет) ).<br>   (2) В остальных случаях требуется один или более ходов. Обезьяна может завладеть бананом в любом состоянии S1, если для него существует ход из состояния P1 в некоторое состояние S2, такое, что, попав в него, обезьяна уже сможет завладеть бананом (за нуль или более ходов). Этот принцип показан на рис. 2.13. Прологовская формула, соответствующая этому правилу, такова:<br>   можетзавладеть( S1) :-<br>    ход( S1, М, S2),<br>    можетзавладеть( S2).<br>   Теперь мы полностью завершили нашу программу, показанную на рис. 2.14.<br>   Формулировка можетзавладеть рекурсивна и совершенно аналогична формулировке отношения предок из гл. 1 (ср. рис. 2.13 и 1.7). Этот принцип используется в Прологе повсеместно.<br>   Мы создали нашу программу "непроцедурным" способом. Давайте теперь изучим ее <i>процедурное</i> поведение, рассмотрев следующий вопрос к программе:<br>   ?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).<br>   Ответом пролог-системы будет "да". Процесс, выполняемый ею при этом, обрабатывает, в соответствии с процедурной семантикой Пролога, последовательность списков целей. Для этого требуется некоторый перебор ходов, для отыскания верного из нескольких альтернативных. В некоторых точках при таком переборе будет сделан неверный ход, ведущий в тупиковую ветвь процесса вычислений. На этом этапе автоматический возврат позволит исправить положение. На рис. 2.15 изображен процесс перебора.<br>   % Разрешенные ходы<br>   ход( состояние( середина, на ящике, середина, неимеет),<br>    схватить,           % Схватить банан<br>    состояние( середина, наящике, середина, имеет)).<br>
		 <br>   ход( состояние( P, наполу, P, H),<br>    залезть,            % Залезть на ящик<br>    состояние( P, наящике, P, H) ).<br>
		 <br>   ход( состояние( P1, наполу, P1, H),<br>    подвинуть( P1, Р2), % Подвинуть ящик с P1 на Р2<br>    состояние( Р2, наполу, Р2, H) ).<br>
		 <br>   ход( состояние( P1, наполу, В, H),<br>    перейти( P1, Р2),   % Перейти с P1 на Р2<br>    состояние( Р2, наполу, В, H) ).<br>
		 <br>   % можетзавладеть(Состояние): обезьяна может завладеть<br>   % бананом, находясь в состоянии Состояние<br>   можетзавладеть( состояние( -, -, -, имеет) ).<br>
		 <br>   % может 1:  обезьяна уже его имеет<br>   можетзавладеть( Состояние1) :-<br>    % может 2:  Сделать что-нибудь, чтобы завладеть им<br>    ход( Состояние1, Ход, Состояние2),<br>    % сделать что-нибудь<br>    можетзавладеть( Состояние2).<br>    % теперь может завладеть<br>   <b>Рис. 2.14.</b>  Программа для задачи об обезьяне и банане.<br>
		 <br>   Для ответа на наш вопрос системе пришлось сделать лишь один возврат. Верная последовательность ходов была найдена почти сразу. Причина такой эффективности программы кроется в том порядке, в котором в ней расположены предложения, касающиеся отношения ход. В нашем случае этот порядок (к счастью) оказался весьма подходящим. Однако возможен и менее удачный порядок. По правилам игры обезьяна могла бы с легкостью ходить туда-сюда, даже не касаясь ящика, или бесцельно двигать ящик в разные стороны. Как будет видно из следующего раздела, более тщательное исследование обнаруживает, что порядок предложений в нашей программе является, на самом деле, критическим моментом для успешного решения задачи.<br><div align="center"><img border="1" src="_27.png"></div>   <b>Рис. 2.15.</b>  Поиск банана обезьяной. Перебор начинается в верхнем узле и распространяется вниз, как показано. Альтернативные ходы перебираются слева направо. Возврат произошел только один раз.<br></div>
<h3 align="center">
<a name="TOC_id3494638"></a>2.6. Порядок предложений и целей <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3494644"></a>2.6.1. Опасность бесконечного цикла<br></h4>
<div>   Рассмотрим следующее предложение:<br>   p :- p.<br>   В нем говорится: "p истинно, если p истинно". С точки зрения декларативного смысла это совершенно корректно, однако в процедурном смысле оно бесполезно. Более того, для пролог-системы такое предложение может породить серьезную проблему. Рассмотрим вопрос:<br>   ?-  p.<br>   При использовании вышеприведенного предложения цель p будет заменена на ту же самую цель p; она в свою очередь будет заменена снова на p и т.д. В этом случае система войдет в бесконечный цикл, не замечая, что никакого продвижения в вычислениях не происходит.<br>   Данный пример демонстрирует простой способ ввести пролог-систему в бесконечный цикл. Однако подобное зацикливание могло встретиться и в некоторых наших предыдущих программах, если бы мы изменили порядок предложений, или же порядок целей в них. Будет полезно рассмотреть несколько примеров.<br>   В программе об обезьяне и банане предложения, касающиеся отношения ход, были упорядочены следующим образом: схватить, залезть, подвинуть, перейти (возможно, для полноты следует добавить еще "слезть"). В этих предложениях говорится, что можно схватить, можно залезть и т.д. В соответствии с процедурной семантикой Пролога порядок предложений указывает на то, что обезьяна предпочитает схватывание залезанию, залезание — передвиганию и т.д. Такой порядок предпочтений на самом деле помогает обезьяне решить задачу. Но что могло случиться. если бы этот порядок был другим? Предположим, что предложение с "перейти" оказалось бы первым. Процесс вычисления нашей исходной цели из предыдущего раздела<br>   ?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).<br>   протекал бы на этот раз так. Первые четыре списка целей (с соответствующим образом переименованными переменными) остались бы такими же, как и раньше:<br>   (1) можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).<br>   Применение второго предложения из можетзавладеть ("может2") породило бы<br>   (2) ход( состояние( удвери, наполу, уокна, неимеет), М', S2'), <br>     можетзавладеть( S2')<br>   С помощью хода перейти( уокна, Р2') получилось бы<br>   (3) можетзавладеть( состояние( Р2', наполу, уокна, неимеет) )<br>   Повторное использование предложения "может2" превратило бы список целей в<br>   (4) ход( состояние(Р2', наполу, уокна, неимеет), М'', S2''),<br>     можетзавладеть( S2'')<br>   С этого момента начались бы отличия. Первым предложением, голова которого сопоставима с первой целью из этого списка, было бы теперь "перейти" (а не "залезть", как раньше). Конкретизация стала бы следующей:<br>   S2'' = состояние( Р2'', наполу, уокна, неимеет).<br>   Поэтому список целей стал бы таким:<br>   (5) можетзавладеть( состояние( Р2'', наполу, уокна, неимеет) )<br>   Применение предложения "может2" дало бы<br>   (6) ход( cocтояниe( P2'', наполу, yoкнa, неимeeт), M''', S2'''),<br>                   можетзавладеть( S2''')<br>   Снова первый было бы попробовано "перейти" и получилось бы<br>   (7) можетзавладеть( состояние( Р2''', наполу, уокна, неимеет) )<br>   Сравним теперь цели (3), (5) и (7). Они похожи и отличаются лишь одной переменной, которая по очереди имела имена Р', Р''  и P'''.  Как мы знаем, успешность цели не зависит от конкретных имен переменных в ней. Это означает, что, начиная со списка целей (3), процесс вычислений никуда не продвинулся. Фактически мы замечаем, что по очереди многократно используются одни и те же два предложения: "может2" и "перейти". Обезьяна перемещается, даже не пытаясь воспользоваться ящиком. Поскольку продвижения нет, такая ситуация продолжалась бы (теоретически) бесконечно: пролог-система не сумела бы осознать, что работать в этой направлении нет смысла.<br>   Данный пример показывает, как пролог-система может пытаться решить задачу таким способом, при котором решение никогда не будет достигнуто, хотя оно существует. Такая ситуация не является редкостью при программировании на Прологе. Да и при программировании на других языках бесконечные циклы не такая уж редкость. Что <i>действительно</i> необычно при сравнении Пролога с другими языками, так это то, что декларативная семантика пролог-программы может быть правильной, но в то же самое время ее процедурная семантика может быть ошибочной в том смысле, что с помощью такой программы нельзя получить правильный ответ на вопрос. В таких случаях система не способна достичь цели потому, что она пытается добраться до ответа, но выбирает при этом неверный путь.<br>   Теперь уместно спросить: "Не можем ли мы внести какое-либо более существенное изменение в нашу программу, так чтобы полностью исключить опасность зацикливания? Или же нам всегда придется рассчитывать на удачный порядок предложений и целей?" Как оказывается, программы, в особенности большие, были бы чересчур ненадежными, если бы можно было рассчитывать лишь на некоторый удачный порядок. Существует несколько других методов, позволяющих избежать зацикливания и являющихся более общими и надежными, чем сам по себе метод упорядочивания. Такие методы будут систематически использоваться дальше в книге, в особенности в тех главах, в которых пойдет речь о нахождении путей (в графах), о решения интеллектуальных задач и о переборе.<br></div>
<h4 align="center">
<a name="TOC_id3392094"></a>2.6.2. Варианты программы, полученые путем переупорядочивания предложений и целей<br></h4>
<div>   Уже в примерах программ гл. 1 существовала скрытая опасность зацикливания. Определение отношения предок в этой главе было таким:<br>   предок( X, Z) :-<br>    родитель( X, Z).<br>
		 <br>   предок( X, Z) :-<br>    родитель( X, Y),<br>    предок( Y, Z).<br>   Проанализируем некоторые варианты этой программы. Ясно, что все варианты будут иметь одинаковую декларативную семантику, но разные процедурные семантики.<br>   В соответствии с декларативной семантикой Пролога мы можем, не меняя декларативного смысла, изменить<br>   (1) порядок предложений в программе и<br>   (2) порядок целей в телах предложений.<br>   Процедура предок состоит из двух предложений, и одно из них содержит в своем теле две цели. Возможны, поэтому, четыре варианта данной программы, все с одинаковым декларативным смыслом. Эти четыре варианта можно получить, если<br>   (1) поменять местами оба предложения и<br>   (2) поменять местами цели в каждом из этих двух последовательностей предложений.<br>   Соответствующие процедуры, названные пред1, пред2, пред3 и пред4, показаны на рис. 2.16.<br>   Есть существенная разница в поведении этих четырех декларативно эквивалентных процедур. Чтобы это продемонстрировать, будем считать, отношение родитель определенным так, как показано на рис. 1.1 гл. 1. и посмотрим, что произойдет, если мы спросим, является ли Том предком Пат, используя все четыре варианта отношения предок:<br>   ?- пред1( том, пат).<br>   да<br>
		 <br>   ?- пред2( том, пат).<br>   да<br>
		 <br>   ?- пред3( том, пат).<br>   да<br>
		 <br>   ?- пред4( том, пат).<br>
		 <br>   % Четыре версии программы предок<br>
		 <br>   % Исходная версия<br>   пред1( X, Z) :-<br>    родитель( X, Z).<br>   пред1( X, Z) :-<br>    родитель( X, Y),<br>    пред1( Y, Z).<br>
		 <br>   % Вариант  а:  изменение порядка предложений в исходной версии<br>   пред2( X, Z) :-<br>    родитель( X, Y),<br>    пред2( Y, Z).<br>   пред2( X, Z) :-<br>    родитель( X, Z).<br>
		 <br>   % Вариант  b:  изменение порядка целей во втором предложении<br>   % исходной версии<br>   пред3( X, Z) :-<br>    родитель( X, Z).<br>   пред3( X, Z) :-<br>    пред3( X, Y),<br>    родитель( Y, Z).<br>
		 <br>   % Вариант  с:  изменение порядка предложений и целей в исходной<br>   % версии<br>   пред4( X, Z) :-<br>    пред4( X, Y),<br>    родитель( Y, Z).<br>   пред4( X, Z):-<br>    родитель( X, Z).<br>   <b>Рис. 2.16.</b>  Четыре версии программы предок.<br>
		 <br>   В последнем случае пролог-система не сможет найти ответа. И выведет на терминал сообщение: "Не хватает памяти".<br>   На рис. 1.11 гл. 1 были показаны все шаги вычислений по пред1 (в главе 1 она называлась предок), предпринятые для ответа на этот вопрос. На рис 2.17 показаны соответствующие вычисления по пред2, пред3 и пред4. На рис. 2.17 (с) ясно видно, что работа пред4 — бесперспективна, а рис. 2.17(а) показывает, что пред2 довольно неэффективна по сравнению с пред1: пред2 производит значительно больший перебор и делает больше возвратов по фамильному дереву.<br>   Такое сравнение должно напомнить нам об общем практическом правиле при решении задач: обычно бывает полезным прежде всего попробовать самое простое соображение. В нашем случае все версии отношения предок основаны на двух соображениях:<br>   • более простое — нужно проверить, не удовлетворяют ли два аргумента отношения предок отношению родитель;<br>   • более сложное — найти кого-либо "между" этими двумя людьми (кого-либо, кто связан с ними отношениями родитель и предок).<br>   Из всех четырех вариантов отношения предок, пред1 использует наиболее простое соображение в первую очередь. В противоположность этому пред4 всегда сначала пробует использовать самое сложное. Пред2 и пред3 находятся между этими двумя крайностями. Даже без детального изучения процессов вычислений ясно, что пред1 следует предпочесть просто на основании правила "самое простое пробуй в первую очередь".<br>   Наши четыре варианта процедуры предок можно далее сравнить, рассмотрев вопрос: "На какие типы вопросов может отвечать тот или иной конкретный вариант и на какие не может?" Оказывается, пред1 и пред2 оба способны найти ответ на любой вид вопроса относительно предков; пред4 никогда не находит ответа, а пред3 иногда может найти, иногда нет. Вот пример вопроса, на который пред4 ответить не может:<br>   ?- пред3( лиз, джим).<br>   Такой вопрос тоже вводит систему в бесконечную рекурсию. Следовательно и пред3 нельзя признать верным с точки зрения процедурного смысла.<br><div align="center"><img border="1" src="_281.png"></div>
<div align="center"><img border="1" src="_282.png"></div>   <b>Рис. 2.17.</b> Поведение трех вариантов формулировки отношения предок при ответе на вопрос, является ли Том предком Пат?<br></div>
<h4 align="center">
<a name="TOC_id3306331"></a>2.6.3. Сочетание декларативного и процедурного подходов<br></h4>
<div>   В предыдущем разделе было показано, что порядок целей и предложений имеет существенное значение. Более того, существуют программы, которые верны в декларативном смысле, но на практике не работают. Такое противоречие между декларативным и процедурным смыслами может вызвать недовольство. Кто-нибудь спросит: "А почему вообще не забыть о декларативном смысле?" Такое пожелание становится особенно сильным, когда рассматриваются предложения типа:<br>   предок( X, Z) :- предок( X, Z).<br>   Это предложение верно в декларативном смысле, но совершенно бесполезно в качестве рабочей программы.<br>   Причина, по которой не следует забывать о декларативном смысле, кроется в том, что прогресс, достигнутый в технологии программирования, получен на пути продвижения от учета всех процедурных деталей к концентрации внимания на декларативных аспектах, которые обычно легче формулировать и понимать. Сама система, а не программист, должна нести бремя заботы о процедурных деталях. В этом Пролог оказывает некоторую помощь, хотя, как мы видели в данном разделе, помощь лишь частичную: иногда он правильно прорабатывает эти процедурные детали, иногда — нет. Многие придерживаются мнения, что лучше иметь хоть какую-то декларативную семантику, чем никакой (отсутствие декларативной семантики характерно для многих других языков программирования). Практическим следствием такого взгляда является тот факт, что часто довольно легко получить работающую программу, имея программу декларативно корректную. Поэтому практичным следует признать такой подход: сосредоточиться на декларативных аспектах задачи, затем пропустить на машине полученную программу и, если она окажется процедурно неправильной, попытаться изменить порядок следования предложений и целей. <br></div>
</div>
<h3 align="center">
<a name="TOC_id3306357"></a>2.7. Замечания о взаимосвязи между Прологом и логикой<br></h3>
<div>   Пролог восходит к математической логике, поэтому его синтаксис и семантику можно наиболее точно описать при помощи логики. Так часто и поступают при обучении этому языку. Однако такой подход к ознакомлению с Прологом предполагает знание читателем определенных понятий математической логики. С другой стороны, знание этих понятий явно необязательно для того, чтобы понять и использовать Пролог в качестве инструмента для практического программирования, а цель данной книги — научить именно этому. Для тех же читателей, которые особенно заинтересуются взаимосвязями между Прологом и логикой, мы сейчас перечислим основные из них, а также приведем некоторые подходящие источники.<br>   Синтаксис Пролога — это синтаксис предложений <i>логики предикатов первого порядка</i>, записанных в так называемой <i>форме предложений</i> (форме, при которой кванторы не выписываются явно), а точнее, в виде частного случая таких предложений — в виде <i>формул Хорна </i>(предложений, имеющих самое большее один положительный литерал). Клоксин и Меллиш (1981 г.) приводят пролог-программу, которая преобразует предложения исчисления предикатов первого порядка в форму предложений. Процедурный смысл Пролога основывается на <i>принципе резолюций</i>, применяющемся для автоматического доказательства теорем, который был предложен Робинсоном в его классической статье (1965 г.). В Прологе используется особая стратегия доказательства теоремы методом резолюций, носящая название SLD. Введение в исчисление предикатов первого порядка и доказательство теорем, основанное на методе резолюций, можно найти у Нильсона (1981 г.). Математические вопросы, касающиеся свойств процедурной семантики Пролога в их связи с логикой, проанализированы Ллойдом (1984 г.).<br>   Сопоставление в Прологе соответствует некоторому действию в логике, называемому <i>унификацией</i>. Мы, однако, избегаем слова "унификация", так как по соображениям эффективности внести в большинстве пролог-систем сопоставление реализовано таким образом, что оно не полностью соответствует унификации (см. упражнение 2.10). Тем не менее, с практической точки зрения, такая приближенная унификация вполне допустима.<br><h5>Упражнение</h5>   <b>2.10.</b> Что будет, если пролог-системе задать такой вопрос:<br>   ?- X = f( X).<br>   Успешным или неуспешным будет здесь сопоставление? По определению унификации в логике, сопоставление должно быть неуспешным, а что будет в соответствии с нашим определением сопоставления из раздела 2.2? Попробуйте объяснить, почему многие реализации Пролога отвечают на вышеприведенный вопрос так:<br>   X = f(f(f(f(f(f(f(f(f(f(f(f(f(f(f( ...<br></div>
<h3 align="center">
<a name="TOC_id3399238"></a>Резюме<br></h3>
<div>   К настоящему моменту мы изучили нечто вроде базового Пролога, который называют еще "чистый Пролог". Он "чист", потому что довольно точно соответствует формальной логике. Расширения, преследующие цель приспособить язык к некоторым практическим нуждам, будут изучены дальше (гл. 3, 5, 6. 7). Важными моментами данной главы являются следующие:<br>   • Простые объекты в Прологе — это <i>атомы</i>, <i>переменные</i> и <i>числа</i>. Структурные объекты, или <i>структуры</i>, используются для представления объектов, которые состоят из нескольких компонент.<br>   • Структуры строятся посредством <i>функторов</i>. Каждый функтор определяется своими именем и арностью.<br>   • Тип объекта распознается исключительно по его синтаксической форме.<br>   • <i>Область известности (лексический диапазон)</i> переменных — одно предложение. Поэтому одно и то же имя в двух предложениях обозначает две разные переменные.<br>   • Структуры могут быть естественным образом изображены в виде деревьев. Пролог можно рассматривать как язык обработки деревьев.<br>   • Операция <i>сопоставление</i> берет два терма и пытается сделать их идентичными, подбирая соответствующую конкретизацию переменных в обоих термах.<br>   • Сопоставление, если оно завершается успешно, в качестве результата выдает <i>наиболее общую</i> конкретизацию переменных.<br>   • <i>Декларативная семантика</i> Пролога определяет, является ли целевое утверждение истинным, исходя из данной программы, и если оно истинно, то для какой конкретизации переменных.<br>   • Запятая между целями означает их конъюнкцию. Точка с запятой между целями означает их дизъюнкцию.<br>   • <i>Процедурная семантика</i> Пролога — это процедура достижения списка целей в контексте данной программы. Процедура выдает истинность или ложность списка целей и соответствующую конкретизацию переменных. Процедура осуществляет автоматический возврат для перебора различных вариантов.<br>   • Декларативный смысл программ на "чистом Прологе" не зависит от порядка предложений и от порядка целей в предложениях.<br>   • Процедурный смысл существенно зависит от порядка целей и предложений. Поэтому порядок может повлиять на эффективность программы; неудачный порядок может даже привести к бесконечным рекурсивным вызовам.<br>   • Имея декларативно правильную программу, можно улучшить ее эффективность путем изменения порядка предложений и целей при сохранении ее декларативной правильности. Переупорядочивание — один из методов предотвращения зацикливания.<br>   • Кроме переупорядочивания существуют и другие, более общие методы предотвращения зацикливания, способствующие получению процедурно правильных программ.<br>   • В данной главе обсуждались следующие понятия:<br>     объекты данных:<br>        атом, число, переменная, структура<br>     терм<br>     функтор, арность функтора<br>     главный функтор терма<br>     сопоставление термов<br>     наиболее общая конкретизация<br>     декларативная семантика<br>     конкретизация предложений,<br>       вариант предложения<br>     процедурная семантика<br>     вычисление целевого утверждения<br><h5>Литература</h5>   Clocksin W. F. and Mellish С. S. (1981). <i>Programming in Prolog.</i> Springer-Verlag. [Имеется перевод: Клоксин У., Меллиш К. Программирование на языке Пролог. — М.: Мир, 1987.]<br>   Lloyd J. W. (1984). <i>Foundations of Logic Programming.</i> Springer-Verlag.<br>   Nilsson N. J. (1981). <i>Principies of Artificial Intelligence.</i> Tioga; Springer-Verlag.<br>   Robinson A. J. (1965). <i>A machine-oriented logic based on the resolution principle. JACM </i><b>12:</b> 23-41. [Имеется перевод: Робинсон Дж. Машинно-ориентированная логика, основанная на принципе резолюции. — В кн. Кибернетический сборник, вып. 7, 1970, с. 194–218.] <br></div>
</div>
<h2 align="center">
<a name="TOC_id3399376"></a>Глава 3<br>Списки, операторы, арифметика<br></h2>
<div>
<div>   В этой главе мы будем изучать специальные способы представления списков. Список - один из самых простых и полезных типов структур. Мы рассмотрим также некоторые программы для выполнения типовых операций над списками и, кроме того, покажем, как можно просто записывать арифметические выражения и операторы, что во многих случаях позволит улучшить "читабельность" программ. Базовый Пролог (глава 2), расширенный этими тремя добавлениями, станет удобной основой для составления интересных программ.<br></div>
<h3 align="center">
<a name="TOC_id3399396"></a>3.1. Представление списков<br></h3>
<div>   <i>Список</i> — это простая структура данных, широко используемая в нечисловом программировании. Список — это последовательность, составленная из произвольного числа элементов, например энн<b>, </b>теннис<b>, </b>том<b>, </b>лыжи. На Прологе это записывается так:<br>   [ энн, теннис, том, лыжи ]<br>   Однако таково лишь внешнее представление списков. Как мы уже видели в гл. 2, все структурные объекты Пролога — это деревья. Списки не являются исключением из этого правила.<br>   Каким образом можно представить список в виде стандартного прологовского объекта? Мы должны рассмотреть два случая: пустой список и не пустой список. В первом случае список записывается как атом  [].  Во втором случае список следует рассматривать как структуру состоящую из двух частей:<br>   (1) первый элемент, называемый <i>головой</i> списка;<br>   (2) остальная часть списка, называемая <i>хвостом</i>.<br>   Например, для списка<br>   [ энн, теннис, том, лыжи ]<br>   энн — это голова, а хвостом является список<br>   [ теннис, том, лыжи ]<br>   В общем случае, головой может быть что угодно (любой прологовский объект, например, дерево или переменная); хвост же должен быть списком. Голова соединяется с хвостом при помощи специального функтора. Выбор этого функтора зависит от конкретной реализации Пролога; мы будем считать, что это точка:<br>   .( Голова, Хвост)<br>   Поскольку Хвост — это список, он либо пуст, либо имеет свои собственную голову и хвост. Таким образом, выбранного способа представления списков достаточно для представления списков любой длины. Наш список представляется следующим образом:<br>   .( энн, .( теннис, .( том, .( лыжи, [] ) ) ) )<br>   На рис. 3.1 изображена соответствующая древовидная структура. Заметим, что показанный выше пример содержит пустой список []. Дело в том, что самый последний хвост является одноэлементным списком:<br>   [ лыжи ]<br>   Хвост этого списка пуст<br>   [ лыжи ] = .( лыжи, [] )<br>   Рассмотренный пример показывает, как общий принцип структуризации объектов данных можно применить к спискам любой длины. Из нашего примера также видно, что такой примитивный способ представления в случае большой глубины вложенности подэлементов в хвостовой части списка может привести к довольно запутанным выражениям. Вот почему в Прологе предусматривается более лаконичный способ изображения списков, при котором они записываются как последовательности элементов, заключенные в квадратные скобки. Программист может использовать оба способа, но представление с квадратными скобками, конечно, в большинстве случаев пользуется предпочтением. Мы, однако, всегда будем помнить, что это всего лишь косметическое улучшение и что во внутреннем представлении наши списки выглядят как деревья. При выводе же они автоматически преобразуются в более лаконичную форму представления. Так, например, возможен следующий диалог:<br>   ?- Список1 = [а, b, с],<br>    Список2 = (a, .(b, .(c,[]) ) ).<br>
		 <br>   Список1 = [а, b, с]<br>   Список2 = [а, b, с]<br>
		 <br>   ?- Увлечения1 = .( теннис, .(музыка, [] ) ),<br>    Увлечения2 = [лыжи, еда],<br>    L = [энн, Увлечения1, том, Увлечения2].<br>
		 <br>   Увлечения1 = [теннис, музыка]<br>   Увлечения2 = [лыжи, еда]<br>   L = [энн, [теннис, музыка], том, [лыжи, еда]]<br><div align="center"><img border="1" src="_29.png"></div>   <b>Рис. 3.1.</b> Представление списка [энн, теннис, том, лыжи] в виде дерева.<br>   Приведенный пример также напоминает вам о том, что элементами списка могут быть любые объекты, в частности тоже списки.<br>   На практике часто бывает удобным трактовать хвост списка как самостоятельный объект. Например, пусть<br>   L = [а, b, с]<br>   Тогда можно написать:<br>   Хвост = [b, с] и L = .(а, Хвост)<br>   Для того, чтобы выразить это при помощи квадратных скобок, в Прологе предусмотрено еще одно расширение нотации для представления списка, а именно вертикальная черта, отделяющая голову от хвоста:<br>   L = [а | Хвост]<br>   На самом деле вертикальная черта имеет более общий смысл: мы можем перечислить любое количество элементов списка, затем поставить символ "|", а после этого — список остальных элементов. Так, только что рассмотренный пример можно представить следующими различными способами:<br>   [а, b, с] = [а | [b, с]] = [a, b | [c]] = [a, b, c | [ ]]<br>   Подытожим:<br>   • Список — это структура данных, которая либо пуста, либо состоит из двух частей: <i>головы</i> и <i>хвоста</i>. Хвост в свою очередь сам является списком.<br>   • Список рассматривается в Прологе как специальный частный случай двоичного дерева. Для повышения наглядности программ в Прологе предусматриваются специальные средства для списковой нотации, позволяющие представлять списки в виде<br>   [ Элемент1, Элемент2, ... ]<br>   или<br>   [ Голова | Хвост ]<br>   или<br>   [ Элемент1, Элемент2, ... | Остальные]<br></div>
<h3 align="center">
<a name="TOC_id3391224"></a>3.2. Некоторые операции над списками<br></h3>
<div>
<div>   Списки можно применять для представления множеств, хотя и существует некоторое различие между этими понятиями: порядок элементов множества не существенен, в то время как для списка этот порядок имеет значение; кроме того, один н тот же объект может встретиться в списке несколько раз. Однако наиболее часто используемые операции над списками аналогичны операциям над множествами. Среди них<br>   • проверка, является ли некоторый объект элементом списка, что соответствует проверке объекта на принадлежность множеству;<br>   • конкатенация (сцепление) двух списков, что соответствует объединению множеств;<br>   • добавление нового объекта в список или удаление некоторого объекта из него.<br>   В оставшейся части раздела мы покажем программы, реализующие эти и некоторые другие операции над списками.<br></div>
<h4 align="center">
<a name="TOC_id3391256"></a>3.2.1. Принадлежность к списку<br></h4>
<div>   Мы представим отношение принадлежности как<br>   принадлежит( X, L)<br>   где X — объект, а L — список. Цель принадлежит( X, L) истинна, если элемент X встречается в L. Например, верно что<br>   принадлежит( b, [а, b, с] )<br>   и, наоборот, не верно, что<br>   принадлежит b, [а, [b, с] ] )<br>   но<br>   принадлежит [b, с], [а, [b, с]] )<br>   истинно. Составление программы для отношения принадлежности может быть основано на следующих соображениях:<br>   (1) X есть голова L, либо<br>   (2) X принадлежит хвосту L.<br>   Это можно записать в виде двух предложений, первое из которых есть простой факт, а второе — правило:<br>   принадлежит( X, [X | Хвост ] ).<br>
		 <br>   принадлежит ( X, [Голова | Хвост ] ) :-<br>    принадлежит( X, Хвост).<br></div>
<h4 align="center">
<a name="TOC_id3422638"></a>3.2.2. Сцепление (конкатенация)<br></h4>
<div>   Для сцепления списков мы определим отношение<br>   конк( L1, L2, L3)<br>   Здесь L1 и L2 — два списка, a L3 — список, получаемый при их сцеплении. Например,<br>   конк( [а, b], [c, d], [a, b, c, d] )<br>   истинно, а<br>   конк( [а, b], [c, d], [a, b, a, c, d] )<br>   ложно. Определение отношения конк, как и раньше, содержит два случая в зависимости от вида первого аргумента L1:<br>   (1) Если первый аргумент пуст, тогда второй и третий аргументы представляют собой один и тот же список (назовем его L), что выражается в виде следующего прологовского факта:<br>   конк( [], L, L ).<br>   (2) Если первый аргумент отношения конк не пуст, то он имеет голову и хвост в выглядит так:<br>   [X | L1]<br>   На рис. 3.2 показано, как производится сцепление списка [X | L1] с произвольным списком L2. Результат сцепления — список [X | L3], где L3 получен после сцепления списков L1 и L2. На прологе это можно записать следующим образом:<br>   конк( [X | L1, L2, [X | L3]):-<br>    конк( L1, L2, L3).<br><div align="center"><img border="1" src="_30.png"></div>   <b>Рис. 3.2.</b> Конкатенация списков.<br>   Составленную программу можно теперь использовать для сцепления заданных списков, например:<br>   ?- конк( [a, b, с], [1, 2, 3], L ).<br>   L = [a, b, c, 1, 2, 3]<br>
		 <br>   ?- конк( [а, [b, с], d], [а, [], b], L ).<br>   L = [a, [b, c], d, а, [], b]<br>   Хотя программа для конк выглядит довольно просто, она обладает большой гибкостью и ее можно использовать многими другими способами. Например, ее можно применять как бы в обратном направлении для <i>разбиения</i> заданного списка на две части:<br>   ?- конк( L1, L2, [а, b, с] ).<br>
		 <br>   L1 = []<br>   L2 = [а, b, c];<br>
		 <br>   L1 = [а]<br>   L2 = [b, с];<br>
		 <br>   L1 = [а, b]<br>   L2 = [c];<br>
		 <br>   L1 = [а, b, с]<br>   L2 = [];<br>   no            (нет)<br>   Список [а, b, с] разбивается на два списка четырьмя способами, и все они были обнаружены нашей программой при помощи механизма автоматического перебора.<br>   Нашу программу можно также применить для поиска в списке комбинации элементов, отвечающей некоторому условию, задаваемому в виде шаблона или образца. Например, можно найти все месяцы, предшествующие данному, и все месяцы, следующие за ним, сформулировав такую цель:<br>   ?- конк( До, [май | После ],<br>    [янв, фев, март, апр, май, июнь,<br>     июль, авг, сент, окт, ноябрь, дек]).<br>
		 <br>   До = [янв, фев, март, апр]<br>   После = [июнь, июль, авг, сент, окт, ноябрь, дек].<br>   Далее мы сможем найти месяц, непосредственно предшествующий маю, и месяц, непосредственно следующий за ним, задав вопрос:<br>   ?- конк( _, [Месяц1, май, Месяц2 | _ ],<br>    [янв, февр, март, апр, май, июнь,<br>     июль, авг, сент, окт, ноябрь, дек]).<br>
		 <br>   Месяц1 = апр<br>   Месяц2 = июнь<br>   Более того, мы сможем, например, удалить из некоторого списка L1 все, что следует за тремя последовательными вхождениями элемента z в L1 вместе с этими тремя z. Например, это можно сделать так:<br>   ?- L1 = [a, b, z, z, c, z, z, z, d, e],<br>    конк( L2, [z, z, z | _ ], L1).<br>
		 <br>   L1 = [a, b, z, z, c, z, z, z, d, e]<br>   L2 = [a, b, z, z, c]<br>   Мы уже запрограммировали отношение принадлежности. Однако, используя конк, можно было бы определить это отношение следующим эквивалентным способом:<br>   принадлежит1( X, L) :-<br>    конк( L1, [X | L2], L).<br><div align="center"><img border="1" src="_31.png"></div>   <b>Рис. 3.3.</b> Процедура принадлежит1 находит элемент в заданном списке, производя по нему последовательный поиск.<br>   В этом предложении сказано: "X принадлежит L, если список L можно разбить на два списка таким образом, чтобы элемент X являлся головой второго из них. Разумеется, принадлежит1 определяет то же самое отношение, что и принадлежит. Мы использовали другое имя только для того, чтобы различать таким образом две разные реализации этого отношения, Заметим, что, используя анонимную переменную, можно записать вышеприведенное предложение так:<br>   принадлежит1( X, L) :-<br>    конк( _, [X | _ ], L).<br>   Интересно сравнить между собой эти две реализации отношения принадлежности. Принадлежит имеет довольно очевидный процедурный смысл:<br>    Для проверки, является ли X элементом списка L, нужно<br>    (1) сначала проверить, не совпадает ли голова списка L с X, а затем<br>    (2) проверить, не принадлежит ли X хвосту списка L.<br>   С другой стороны, принадлежит1, наоборот, имеет очевидный декларативный смысл, но его процедурный смысл не столь очевиден.<br>   Интересным упражнением было бы следующее: выяснить, как в действительности принадлежит1 что-либо вычисляет. Некоторое представление об этом мы получим, рассмотрев запись всех шагов вычисления ответа на вопрос:<br>   ?-  принадлежит1( b, [а, b, с] ).<br>   На рис. 3.3 приведена эта запись. Из нее можно заключить, что принадлежит1 ведет себя точно так же, как и принадлежит. Он просматривает список элемент за элементом до тех пор, пока не найдет нужный или пока не кончится список.<br><h5>Упражнения</h5>   <b>3.1.</b> (а) Используя отношение конк, напишите цель, соответствующую вычеркиванию трех последних элементов списка L, результат — новый список L1. Указание: L — конкатенация L1 и трехэлементного списка.<br>   (b) Напишите последовательность целей для порождения списка L2, получающегося из списка L вычеркиванием его трех первых и трех последних элементов.<br>   <b>3.2.</b> Определите отношение<br>   последний( Элемент, Список)<br>   так, чтобы Элемент являлся последним элементом списка Список. Напишите два варианта определения: (а) с использованием отношения конк, (b) без использования этого отношения.<br></div>
<h4 align="center">
<a name="TOC_id3606860"></a>3.2.3. Добавление элемента<br></h4>
<div>   Наиболее простой способ добавить элемент в список — это вставить его в самое начало так, чтобы он стал его новой головой. Если X — это новый элемент, а список, в который X добавляется — L, тогда результирующий список — это просто<br>   [X | L]<br>   Таким образом, для того, чтобы добавить новый элемент в начало списка, не надо использовать никакой процедуры. Тем не менее, если мы хотим определить такую процедуру в явном виде, то ее можно представить в форме такого факта:<br>   добавить( X, L, [X | L] ).<br></div>
<h4 align="center">
<a name="TOC_id3606885"></a>3.2.4. Удаление элемента<br></h4>
<div>   Удаление элемента X из списка L можно запрограммировать в виде отношения<br>   удалить( X, L, L1)<br>   где L1 совпадает со списком L, у которого удален элемент X. Отношение удалить можно определить аналогично отношению принадлежности. Имеем снова два случая:<br>   (1) Если X является головой списка, тогда результатом удаления будет хвост этого списка.<br>   (2) Если X находится в хвосте списка, тогда его нужно удалить оттуда.<br>   удалить( X, [X | Хвост], Хвост).<br>   удалить( X, [Y | Хвост], [Y | Хвост1] ) :-<br>    удалить( X, Хвост, Хвост1).<br>   как и принадлежит, отношение удалить по природе своей недетерминировано. Если в списке встречается несколько вхождений элемента X, то удалить сможет исключить их все при помощи возвратов. Конечно, вычисление по каждой альтернативе будет удалять лишь одно вхождение X, оставляя остальные в неприкосновенности. Например:<br>   ?- удалить( а, [а, b, а, а], L].<br>
		 <br>   L = [b, а, а];<br>   L = [а, b, а];<br>   L = [а, b, а];<br>   no            (нет)<br>   При попытке исключить элемент, не содержащийся в списке, отношение удалить потерпит неудачу.<br>   Отношение удалить можно использовать в обратном направлении для того, чтобы добавлять элементы в список, вставляя их в произвольные места. Например, если мы хотим во все возможные места списка [1, 2, 3] вставить атом а, то мы можем это сделать, задав вопрос: "Каким должен быть список L, чтобы после удаления из него элемента а получился список [1, 2, 3]?"<br>   ?- удалить( а, L, [1, 2, 3] ).<br>
		 <br>   L = [а, 1, 2, 3];<br>   L = [1, а, 2, 3];<br>   L = [1, 2, а, 3];<br>   L = [1, 2, 3, а];<br>   nо               (нет)<br>   Вообще операция по внесению X в произвольное место некоторого списка Список, дающее в результате БольшийСписок, может быть определена предложением:<br>   внести( X, Список, БольшийСписок) :-<br>    удалить( X, БольшийСписок, Список).<br>   В принадлежит1 мы изящно реализовали отношение принадлежности через конк. Для проверки на принадлежность можно также использовать и удалить. Идея простая: некоторый X принадлежит списку Список, если X можно из него удалить:<br>   принадлежит2( X, Список) :-<br>    удалить( X, Список, _ ).<br></div>
<h4 align="center">
<a name="TOC_id3578007"></a>3.2.5. Подсписок<br></h4>
<div>   Рассмотрим теперь отношение подсписок. Это отношение имеет два аргумента — список L и список S, такой, что S содержится в L в качестве подсписка. Так отношение<br>   подсписок( [c, d, e], [a, b, c, d, e, f] )<br>   имеет место, а отношение<br>   подсписок( [c, e], [a, b, c, d, e, f] )<br>   нет. Пролог-программа для отношения подсписок может основываться на той же идее, что и принадлежит1, только на этот раз отношение более общо (см. рис. 3.4).<br><div align="center"><img border="1" src="_32.png"></div>   <b>Рис. 3.4.</b> Отношения принадлежит и подсписок.<br>   Его можно сформулировать так:<br>    S является подсписком L, если<br>     (1) L можно разбить на два списка L1 и L2 и<br>     (2) L2 можно разбить на два списка S и L3.<br>   Как мы видели раньше, отношение конк можно использовать для разбиения списков. Поэтому вышеприведенную формулировку можно выразить на Прологе так:<br>   подсписок( S, L) :-<br>    конк( L1, L2, L),<br>    конк( S, L3, L2).<br>   Ясно, что процедуру подсписок можно гибко использовать различными способами. Хотя она предназначалась для проверки, является ли какой-либо список подсписком другого, ее можно использовать, например, для нахождения всех подсписков данного списка:<br>   ?-  подсписок( S, [а, b, с] ).<br>
		 <br>   S = [];<br>   S = [a];<br>   S = [а, b];<br>   S = [а, b, с];<br>   S = [b];<br>   ...<br></div>
<h4 align="center">
<a name="TOC_id3390728"></a>3.2.6. Перестановки<br></h4>
<div>   Иногда бывает полезно построить все перестановки некоторого заданного списка. Для этого мы определим отношение перестановка с двумя аргументами. Аргументы — это два списка, один из которых является перестановкой другого. Мы намереваемся порождать перестановки списка с помощью механизма автоматического перебора, используя процедуру перестановка, подобно тому, как это делается в следующем примере:<br>   ?- перестановка( [а, b, с], P).<br>
		 <br>   P = [а, b, с];<br>   P = [а, с, b];<br>   P = [b, а, с];<br>   ...<br><div align="center"><img border="1" src="_33.png"></div>   <b>Рис. 3.5.</b> Один из способов построения перестановки списка [X | L].<br>   Программа для отношения перестановка в свою очередь опять может основываться на рассмотрении двух случаев в зависимости от вида первого списка:<br>   (1) Если первый список пуст, то и второй список должен быть пустым.<br>   (2) Если первый список не пуст, тогда он имеет вид [X | L], и перестановку такого списка можно построить так, как это показано на рис. 3.5: вначале получить список L1 — перестановку L, а затем внести X в произвольную позицию L1.<br>   Два прологовских предложения, соответствующих этим двум случаям, таковы:<br>   перестановка( [], []).<br>   перестановка( [X | L ], P) :-<br>    перестановка( L, L1),<br>    внести( X, L1, P).<br>   Другой вариант этой программы мог бы предусматривать удаление элемента X из первого списка, перестановку оставшейся его части — получение списка P, а затем добавление X в начало списка P. Соответствующая программа такова:<br>   перестановка2( [], []).<br>   перестановка2( L, [X | P] ) :-<br>    удалить( X, L, L1),<br>    перестановка2( L1, P).<br>   Поучительно проделать несколько экспериментов с нашей программой перестановки. Ее нормальное использование могло бы быть примерно таким:<br>   ?-  перестановка( [красный, голубой, зеленый], P).<br>   Как и предполагалось, будут построены все шесть перестановок:<br>   P = [ красный, голубой, зеленый];<br>   P = [ красный, зеленый, голубой];<br>   P = [ голубой, красный, зеленый];<br>   P = [ голубой, зеленый, красный];<br>   P = [ зеленый, красный, голубой];<br>   P = [ зеленый, голубой, красный];<br>   no                               (нет)<br>   Приведем другой вариант использования процедуры перестановка:<br>   ?-  перестановка( L, [а, b, с] ).<br>   Наша первая версия, перестановка, произведет успешную конкретизацию L всеми шестью перестановками. Если пользователь потребует новых решений, он никогда не получит ответ "нет", поскольку программа войдет в бесконечный цикл, пытаясь отыскать новые несуществующие перестановки. Вторая версия, перестановка2, в этой ситуации найдет только первую (идентичную) перестановку, а затем сразу зациклится. Следовательно, при использовании этих отношений требуется соблюдать осторожность.<br><h5>Упражнения</h5>   <b>3.3.</b> Определите два предиката<br>   четнаядлина( Список) и нечетнаядлина( Список)<br>   таким образом, чтобы они были истинными, если их аргументом является список четной или нечетной длины соответственно. Например, список [а, b, с, d] имеет четную длину, a [a, b, c] — нечетную.<br>   <b>3.4.</b> Определите отношение<br>   обращение( Список, ОбращенныйСписок),<br>   которое обращает списки. Например,<br>   обращение( [a, b, c, d], [d, c, b, a] ).<br>   <b>3.5.</b> Определите предикат<br>   палиндром( Список).<br>   Список называется палиндромом, если он читается одинаково, как слева направо, так и справа налево. Например, [м, а, д, а, м].<br>   <b>3.6.</b> Определите отношение<br>   сдвиг( Список1, Список2)<br>   таким образом, чтобы Список2 представлял собой Список1, "циклически сдвинутый" влево на один символ. Например,<br>   ?- сдвиг( [1, 2, 3, 4, 5], L1),<br>    сдвиг1( LI, L2)<br>   дает<br>   L1 = [2, 3, 4, 5, 1]<br>   L2 = [3, 4, 5, 1, 2]<br>   <b>3.7.</b> Определите отношение<br>   перевод( Список1, Список2)<br>   для перевода списка чисел от 0 до 9 в список соответствующих слов. Например,<br>   перевод( [3, 5, 1, 3], [три, пять, один, три] )<br>   Используйте в качестве вспомогательных следующие отношения:<br>   означает( 0, нуль).<br>   означает( 1, один).<br>   означает( 2, два).<br>   ...<br>   <b>3.8.</b> Определите отношение<br>   подмножество( Множество, Подмножество)<br>   где Множество и Подмножество — два списка представляющие два множества. Желательно иметь возможность использовать это отношение не только для проверки включения одного множества в другое, но и для порождения всех возможных подмножеств заданного множества. Например:<br>   ?-  подмножество( [а, b, с], S ).<br>
		 <br>   S = [a, b, c];<br>   S = [b, c];<br>   S = [c];<br>   S = [];<br>   S = [a, c];<br>   S = [a];<br>   ...<br>   <b>3.9.</b> Определите отношение<br>   разбиениесписка( Список, Список1, Список2)<br>   так, чтобы оно распределяло элементы списка между двумя списками Список1 и Список2 и чтобы эти списки были примерно одинаковой длины. Например:<br>   разбиениесписка( [а, b, с, d, e], [a, с, e], [b, d]).<br>   <b>3.10.</b> Перепишите программу об обезьяне и бананах из главы 2 таким образом, чтобы отношение<br>   можетзавладеть( Состояние, Действия)<br>   давало не только положительный или отрицательный ответ, но и порождало последовательность действий обезьяны, приводящую ее к успеху. Пусть Действия будет такой последовательностью, представленной в виде списка ходов:<br>   Действия = [ перейти( дверь, окно),<br>                передвинуть( окно, середина),<br>                залезть, схватить ]<br>   <b>3.11.</b> Определите отношение<br>   линеаризация( Список, ЛинейныйСписок)<br>   где Список может быть списком списков, а ЛинейныйСписок — это тот же список, но "выровненный" таким образом, что элементы его подсписков составляют один линейный список. Например:<br>   ?- линеаризация( [а, d, [с, d], [], [[[e]]], f, L).<br>   L = [a, b, c, d, e, f]<br></div>
</div>
<h3 align="center">
<a name="TOC_id3606768"></a>3.3. Операторная запись (нотация)<br></h3>
<div>   В математике мы привыкли записывать выражения в таком виде:<br>   <i>2*a + b*с</i><br>   где + и * — это операторы, а <i>2</i>, <i>а</i>, <i>b</i>,<i> с</i> — аргументы. В частности, + и * называют <i>инфиксными</i> операторами, поскольку они появляются <i>между</i> своими аргументами. Такие выражения могут быть представлены в виде деревьев, как это сделано на рис. 3.6, и записаны как прологовские термы с + и * в качестве функторов:<br>   +( *( 2, а), *( b, с) )<br>
		 <br><div align="center"><img border="1" src="_34.png"></div>   <b>Рис. 3.6.</b> Представление выражения <i>2*а+b*с</i> в виде дерева.<br>   Поскольку мы обычно предпочитаем записывать такие выражения в привычной инфиксной форме операторов, Пролог обеспечивает такое удобство. Поэтому наше выражение, записанное просто как<br>   2*а + b*с<br>   будет воспринято правильно. Однако это лишь внешнее представление объекта, которое будет автоматически преобразовано в обычную форму прологовских термов. Такой терм выводится пользователю снова в своей внешней инфиксной форме.<br>   Выражения рассматриваются Прологом просто как дополнительный способ записи, при котором не вводятся какие-либо новые принципы структуризации объектов данных. Если мы напишем а + b,  Пролог поймет эту запись, как если бы написали +(а, b). Для того, чтобы Пролог правильно воспринимал выражения типа а + b*с, он должен знать, что * связывает сильнее, чем +. Будем говорить, что + имеет более низкий приоритет, чем *. Поэтому верная интерпретация выражений зависит от приоритетов операторов. Например, выражение а + b*с, в принципе можно понимать и как<br>   +( а, *( b, с) )<br>   и как<br>   *( +( а, b), с)<br>   Общее правило состоит в том, что оператор с самым низким приоритетом расценивается как главный функтор терма. Если мы хотим, чтобы выражения, содержащие + и *, понимались в соответствии с обычными соглашениями, то + должен иметь более низкий приоритет, чем *. Тогда выражение а + b*с означает то же, что и а + (b*с). Если имеется в виду другая интерпретация, то это надо указать явно с помощью скобок, например (а+b)*с.<br>   Программист может вводить свои собственные операторы. Так, например, можно определить атомы имеет и поддерживает в качестве инфиксных операторов, а затем записывать в программе факты вида:<br>   питер имеет информацию.<br>   пол поддерживает стол.<br>   Эти факты в точности эквивалентны следующим:<br>   имеет( питер, информацию).<br>   поддерживает( пол, стол).<br>   Программист определяет новые операторы, вводя в программу особый вид предложений, которые иногда называют <i>директивами</i>. Такие предложения играют роль определений новых операторов. Определение оператора должно появиться в программе раньше, чем любое выражение, использующее этот оператор. Например, оператор имеет можно определить директивой<br>   :- op( 600, xfx, имеет).<br>   Такая запись сообщит Прологу, что мы хотим использовать "имеет" в качестве оператора с приоритетом 600 и типом 'xfx', обозначающий одну из разновидностей инфиксного оператора. Форма спецификатора 'xfx' указывает на то, что оператор, обозначенный через 'f', располагается между аргументами, обозначенными через 'х'.<br>   Обратите внимание на то, что определения операторов не содержат описания каких-либо операций или действий. В соответствии с принципами языка <i>ни</i> с <i>одним оператором не связывается каких-либо операций над данными</i> (за исключением особых, редких случаев). Операторы обычно используются так же, как и функторы, только для объединения объектов в структуры и не вызывают действия над данными, хотя само слово "оператор", казалось бы, должно подразумевать какое-то действие.<br>   Имена операторов это атомы, а их приоритеты — точнее, номера их приоритетов — должны находиться в некотором диапазоне, зависящем от реализации. Мы будем считать, что этот диапазон располагается в пределах от 1 до 1200.<a href="#n_1" title="Чем выше приоритет, тем меньше его номер. — Прим. перев."><sup>[1]</sup></a><br>   Существуют три группы типов операторов, обозначаемые спецификаторами, похожими на xfx:<br>   (1) инфиксные операторы трех типов:<br>   xfx xfy yfx<br>   (2) префиксные операторы двух типов:<br>   fx fy<br>   (3) постфиксные операторы двух типов:<br>   хf yf<br>   Спецификаторы выбраны с таким расчетом, чтобы нагляднее отразить структуру выражения, в котором 'f' соответствует оператору, а 'x' и 'y' представляют его аргументы. Расположение 'f' между аргументами указывает на то, что оператор инфиксный. Префиксные и постфиксные спецификаторы содержат только один аргумент, который, соответственно, либо следует за оператором, либо предшествует ему.<br><div align="center"><img border="1" src="_35.png"></div>   <b>Рис. op3.7.</b>  Две интерпретации выражения а-b-с в предположении, что '-' имеет приоритет 500. Если тип '-' есть yfx, то интерпретация 2 неверна, так как приоритет b-с не выше, чем приоритет '-'.<br>   Между 'x' и 'y' есть разница. Для ее объяснения нам потребуется ввести понятие <i>приоритета аргумента</i>. Если аргумент заключен в скобки или не имеет структуры (является простым объектом), тогда его приоритет равен 0; если же он структурный, тогда его приоритет равен приоритету его главного функтора. С помощью 'x' обозначается аргумент, чей приоритет должен быть строго выше приоритета оператора (т e. его номер строго меньше номера приоритета оператора); с помощью 'y' обозначается аргумент, чей приоритет выше или равен приоритету оператора.<br>   Такие правила помогают избежать неоднозначности при обработке выражений, в которых встречаются операторы с одинаковым приоритетом. Например, выражение<br>   а-b-с<br>   обычно понимается как (а-b)-с, а не как а-(b-с). Чтобы обеспечить такую обычную интерпретацию, оператор '-' следует определять как yfx. На рис. 3.7 показано, каким образом исключается вторая интерпретация.<br>   В качестве еще одного примера рассмотрим оператор not (логическое отрицание "не"). Если not oпределён как fy, тогда выражение<br>    not not p<br>   записано верно; однако, если not определен как fx, оно некорректно, потому что аргументом первого not является структура not p, которая имеет тот же приоритет, что и not. В этом случае выражение следует писать со скобками:<br>   not (not p)<br>
		 <br>   :- op( 1200, xfx, ':-').<br>   :- op( 1200, fx, [:-, ?-] ).<br>   :- op( 1100, xfy, ';').<br>   :- op( 1000, xfy, ',').<br>   :- op( 700, xfx, [=, is, &lt;, &gt;, =&lt;, &gt;=, ==, =\=, \==, =:=]).<br>   :- op( 500, yfx, [+, -] ).<br>   :- op( 500, fx, [+, -, not] ).<br>   :- op( 400, yfx, [*, /, div] ).<br>   :- op( 300, xfx, mod).<br>   <b>Рис. 3.8.</b> Множество предопределенных операторов.<br>
		 <br>   Для удобства некоторые операторы в пролог-системах определены заранее, чтобы ими можно было пользоваться сразу, без какого-либо определения их в программе. Набор таких операторов и их приоритеты зависят от реализации. Мы будем предполагать, что множество этих "стандартных" операторов ведет себя так, как если бы оно было определено с помощью предложений, приведенных на рис. 3.8. Как видно из того же рисунка, несколько операторов могут быть определены в одном предложении, если только они все имеют одинаковый приоритет и тип. В этом случае имена операторов записываются в виде списка. Использование операторов может значительно повысить наглядность, "читабельность" программы. Для примера предположим, что мы пишем программу для обработки булевских выражений. В такой программе мы, возможно, захотим записать утверждение одной из теорем де Моргана, которое в математических обозначениях записывается так:<br>   ~ (А &amp; В) &lt;===&gt; ~А v ~В<br>   Приведем один из способов записи этого утверждения в виде прологовского предложения:<br>   эквивалентно( not( и( А, В)), или( not( A, not( B))).<br>   Однако хорошим стилем программирования было бы попытаться сохранить по возможности больше сходства между видом записи исходной задачи и видом, используемом в программе ее решения. В нашем примере этого можно достичь почти в полной мере, применив операторы. Подходящее множество операторов для наших целей можно определить так:<br>   :- op( 800, xfx, &lt;===&gt;).<br>   :- op( 700, xfy, v).<br>   :- op( 600, хfу, &amp;).<br>   :- op( 500, fy, ~).<br>   Теперь правило де Моргана можно записать в виде следующего факта:<br>   ~(А &amp; В) &lt;===&gt; ~А v ~В.<br>   В соответствии с нашими определениями операторов этот терм понимается так, как это показано на рис. 3.9.<br><div align="center"><img border="1" src="_36.png"></div>   <b>Рис. 3.9.</b> Интерпретация терма ~(А &amp; В) &lt;===&gt; ~A v ~В<br>   Подытожим:<br>   • Наглядность программы часто можно улучшить, использовав операторную нотацию. Операторы бывают инфиксные, префиксные и постфиксные.<br>   • В принципе, с оператором не связываются никакие действия над данными, за исключением особых случаев. Определение оператора не содержит описания каких-либо действий, оно лишь вводит новый способ записи. Операторы, как и функторы, лишь связывают компоненты в единую структуру.<br>   • Программист может вводить свои собственные операторы. Каждый оператор определяется своим именем, приоритетом и типом.<br>   • Номер приоритета — это целое число из некоторого диапазона, скажем, между 1 и 1200. Оператор с самым больший номером приоритета соответствует главному функтору выражения, в котором этот оператор встретился. Операторы с меньшими номерами приоритетов связывают свои аргументы сильнее других операторов.<br>   • Тип оператора зависит от двух условий: (1) его расположения относительно своих аргументов, (2) приоритета его аргументов по сравнению с его собственным. В спецификаторах, таких, как xfy, x обозначает аргумент, чей номер приоритета строго меньше номера приоритета оператора; y — аргумент с номером приоритета, меньшим или равным номеру приоритета оператора.<br><h5>Упражнения</h5>   <b>3.12.</b> Если принять такие определения<br>   :- op( 300, xfy, играет_в).<br>   :- op( 200, xfy, и).<br>   то два следующих терма представляют собой синтаксически правильные объекты:<br>   Tepм1 = джимми играет_в футбол и сквош<br>   Терм1 = сьюзан играет_в теннис и баскетбол и волейбол<br>   Как эти термы интерпретируются пролог-системой? Каковы их главные функторы и какова их структура?<br>   <b>3.13.</b> Предложите подходящее определение операторов ("работает", "в", "нашем"), чтобы можно было писать предложения типа:<br>   диана работает секретарем в нашем отделе.<br>   а затем спрашивать:<br>   ?- Кто работает секретарем в нашем отделе.<br>   Кто = диана<br>
		 <br>   ?- диана работает Кем.<br>   Кем = секретарем в нашем отдела<br>   <b>3.14.</b> Рассмотрим программу:<br>   t( 0+1, 1+0).<br>
		 <br>   t( X+0+1, X+1+0).<br>
		 <br>   t( X+1+1, Z) :-<br>    t( X+1, X1),<br>    t( X1+1, Z).<br>   Как данная программа будет отвечать на ниже перечисленные вопросы, если '+' — это (как обычно) инфиксный оператор типа yfx?<br>   (a) ?- t( 0+1, А).<br>   (b) ?- t( 0+1+1, В).<br>   (с) ?- t( 1+0+1+1+1, С).<br>   (d) ?- t( D, 1+1+1+0).<br>   <b>3.15.</b> В предыдущем разделе отношения между списка ми мы записывали так:<br>   принадлежит( Элемент, Список),<br>    конк( Список1, Список2, Список3),<br>    удалить( Элемент, Список, НовыйСписок), ...<br>   Предположим, что более предпочтительной для нас является следующая форма записи:<br>   Элемент входит_в Список,<br>    конкатенация_списков Список1 и Список2<br>     дает Список3,<br>    удаление_элемента Элемент из_списка Список<br>     дает НовыйСписок, ...<br>   Определите операторы "входит_в", "конкатенация_списков", "и" и т.д. таким образом, чтобы обеспечить эту возможность. Переопределите также и соответствующие процедуры.<br></div>
<h3 align="center">
<a name="TOC_id3488143"></a>3.4. Арифметические действия<br></h3>
<div>   Пролог рассчитан главным образом на обработку символьной информации, при которой потребность в арифметических вычислениях относительно мала. Поэтому и средства для таких вычислений довольно просты. Для осуществления основных арифметических действий можно воспользоваться несколькими предопределенными операторами.<br>   +   сложение<br>   -   вычитание<br>   *   умножение<br>   /   деление<br>   mod модуль, остаток от целочисленного деления<br>   Заметьте, что это как раз тот исключительный случай. когда оператор может и в самом деле произвести некоторую операцию. Но даже и в этом случае требуется дополнительное указание на выполнение действия. Пролог-система знает, как выполнять вычисления, предписываемые такими операторами, но этого недостаточно для их непосредственного использования. Следующий вопрос - наивная попытка произвести арифметическое действие:<br>   ?- X = 1 + 2.<br>   Пролог-система "спокойно" ответит<br>   X = 1 + 2<br>   а не X = 3, как, возможно, ожидалось. Причина этого проста: выражение 1 + 2 обозначает лишь прологовский терм, в котором + является функтором, а 1 и 2 — его аргументами. В вышеприведенной цели нет ничего, что могло бы заставить систему выполнить операцию сложения. Для этого в Прологе существует специальный оператор is (есть). Этот оператор заставит систему выполнить вычисление. Таким образом, чтобы правильно активизировать арифметическую операцию, надо написать:<br>   ?- X is 1 + 2.<br>   Вот теперь ответ будет<br>   X = 3<br>   Сложение здесь выполняется специальной процедурой, связанной с оператором +. Мы будем называть такие процедуры <i>встроенными</i>.<br>   В Прологе не существует общепринятой нотации для записи арифметических действий, поэтому в разных реализациях она может слегка различаться. Например, оператор '/' может в одних реализациях обозначать целочисленное деление, а в других — вещественное. В данной книге под '/' мы подразумеваем вещественное деление, для целочисленного же будем использовать оператор div. В соответствии с этим, на вопрос<br>   ?- X is 3/2,<br>    Y is 3 div 2.<br>   ответ должен быть такой:<br>   X = 1.5<br>   Y = 1<br>   Левым аргументом оператора is является простой объект. Правый аргумент — арифметическое выражение, составленное с помощью арифметических операторов, чисел и переменных. Поскольку оператор is запускает арифметические вычисления, к моменту начала вычисления этой цели все ее переменные должны быть уже конкретизированы какими-либо числами. Приоритеты этих предопределенных арифметических операторов (см. рис. 3.8) выбраны с таким расчетом, чтобы операторы применялись к аргументам в том порядке, который принят в математике. Чтобы изменить обычный порядок вычислений, применяются скобки (тоже, как в математике). Заметьте, что +, -, *, / и div определены, как yfx, что определяет порядок их выполнения слева направо. Например,<br>   X is 5 - 2 - 1<br>   понимается как<br>   X is (5 - 2) - 1<br>   Арифметические операции используются также и при <i>сравнении</i> числовых величин. Мы можем, например, проверить, что больше — 10000 или результат умножения 277 на 37, с помощью цели<br>   ?- 277 * 37 &gt; 10000.<br>   yes            (да)<br>   Заметьте, что точно так же, как и is, оператор '&gt;' вызывает выполнение вычислений.<br>   Предположим, у нас есть программа, в которую входит отношение рожд, связывающее имя человека с годом его рождения. Тогда имена людей, родившихся между 1950 и 1960 годами включительно, можно получить при помощи такого вопроса:<br>   ?- рожд( Имя, Год),<br>    Год &gt;= 1950,<br>    Год &lt;= 1960.<br>   Ниже перечислены операторы сравнения:<br>   X &gt; Y   X больше Y<br>   X &lt; Y   X меньше Y<br>   X &gt;= Y  X больше или равен Y<br>   X =&lt; Y  X меньше или равен Y<br>   X =:= Y величины X и Y совпадают (равны)<br>   X =\= Y величины X и Y не равны<br>   Обратите внимание на разницу между операторами сравнения '=' и '=:=', например, в таких целях как X = Y и X =:= Y. Первая цель вызовет сопоставление объектов X и Y, и, если X и Y сопоставимы, возможно, приведет к конкретизации каких-либо переменных в этих объектах. Никаких вычислений при этом производиться не будет. С другой стороны, X =:= Y вызовет арифметическое вычисление и не может привести к конкретизации переменных. Это различие можно проиллюстрировать следующими примерами:<br>   ?- 1 + 2 =:= 2 + 1.<br>   yes<br>
		 <br>   ?- 1 + 2 = 2 + 1.<br>   no<br>
		 <br>   ?- 1 + А = В + 2.<br>   А = 2<br>   В = 1<br>   Давайте рассмотрим использование арифметических операций на двух простых примерах. В первом примере ищется наибольший общий делитель; во втором — определяется количество элементов в некотором списке.<br>   Если заданы два целых числа X и Y, то их наибольший общий делитель Д можно найти, руководствуясь следующими тремя правилами:<br>   (1) Если X и Y равны, то Д равен X.<br>   (2) Если X &gt; Y, то Д равен наибольшему общему делителю X разности Y – X.<br>   (3) Если Y &lt; X, то формулировка аналогична правилу (2), если X и Y поменять в нем местами.<br>   На примере легко убедиться, что эти правила действительно позволяют найти наибольший общий делитель. Выбрав, скажем, X = 20 и Y = 25, мы, руководствуясь приведенными выше правилами, после серии вычитаний получим Д = 5.<br>   Эти правила легко сформулировать в виде прологовской программы, определив трехаргументное отношение, скажем<br>   нод( X , Y, Д)<br>   Тогда наши три правила можно выразить тремя предложениями так:<br>   нод( X, X, X).<br>
		 <br>   нод( X, Y, Д) :-<br>    X &lt; Y,<br>    Y1 is Y - X,<br>    нод( X, Y1, Д).<br>
		 <br>   нод( X, Y, Д) :-<br>    Y &lt; X,<br>    нод( Y, X, Д).<br>   Разумеется, с таким же успехом можно последнюю цель в третьем предложении заменить двумя:<br>   X1 is X - Y,<br>   нод( X1, Y, Д)<br>   В нашем следующем примере требуется произвести некоторый подсчет, для чего, как правило, необходимы арифметические действия. Примером такой задачи может служить вычисление длины какого-либо списка; иначе говоря, подсчет числа его элементов. Определим процедуру<br>   длина( Список, N)<br>   которая будет подсчитывать элементы списка Список и конкретизировать N полученным числом. Как и раньше, когда речь шла о списках, полезно рассмотреть два случая:<br>   (1) Если список пуст, то его длина равна 0.<br>   (2) Если он не пуст, то Список = [Голова1 | Хвост] и его длина равна 1 плюс длина хвоста Хвост.<br>   Эти два случая соответствуют следующей программе:<br>   длина( [], 0).<br>
		 <br>   длина( [ _ | Хвост], N) :-<br>    длина( Хвост, N1),<br>    N is 1 + N1.<br>   Применить процедуру длина можно так:<br>   ?- длина( [a, b, [c, d], e], N).<br>   N = 4<br>   Заметим, что во втором предложении этой процедуры две цели его тела нельзя поменять местами. Причина этого состоит в том, что переменная N1 должна быть конкретизирована до того, как начнет вычисляться цель<br>   N is 1 + N1<br>   Таким образом мы видим, что введение встроенной процедуры is привело нас к примеру отношения, чувствительного к порядку обработки предложений и целей. Очевидно, что процедурные соображения для подобных отношений играют жизненно важную роль.<br>   Интересно посмотреть, что произойдет, если мы попытаемся запрограммировать отношение длина без использования is. Попытка может быть такой:<br>   длина1( [ ], 0).<br>
		 <br>   длина1( [ _ | Хвост], N) :-<br>    длина1( Хвост, N1),<br>    N = 1 + N1.<br>   Теперь уже цель<br>   ?- длина1( [a, b, [c, d], e], N).<br>   породит ответ:<br>   N = 1+(1+(1+(1+0)))<br>   Сложение ни разу в действительности не запускалось и поэтому ни разу не было выполнено. Но в процедуре длина1, в отличие от процедуры длина, мы можем поменять местами цели во втором предложении:<br>   длина1( _ | Хвост], N) :-<br>    N = 1 + N1,<br>    длина1( Хвост, N1).<br>   Такая версия длина1 будет давать те же результаты, что и исходная. Ее можно записать короче:<br>   длина1( [ _ | Хвост], 1 + N) :-<br>    длина1( Хвост, N).<br>   и она и в этом случае будет давать те же результаты. С помощью длина1, впрочем, тоже можно вычислять количество элементов списка:<br>   ?- длина( [а, b, с], N), Длина is N.<br>
		 <br>   N = 1+(1+(l+0))<br>   Длина = 3<br>   Итак:<br>   • Для выполнения арифметических действий используются встроенные процедуры.<br>   • Арифметические операции необходимо явно запускать при помощи встроенной процедуры is. Встроенные процедуры связаны также с предопределенными операторами +, -, *, /, div и mod.<br>   • К моменту выполнения операций все их аргументы должны быть конкретизированы числами.<br>   • Значения арифметических выражений можно сравнивать с помощью таких операторов, как &lt;, =&lt; и т.д. Эти операторы вычисляют значения своих аргументов.<br><h5>Упражнения</h5>   <b>3.16.</b> Определите отношение<br>   mах( X, Y, Мах)<br>   так, чтобы Мах равнялось наибольшому из двух чисел X и Y.<br>   <b>3.17.</b> Определите предикат<br>   максспис( Список, Мах)<br>   так, чтобы Мах равнялось наибольшему из чисел, входящих в Список.<br>   <b>3.18.</b> Определите предикат<br>   сумспис( Список, Сумма)<br>   так, чтобы Сумма равнялось сумме чисел, входящих в Список.<br>   <b>3.19.</b> Определите предикат<br>   упорядоченный( Список)<br>   который принимает значение истина, если Список представляет собой упорядоченный список чисел. Например: упорядоченный [1, 5, 6, 6, 9, 12] ).<br>   <b>3.20.</b> Определите предикат<br>   подсумма( Множ, Сумма, ПодМнож)<br>   где Множ это список чисел, Подмнож подмножество этих чисел, а сумма чисел из ПодМнож равна Сумма. Например:<br>   ?- подсумма( [1, 2, 5, 3, 2], 5, ПМ).<br>   ПМ = [1, 2, 2];<br>   ПМ = [2, 3];<br>   ПМ = [5];<br>   ...<br>   <b>3.21.</b> Определите процедуру<br>   между( N1, N2, X)<br>   которая, с помощью перебора, порождает все целые числа X, отвечающие условию N1&#8804;X&#8804;N2.<br>   <b>3.22.</b>    Определите операторы 'если', 'то', 'иначе' и ':=" таким образом, чтобы следующее выражение стало правильным термом:<br>   если X &gt; Y то Z := X иначе Z := Y<br>   Выберите приоритеты так, чтобы  'если' стал главным функтором. Затем определите отношение 'если' так, чтобы оно стало как бы маленьким интерпретатором выражений типа 'если-то-иначе'. Например, такого<br>   если Вел1 &gt; Вел2 то Перем := Вел3<br>   иначе Перем := Вел4<br>   где Вел1, Вел2, Вел3 и Вел4 — числовые величины (или переменные, конкретизированные числами), а Перем — переменная. Смысл отношения 'если' таков: если значение Вел1 больше значения Вел2, тогда Перем конкретизируется значением Вел3, в противном случае — значением Вел4. Приведем пример использования такого интерпретатора:<br>   ?- X = 2, Y = 3,<br>    Вел2 is 2*X,<br>    Вел4 is 4*X,<br>    Если Y &gt; Вел2 то Z := Y иначе Z := Вел4.<br>    Если Z &gt; 5 то W := 1 иначе W :=0.<br>
		 <br>   X = 2<br>   Y = 3<br>   Z = 8<br>   W = 1<br>
		 <br>   Вел2 = 4<br>   Вел4 = 8<br></div>
<h3 align="center">
<a name="TOC_id3501608"></a>Резюме<br></h3>
<div>   • Список — часто используемая структура. Он либо пуст, либо состоит из <i>головы</i> и <i>хвоста</i>, который в свою очередь также является списком. Для списков в Прологе имеется специальная нотация.<br>   • В данной главе рассмотрены следующие операции над списками: принадлежность к списку, конкатенация, добавление элемента, удаление элемента, удаление подсписка.<br>   • <i>Операторная запись</i> позволяет программисту приспособить синтаксис программ к своим конкретным нуждам. С помощью операторов можно значительно повысить наглядность программ.<br>   • Новые операторы определяются с помощью директивы op, в которой указываются его имя, тип и приоритет.<br>   • Как правило, с оператором не связывается никакой операции; оператор это просто синтаксическое удобство, обеспечивающее альтернативный способ записи термов.<br>   • Арифметические операции выполняются с помощью встроенных процедур. Вычисление арифметических выражений запускается процедурой is, а также предикатами сравнения &lt;, =&lt; и т.д.<br>   • Понятия, введенные в данной главе:<br>    список, голова списка, хвост списка<br>    списковая нотация<br>    операторы, операторная нотация<br>    инфиксные, префиксные и постфиксные операторы<br>    приоритет операторов<br>    арифметические встроенные процедуры <br></div>
</div>
<h2 align="center">
<a name="TOC_id3417198"></a>Глава 4<br>Использование структур: примеры<br></h2>
<div>
<div>   Структуры данных вместе с сопоставлением, автоматическими возвратами и арифметикой представляют собой мощный инструмент программирования. В этой главе мы расширим навыки использования этого инструмента при помощи следующих учебных программных примеров: получение структурированной информации из базы данных, моделирование недетерминированного автомата, планирование маршрута поездки и решение задачи о расстановке восьми ферзей на шахматной доске. Мы увидим также, как в Прологе реализуется принцип абстракции данных.<br></div>
<h3 align="center">
<a name="TOC_id3417218"></a>4.1. Получение структурированной информации из базы данных<br></h3>
<div>   Это упражнение развивает навыки представления структурных объектов данных и управления ими. Оно показывает также, что Пролог является естественным языком запросов к базе данных.<br>   База данных может быть представлена на Прологе в виде множества фактов. Например, в базе данных о семьях каждая семья может описываться одним предложением. На рис. 4.1 показано, как информацию о каждой семье можно представить в виде структуры. Каждая семья состоит из трех компонент: мужа, жены и детей. Поскольку количество детей в разных семьях может быть разным, то их целесообразно представить в виде списка, состоящего из произвольного числа элементов. Каждого члена семьи в свою очередь можно представить структурой, состоящей из четырех компонент: имени, фамилии, даты рождения и работы. Информация о работе — это либо "не работает", либо указание места работа и оклада (дохода). Информацию о семье, изображенной на рис. 4.1, можно занести в базу данных с помощью предложения:<br>   семья( членсемьи( том, фокс, дата( 7, май, 1950),<br>    работает( bbс, 15200) ),<br>    членсемьи( энн, фокс, дата( 9, май, 1951), неработает),<br>    [членсемьи( пат, фокс, дата( 5, май, 1973), неработает),<br>    членсемьи( джим, фокс, дата( 5, май, 1973), неработает) ] ).<br><div align="center"><img border="1" src="_37.png"></div>   <b>Рис. 4.1.</b> Структурированная информация о семье.<br>   Тогда база данных будет состоять из последовательности фактов, подобных этому, и описывать все семьи, представляющие интерес для нашей программы.<br>   В действительности Пролог очень удобен для извлечения необходимой информации из такой базы данных. Здесь хорошо то, что можно ссылаться на объекты, не указывая в деталях всех их компонент. Можно задавать только <i>структуру</i> интересующих нас объектов и оставлять конкретные компоненты без точного описания или лишь с частичным описанием. На рис. 4.2 приведено несколько примеров. Так, а запросах к базе данных можно ссылаться на всех Армстронгов с помощью терма<br>   семья( членсемьи( _, армстронг, _, _ ), _, _ )<br>   Символы подчеркивания обозначают различные анонимные переменные, значения которых нас не заботят. Далее можно сослаться на все семьи с тремя детьми при помощи терма:<br>   семья( _, _, [ _, _, _ ])<br>   Чтобы найти всех замужних женщин, имеющих по крайней мере троих детей, можно задать вопрос:<br>    ?-  семья( _, членсемьи( Имя, Фамилия, _, _ ), [ _, _, _ | _ ]).<br>   Главным моментом в этих примерах является то, что указывать интересующие нас объекты можно не только по их содержимому, но и по их структуре. Мы задаем одну структуру и оставляем ее аргументы в виде слотов (пропусков).<br><div align="center"><img border="1" src="_38.png"></div>   <b>Рис. 4.2.</b> Описания объектов по их структурным свойствам: (а) любая семья Армстронгов; (b) любая семья, имеющая ровно трех детей; (с) любая семья, имеющая по крайней мере три ребенка. Структура (с) дает возможность получить имя и фамилию жены конкретизацией переменных Имя и Фамилия.<br>   Можно создать набор процедур, который служил бы утилитой, делающей взаимодействие с нашей базой данных более удобным. Такие процедуры являлись бы частью пользовательского интерфейса. Вот некоторые полезные процедуры для нашей базы данных:<br>   муж( X) :-     % X - муж<br>    семья( X, _, _ ).<br>
		 <br>   жена( X) :-    % X - жена<br>    семья( _, X, _ ).<br>
		 <br>   ребенок( X) :- % X - ребенок<br>    семья( _, _, Дети),<br>    принадлежит( X, Дети).<br>
		 <br>   принадлежит( X, [X | L ]).<br>   принадлежит( X, [Y | L ]) :-<br>    принадлежит( X, L).<br>
		 <br>   существует( Членсемьи) :-<br>    % Любой член семьи в базе данных<br>    муж( Членсемьи);<br>    жена( Членсемьи);<br>    ребенок( Членсемьи).<br>
		 <br>   дата рождения( Членсемьи( _, _, Дата, _ ), Дата).<br>
		 <br>   доход( Членсемьи( _, _, _, работает( _, S) ), S).<br>    % Доход работающего<br>   доход( Членсемьи( _, _, _, неработает), 0).<br>    % Доход неработающего<br>   Этими процедурами можно воспользоваться, например, в следующих запросах к базе данных:<br>   • Найти имена всех людей из базы данных:<br>     ?-  существует( членсемьи( Имя,Фамилия, _, _ )).<br>   • Найти всех детей, родившихся в 1981 году:<br>     ?-  ребенок( X), датарождения( X, дата( _, _, 1981) ).<br>   • Найти всех работающих жен:<br>     ?-  жена( членсемьи( Имя, Фамилия, _, работает( _, _ ))).<br>   • Найти имена и фамилии людей, которые не работают и родились до 1963 года:<br>     ?- существует членсемьи( Имя, Фамилия, дата( _, _, Год), неработает) ),<br>     Год &lt; 1963.<br>   • Найти людей, родившихся до 1950 года, чей доход меньше, чем 8000:<br>     ?- существует( Членсемьи),<br>     датарождения( Членсемьи, дата( _, _, Год) ),<br>     Год &lt; 1950,<br>     доход( Членсемьи, Доход),<br>     Доход &lt; 8000.<br>   • Найти фамилии людей, имеющих по крайней мере трех детей:<br>     ?-  семья( членсемьи( _, Фамилия, _, _ ), _, [ _, _, _ | _ ]).<br>   Для подсчета общего дохода семья полезно определить сумму доходов людей из некоторого списка в виде двухаргументного отношения:<br>   общий( Список_Людей, Сумма_их_доходов)<br>   Это отношение можно запрограммировать так:<br>   общий( [], 0). % Пустой список людей<br>   общий( [ Человек | Список], Сумма) :-<br>    доход( Человек, S),<br>     % S - доход первого человека<br>    общий( Список, Остальные),<br>     % Остальные - сумма доходов остальных<br>    Сумма is S + Остальные.<br>   Теперь общие доходы всех семей могут быть найдены с помощью вопроса:<br>   ?- семья( Муж, Жена, Дети),<br>    общий( [Муж, Жена | Дети], Доход).<br>   Пусть отношение длина подсчитывает количество элементов списка, как это было определено в разд. 3.4. Тогда мы можем найти все семьи, которые имеют доход на члена семьи, меньший, чем 2000, при помощи вопроса:<br>   ?- семья( Муж, Жена, Дети),<br>    общий( [ Муж, Жена | Дети], Доход),<br>    длина( [ Муж, Жена | Дети], N),<br>    Доход/N &lt; 2000.<br><h5>Упражнения</h5>   <b>4.1.</b> Напишите вопросы для поиска в базе данных о семьях.<br>   (а) семей без детей;<br>   (b) всех работающих детей;<br>   (с) семей, где жена работает, а муж нет,<br>   (d) всех детей, разница в возрасте родителей которых составляет не менее 15 лет.<br>   <b>4.2.</b> Определите отношение<br>   близнецы( Ребенок1, Ребенок2)<br>   для поиска всех близнецов в базе данных о семьях.<br></div>
<h3 align="center">
<a name="TOC_id3426822"></a>4.2. Абстракция данных<br></h3>
<div>   <i>Абстракцию данных</i> можно рассматривать как процесс организации различных фрагментов информации в единые логические единицы (возможно, иерархически), придавая ей при этом некоторую концептуально осмысленную форму. Каждая информационная единица должна быть легко доступна в программе. В идеальном случае все детали реализации такой структуры должны быть невидимы пользователю этой структуры. Самое главное в этом процессе - дать программисту возможность использовать информацию, не думая о деталях ее действительного представления.<br>   Обсудим один из способов реализации этого принципа на Прологе. Рассмотрим снова пример с семьей из предыдущего раздела. Каждая семья — это набор некоторых фрагментов информации. Все эти фрагменты объединены в естественные информационные единицы, такие, как "член семьи" или "семья", и с ними можно обращаться как с едиными объектами. Предположим опять, что информация о семье структурирована так же, как на рис. 4.1. Определим теперь некоторые отношения, с помощью которых пользователь может получать доступ к конкретным компонентам семьи, не зная деталей рис. 4.1. Такие отношения можно назвать <i>селекторами</i>, поскольку они позволяют выбирать конкретные компоненты. Имя такого отношения-селектора будет совпадать с именем компоненты, которую нужно выбрать. Отношение будет иметь два аргумента: первый — объект, который содержит компоненту, и второй — саму компоненту:<br>   отношение_селектор(Объект, Выбранная_компонента)<br>   Вот несколько селекторов для структуры семья:<br>   муж( семья( Муж, _, _ ), Муж).<br>   жена( семья( _, Жена, _ ), Жена).<br>   дети( семья( _, _, СписокДетей ), СписокДетей).<br>   Можно также создать селекторы для отдельных детей семьи:<br>   первыйребенок( Семья, Первый) :-<br>    дети( Семья, [Первый | _ ]).<br>
		 <br>   второйребенок( Семья, Второй) :-<br>    дети( Семья, [ _, Второй | _ ]).<br>
		 <br>   ...<br>   Можно обобщить этот селектор для выбора N-го ребенка:<br>   <i>n</i>ребенок( N, Семья, Ребенок) :-<br>    дети( Семья, СписокДетей),<br>    <i>n</i>_элемент( N, СписокДетей, Ребенок)<br>     % N-й элемент списка<br>   Другим интересным объектом является "член семьи". Вот некоторые связанные с ним селекторы, соответствующие рис. 4.1:<br>   имя( членсемьи( Имя, _, _, _ ), Имя).<br>   фамилия( членсемьи( _, Фамилия, _, _ ), Фамилия).<br>   датарождения( членсемьи( _, _, Дата), Дата).<br>   Какие преимущества мы можем получить от использования отношений-селекторов? Определив их, мы можем теперь забыть о конкретном виде структуры представления информации. Для пополнения и обработки этой информации нужно знать только имена отношений-селекторов и в оставшейся части программы пользоваться только ими. В случае, если информация представлена сложной структурой, это легче, чем каждый раз обращаться к ней в явном виде. В частности, в нашем примере с семьей пользователь не обязан знать, что дети представлены в виде списка. Например, предположим, мы хотим сказать, что Том Фокс и Джим Фокс принадлежат к одной семье и что Джим — второй ребенок Тома. Используя приведенные выше отношения-селекторы, мы можем определить двух человек, назовем их Человек1 и Человек2, и семью. Следующий список целей приводит к желаемому результату:<br>   имя( Человек1, том), фамилия( Человек1, фокс),<br>     % Человек1 - Том Фокс<br>    имя( Человек2, джим), фамилия( Человек1, фокс),<br>     % Человек2 - Джим Фокс<br>    муж( Семья, Человек1),<br>    второйребенок( Семья, Человек2)<br>   Использование отношений-селекторов облегчает также и последующую модификацию программ. Представьте себе, что мы захотели повысить эффективность программы, изменив представление информации. Все, что нужно сделать для этого, — изменить определения отношений-селекторов, и вся остальная программа без изменений будет работать с этим новым представлением.<br><h5>Упражнение</h5>   <b>4.3.</b> Завершите определение отношения <i><i>n</i>ребенок</i>, определив отношение<br>   <i>n</i>_элемент( N, Список, X)<br>   которое выполняется, если X является N-м элементом списка Список.<br></div>
<h3 align="center">
<a name="TOC_id3609108"></a>4.3. Моделирование недетерминированного автомата<br></h3>
<div>   Данное упражнение показывает, как абстрактную математическую конструкцию можно представить на Прологе. Кроме того, программа, которая получится, окажется значительно более гибкой, чем предполагалось вначале.<br>   <i>Недетерминированный конечный автомат</i> — это абстрактная машина, которая читает символы из входной цепочки и решает, <i>допустить</i> или <i>отвергнуть</i> эту цепочку. Автомат имеет несколько <i>состояний</i> и всегда находится в одном из них. Он может изменить состояние, перейдя из одного состояния в другое. Внутреннюю структуру такого автомата можно представить графом переходов, как показано на рис. 4.3. В этом примере <i>S<sub>1</sub></i>, <i>S<sub>2</sub></i>, <i>S<sub>3</sub></i> и <i>S<sub>4</sub></i> — <i>состояния</i> автомата. Стартовав из начального состояния (в нашем примере это <i>S<sub>1</sub></i>), автомат переходит из состояния в состояние по мере чтения входной цепочки. Переход зависит от текущего входного символа, как указывают метки на дугах графа переходов.<br><div align="center"><img border="1" src="_39.png"></div>   <b>Рис. 4.3.</b> Пример недетерминированного конечного автомата.<br>   Переход выполняется всякий раз при чтении входного символа. Заметим, что переходы могут быть недетерминированными. На рис. 4.3 видно, что если автомат находится в состоянии <i>S<sub>1</sub></i>, и текущий входной символ равен  <i>а</i>,  то переход может осуществиться как в <i>S<sub>1</sub></i>, так и в <i>S<sub>2</sub></i>. Некоторые дуги помечены меткой пусто, обозначающей "пустой символ". Эти дуги соответствуют "спонтанным переходам" автомата. Такой переход называется <i>спонтанным</i>, потому что он выполняется без чтения входной цепочки. Наблюдатель, рассматривающий автомат как черный ящик, не сможет обнаружить, что произошел какой-либо переход.<br>   Состояние <i>S<sub>3</sub></i> обведено двойной линией, это означает, что <i>S<sub>3</sub></i> — <i>конечное состояние</i>. Про автомат говорят, что он <i>допускает</i> входную цепочку, если в графе переходов существует путь, такой, что:<br>   (1) он начинается в начальном состоянии,<br>   (2) он оканчивается в конечном состоянии, и<br>   (3) метки дуг, образующих этот путь, соответствуют полной входной цепочке.<br>   Решать, какой из возможных переходов делать в каждый момент времени — исключительно внутреннее дело автомата. В частности, автомат сам решает, делать ли спонтанный переход, если он возможен в текущем состоянии. Однако абстрактные недетерминированные машины такого типа обладают волшебным свойством: если существует выбор, они всегда избирают "правильный" переход, т.е. переход, ведущий к допущению входной цепочки при наличии такого перехода. Автомат на рис. 4.3, например, допускает цепочки <i>аb </i>и <i>aabaab</i>, но отвергает цепочки <i>abb</i> и <i>abba</i>. Легко видеть, что этот автомат допускает любые цепочки, оканчивающиеся на <i>аb</i> и отвергает все остальные.<br><div align="center"><img border="1" src="_40.png"></div>   <b>Рис. 4.4.</b> Допущение цепочки: (a) при чтении первого символа X; (b) при совершении спонтанного перехода.<br>   Некоторый автомат можно описать на Прологе при помощи трех отношений:<br>   (1) Унарного отношения конечное, которое определяет конечное состояние автомата.<br>   (2) Трехаргументного отношения переход, которое определяет переход из состояния в состояние, при этом<br>   переход( S1, X, S2)<br>   означает переход из состояния S1 в S2, если считан входной символ X.<br>   (3) Бинарного отношения<br>   спонтанный( S1, S2)<br>   означающего, что возможен спонтанный переход из S1 в S2.<br>   Для автомата, изображенного на рис. 4.3, эти отношения будут такими:<br>   конечное( S3).<br>
		 <br>   переход( S1, а, S1).<br>   переход( S1, а, S2).<br>   переход( S1, b, S1).<br>   переход( S2, b, S3).<br>   переход( S3, b, S4).<br>
		 <br>   спонтанный( S2, S4).<br>   спонтанный( S3, S1).<br>   Представим входные цепочки в виде списков Пролога. Цепочка <i>ааb</i> будет представлена как [а, а, b]. Модель автомата, получив его описание, будет обрабатывать заданную входную цепочку, и решать, допускать ее или нет. По определению, недетерминированный автомат допускает заданную цепочку, если (начав из начального состояния) после ее прочтения он способен оказаться в конечном состоянии. Модель программируется в виде бинарного отношения допускается, которое определяет принятие цепочки из данного состояния. Так<br>   допускается( Состояние, Цепочка)<br>   истинно, если автомат, начав из состояния Состояние как из начального, допускает цепочку Цепочка. Отношение допускается можно определить при помощи трех предложений. Они соответствуют следующим трем случаям:<br>   (1) Пустая цепочка [] допускается из состояния S, если S — конечное состояние.<br>   (2) Непустая цепочка допускается из состояния S, если после чтения первого ее символа автомат может перейти в состояние S1, и оставшаяся часть цепочки допускается из S1. Этот случай иллюстрируется на рис. 4.4(а).<br>   (3) Цепочка допускается из состояния S, если автомат может сделать спонтанный переход из S в S1, а затем допустить (всю) входную цепочку из S1. Такой случай иллюстрируется на рис. 4.4(b).<br>   Эти правила можно перевести на Пролог следующим образом:<br>   допускается( S, []) :-<br>     % Допуск пустой цепочки<br>    конечное( S).<br>
		 <br>   допускается( S, [X | Остальные]) :-<br>     % Допуск чтением первого символа<br>    переход( S, X, S1),<br>    допускается( S1, Остальные).<br>
		 <br>   допускается( S, Цепочка) :-<br>     % Допуск выполнением спонтанного перехода<br>    спонтанный( S, S1),<br>    допускается( S1, Цепочка).<br>   Спросить о том, допускается ли цепочка <i>аааb</i>, можно так:<br>   ?- допускается( S1, [a, a, a, b]).<br>   yes            (да)<br>   Как мы уже видели, программы на Прологе часто оказываются способными решать более общие задачи, чем те, для которых они первоначально предназначались. В нашем случае мы можем спросить модель также о том, в каком состоянии должен находиться автомат в начале работы, чтобы он допустил цепочку <i>аb</i>:<br>   ?- допускается( S, [a, b]).<br>
		 <br>   S = s1;<br>   S = s3<br>   Как ни странно, мы можем спросить также "Каковы все цепочки длины 3, допустимые из состояния s1?"<br>   ?- допускается( s1, [X1, Х2, X3]).<br>
		 <br>   X1 = а<br>   X2 = а<br>   X3 = b;<br>
		 <br>   X1 = b<br>   X2 = а<br>   X3 = b;<br>
		 <br>   nо     (нет)<br>   Если мы предпочитаем, чтобы допустимые цепочки выдавались в виде списков, тогда наш вопрос следует сформулировать так:<br>   ?- Цепочка = [ _, _, _ ], допускается( s1, Цепочка).<br>
		 <br>   Цепочка = [а, а, b];<br>   Цепочка = [b, а, b];<br>   nо     (нет)<br>   Можно проделать и еще некоторые эксперименты, например спросить: "Из какого состояния автомат допустит цепочку длиной 7?"<br>   Эксперименты могут включать в себя переделки структуры автомата, вносящие изменения в отношения конечное, переход и спонтанный. В автомате, изображенном на рис. 4.3, отсутствуют циклические "спонтанные пути" (пути, состоящие только из спонтанных переходов). Если на рис. 4.3 добавить новый переход<br>   спонтанный( s1, s3)<br>   то получится "спонтанный цикл". Теперь наша модель может столкнуться с неприятностями. Например, вопрос<br>   ?- допускается( s1, [а]).<br>   приведет к тому, что модель будет бесконечно переходить в состояние s1, все время надеясь отыскать какой-либо путь в конечное состояние.<br><h5>Упражнения</h5>   <b>4.4.</b> Почему не могло возникнуть зацикливание модели исходного автомата на рис. 4.3, когда в его графе переходов не было "спонтанного цикла"?<br>   <b>4.5.</b> Зацикливание при вычислении допускается можно предотвратить, например, таким способом: подсчитывать число переходов, сделанных к настоящему моменту. При этом модель должна будет искать пути только некоторой ограниченной длины. Модифицируйте так отношение допускается. Указание: добавьте третий аргумент — максимально допустимое число переходов:<br>   допускается( Состояние, Цепочка, Макс_переходов)<br></div>
<h3 align="center">
<a name="TOC_id3419186"></a>4.4. Планирование поездки<br></h3>
<div>   В данном разделе мы создадим программу, которая дает советы по планированию воздушного путешествия. Эта программа будет довольно примитивным советчиком, тем не менее она сможет отвечать на некоторые полезные вопросы, такие как:<br>   • По каким дням недели есть прямые рейсы из Лондона в Любляну?<br>   • Как в четверг можно добраться из Любляны в Эдинбург?<br>   • Мне нужно посетить Милан, Любляну и Цюрих; вылетать нужно из Лондона во вторник и вернуться обратно в Лондон в пятницу. В какой последовательности мне следует посещать эти города, чтобы ни разу на протяжении поездки не пришлось совершать более одного перелета в день.<br>   Центральной частью программы будет база данных, содержащая информацию о рейсах. Эта информация будет представлена в виде трехаргументного отношения:<br>   расписание( Пункт1, Пункт2, Список_рейсов)<br>   где Список_рейсов — это список, состоящий из структурированных объектов вида:<br>   Время_отправления / Время_прибытия / Номер_рейса<br>    / Список_дней_вылета<br>   Список_дней_вылета — это либо список дней недели, либо атом "ежедневно". Одно из предложений, входящих в расписание могло бы быть, например, таким:<br>   расписание( лондон, эдинбург,<br>    [ 9:40 / 10:50 / bа4733/ ежедневно,<br>      19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, сб]] ).<br>   Время представлено в виде структурированных объектов, состоящих из двух компонент — часов и минут, объединенных оператором ":".<br>   Главная задача состоит в отыскании точных маршрутов между двумя заданными городами в определенные дни недели. Ее решение мы будем программировать в виде четырехаргументного отношения:<br>   маршрут( Пункт1, Пункт2, День, Маршрут)<br>   Здесь Маршрут — это последовательность перелетов, удовлетворяющих следующим критериям:<br>   (1) начальная точка маршрута находится в Пункт1;<br>   (2) конечная точка — в Пункт2;<br>   (3) все перелеты совершаются в один и тот же день недели — День;<br>   (4) все перелеты, входящие в Маршрут, содержатся в определении отношения расписание;<br>   (5) остается достаточно времени для пересадки с рейса на рейс.<br>   Маршрут представляется в виде списка структурированных объектов вида<br>   Откуда - Куда : Номер_рейса : Время_отправления<br>   Мы еще будем пользоваться следующими вспомогательными предикатами:<br>   (1) рейс( Пункт1, Пункт2, День, N_рейса, Вр_отпр, Вр_приб)<br>   Здесь сказано, что существует рейс N_рейса между Пункт1 и Пункт2 в день недели День с указанными временами отправления и прибытия.<br>   (2) вр_отпр( Маршрут, Время)<br>   Время — это время отправления по маршруту Маршрут.<br>   (3) пересадка( Время1, Время2)<br>   Между Время1 и Время2 должен существовать промежуток не менее 40 минут для пересадки с одного рейса на другой.<br>   Задача нахождения маршрута напоминает моделирование недетерминированного автомата из предыдущего раздела:<br>   • Состояния автомата соответствуют городам.<br>   • Переход из состояния в состояние соответствует перелету из одного города в другой.<br>   • Отношение переход автомата соответствует отношению расписание.<br>   • Модель автомата находит путь в графе переходов между исходным и конечным состояниями; планировщик поездки находит маршрут между начальным н конечным пунктами поездки.<br>   Неудивительно поэтому, что отношение маршрут можно определить аналогично отношению допускает, с той разницей, что теперь нет "спонтанных переходов". Существуют два случая:<br>   (1) Прямой рейс: если существует прямой рейс между пунктами Пункт1 и Пункт2, то весь маршрут состоит только из одного перелета:<br>   маршрут( Пункт1, Пункт2, День, [Пункт1-Пункт2 : Nр : Отпр]) :-<br>    рейс( Пункт1, Пункт2, День, Np, Отпр, Приб).<br>   (2) Маршрут с пересадками: маршрут между пунктами P1 и Р2 состоит из первого перелета из P1 в некоторый промежуточный пункт Р3 и маршрута между Р3 и Р2. Кроме того, между окончанием первого перелета и отправлением во второй необходимо оставить достаточно времени для пересадки.<br>   маршрут( P1, Р2, День, [P1-Р3 : Nр1 : Отпр1 | Маршрут]) :-<br>    маршрут( Р3, Р2, День, Маршрут ),<br>    рейс( P1, Р3, День, Npl, Oтпpl, Приб1),<br>    вр_отпр( Маршрут, Отпр2),<br>    пересадка( Приб1, Отпр2).<br>   Вспомогательные отношения рейс, пересадка и вр_отпр запрограммировать легко; мы включили их в полный текст программы планировщика поездки на рис. 4.5. Там же приводится и пример базы данных расписания.<br>   Наш планировщик исключительно прост и может рассматривать пути, очевидно ведущие в никуда. Тем не менее его оказывается вполне достаточно, если база данных о рейсах самолетов невелика. Для больших баз данных потребовалось бы разработать более интеллектуальный планировщик, который мог бы справиться с большим количеством путей, участвующих в перебора при нахождении нужного пути.<br>   % ПЛАНИРОВЩИК ВОЗДУШНЫХ МАРШРУТОВ<br>
		 <br>   :- op( 50, xfy, :).<br>
		 <br>   рейс( Пункт1, Пункт2, День, Np, ВрОтпр, ВрПриб) :-<br>    расписание( Пункт1, Пункт2, СписРейсов),<br>    принадлежит( ВрОтпр / ВрПриб / Nр / СписДней, СписРейсов),<br>    день_выл( День, СписДней).<br>
		 <br>   принадлежит( X, [X | L] ).<br>   принадлежит( X, [Y | L] ) :-<br>    принадлежит( X, L ).<br>
		 <br>   день_выл( День, СписДней) :-<br>    принадлежит( День, СписДней).<br>   день_выл( День, ежедневно) :-<br>    принадлежит( День, [пн, вт, ср, чт, пт, сб, вс] ).<br>
		 <br>   маршрут( P1, P2, День, [P1-Р2 : Np : ВрОтпр] ) :-<br>     % прямой рейс<br>    рейс( P1, P2, День, Np, ВрОтпр, _ ).<br>   маршрут( P1, Р2, День, [Pl-P3 : Np1 : Oтпp1 | Маршрут]) :-<br>     % маршрут с пересадками<br>    маршрут( Р3, P2, День, Маршрут ),<br>    рейс( P1, Р3, День, Npl, Oтпp1, Приб1),<br>    вр_отпр( Маршрут, Отпр2),<br>    пересадка( Приб1, Отпр2).<br>
		 <br>   вр_отпр( [P1-Р2 : Np : Отпр | _ ], Отпр).<br>
		 <br>   пересадка( Часы1 : Минуты1, Часы2 : Минуты2) :-<br>    60 * (Часы2-Часы1) + Минуты2 - Минуты1 &gt;= 40<br>
		 <br>   % БАЗА ДАННЫХ О РЕЙСАХ САМОЛЕТОВ<br>
		 <br>   расписание( эдинбург, лондон,<br>    [ 9:40 / 10:50 / bа4733 / ежедневно,<br>      13:40 / 14:50 / ba4773 / ежедневно,<br>      19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, вс] ] ).<br>
		 <br>   расписание( лондон, эдинбург,<br>    [ 9:40 / 10:50 / bа4732 / ежедневно,<br>      11:40 / 12:50 / bа4752 / ежедневно,<br>      18:40 / 19:50 / bа4822 / [пн, вт, ср, чт, пт] ] ),<br>
		 <br>   расписание( лондон, любляна,<br>    [13:20 / 16:20 / ju201 / [пт],<br>     13:20 / 16:20 / ju213 / [вс] ] ).<br>
		 <br>   расписание( лондон, цюрих,<br>    [ 9:10 / 11:45 / bа614 / ежедневно,<br>      14:45 / 17:20 / sr805 / ежедневно ] ).<br>
		 <br>   расписание( лондон, милан,<br>    [ 8:30 / 11:20 / bа510 / ежедневно,<br>      11:00 / 13:50 / az459 / ежедневно ] ).<br>
		 <br>   расписание( любляна, цюрих,<br>    [11:30 / 12:40 / ju322 / [вт,чт] ] ).<br>
		 <br>   расписание( любляна, лондон,<br>    [11:10 / 12:20 / yu200 / [пт],<br>     11:25 / 12:20 / yu212 / [вс] ] ).<br>
		 <br>   расписание( милан, лондон,<br>    [ 9:10 / 10:00 / az458 / ежедневно,<br>      12:20 / 13:10 / bа511 / ежедневно ] ).<br>
		 <br>   расписание( милан, цюрих,<br>    [ 9:25 / 10:15 / sr621 / ежедневно,<br>      12:45 / 13:35 / sr623 / ежедневно ] ).<br>
		 <br>   расписание( цюрих, любляна,<br>    [13:30 / 14:40 / yu323 / [вт, чт] ] ).<br>
		 <br>   расписание( цюрих, лондон,<br>    9:00 / 9:40 / bа613 /<br>    [ пн, вт, ср, чт, пт, сб],<br>      16:10 / 16:55 / sr806 / [пн, вт, ср, чт, пт, сб] ] ).<br>
		 <br>   расписание( цюрих, милан,<br>    [ 7:55 / 8:45 / sr620 / ежедневно ] ).<br>   <b>Рис. 4.5.</b>  Планировщик воздушных маршрутов и база данных о рейсах самолетов.<br>
		 <br>   Вот некоторые примеры вопросов к планировщику:<br>   • По каким дням недели существуют прямые рейсы из Лондона в Люблину?<br>   ?- рейс( лондон, любляна, День, _, _, _ ).<br>
		 <br>   День = пт;<br>   День = сб;<br>
		 <br>   no        (нет)<br>   • Как мне добраться из Любляны в Эдинбург в четверг?<br>   ?- маршрут( любляна, эдинбург, чт, R).<br>
		 <br>   R = [любляна-цюрих : уu322 : 11:30, цюрих-лондон:<br>        sr806 : 16:10,<br>        лондон-эдинбург : bа4822 : 18:40 ]<br>   • Как мне посетить Милан, Любляну и Цюрих, вылетев из Лондона во вторник и вернувшись в него в пятницу, совершая в день не более одного перелета? Этот вопрос сложнее, чем предыдущие. Его можно сформулировать, использовав отношение перестановка, запрограммированное в гл. 3. Мы попросим найти такую перестановку городов Милан, Любляна и Цюрих, чтобы соответствующие перелеты можно было осуществить в несколько последовательных дней недели:<br>   ?- перестановка( [милан, любляна, цюрих],<br>    [Город1, Город2, Город3] ),<br>    рейс( лондон, Город1, вт, Np1, Oтпp1, Пpиб1),<br>    peйc( Город1, Город2, ср, Np2, Отпр2, Приб2),<br>    рейс( Город2, Город3, чт, Np3, Отпp3, Приб3),<br>    рейс( Город3, лондон, пт, Np4, Отпр4, Приб4).<br>
		 <br>   Город1 = милан<br>   Город2 = цюрих<br>   Город3 = любляна<br>
		 <br>   Np1 = ba510<br>   Отпр1 = 8:30<br>   Приб1 = 11:20<br>
		 <br>   Np2 =sr621<br>   Отпр2 = 9:25<br>   Приб2 = 10:15<br>
		 <br>   Np3 = yu323<br>   Отпр3 = 13:30<br>   Приб3 = 14:40<br>
		 <br>   Np4 = yu200<br>   Отпр4 = 11:10<br>   Приб4 = 12:20<br></div>
<h3 align="center">
<a name="TOC_id3382322"></a>4.5. Задача о восьми ферзях<br></h3>
<div>
<div>   Эта задача состоит в отыскании такой расстановки восьми ферзей на пустой шахматной доске, в которой ни один из ферзей не находится под боем другого. Решение мы запрограммируем в виде унарного отношения:<br>   решение( Поз)<br>   которое истинно тогда и только тогда, когда Поз изображает позицию, в которой восемь ферзей не бьют друг друга. Будет интересно сравнить различные идеи, лежащие в основе программирования этой задачи. Поэтому мы приведем три программы, основанные на слегка различающихся ее представлениях.<br></div>
<h4 align="center">
<a name="TOC_id3494272"></a>4.5.1. Программа 1<br></h4>
<div>   Вначале нужно выбрать способ представления позиции на доске. Один из наиболее естественных способов — представить позицию в виде списка из восьми элементов, каждый из которых соответствует одному из ферзей. Каждый такой элемент будет описывать то поле доски, на которой стоит соответствующий ферзь. Далее, каждое поле доски можно описать с помощью пары координат (X и Y), где каждая координата - целое число от 1 до 8. В программе мы будем записывать такую пару в виде<br>   X / Y<br>   где оператор "/" обозначает, конечно, не деление, а служит лишь для объединения координат поля в один элемент списка. На рис. 4.6 показано одно из решений задачи о восьми ферзях и его запись в виде списка.<br>   После того, как мы выбрали такое представление, задача свелась к нахождению списка вида:<br>   [X1/Y1, X2/Y2, X3/Y3, X4/Y4, X5/Y5, X6/Y6, X7/Y7, X8/Y8]<br>   удовлетворяющего требованию отсутствия нападений. Наша процедура решение должна будет найти подходящую конкретизацию переменных X1, Y1, Х2, Y2, <b>…</b>, Х8, Y8. Поскольку мы знаем, что все ферзи должны находиться на разных вертикалях во избежание нападений по вертикальным линиям, мы можем сразу же ограничить перебор, чтобы облегчать поиск решения. Можно поэтому сразу зафиксировать X-координаты так, чтобы список, изображающий решение, удовлетворял следующему, более конкретному шаблону:<br>   [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]<br><div align="center"><img border="1" src="_41.png"></div>   <b>Рис. 4.6.</b> Решение задачи о восьми ферзях. Эта позиция может быть представлена в виде списка [1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1].<br>   Нас интересует решение для доске размером 8&#215;8. Однако, как это часто бывает в программировании, ключ к решению легче найти, рассмотрев более общую постановку задачи. Как это ни парадоксально, но часто оказывается, что решение более общей задачи легче сформулировать, чем решение более частной, исходной задачи; после этого исходная задача решается просто как частный случай общей задачи.<br>   Основная часть работы при таком подходе ложится на нахождение правильного обобщения исходной задачи. В нашем случае хорошей является идея обобщать задачу в отношении количества ферзей (количества вертикалей в списке), разрешив количеству ферзей принимать любое значение, включая нуль. Тогда отношение решение можно сформулировать, рассмотрев два случая:<br>   <i>Случай 1</i>. Список ферзей пуст. Пустой список без сомнения является решением, поскольку нападений в этом случае нет.<br>   <i>Случай 2</i>. Список ферзей не пуст. Тогда он выглядит так:<br>   [ X/Y | Остальные ]<br>   В случае 2 первый ферзь находится на поле X / Y, а остальные — на полях, указанных в списке Остальные. Если мы хотим, чтобы это было решением, то должны выполняться следующие условия:<br>   (1) Ферзи, перечисленные в списке Остальные, не должны бить друг друга; т.е. список Остальные сам должен быть решением.<br>   (2) X и Y должны быть целыми числами от 1 до 8.<br>   (3) Ферзь, стоящий на поле X / Y, не должен бить ни одного ферзя из списка Остальные.<br>   Чтобы запрограммировать первое условие, можно воспользоваться самим отношением решение. Второе условие можно сформулировать так: Y должен принадлежать списку целых чисел от 1 до 8. т.е. [1, 2, 3, 4, 5, 6, 7, 8]. С другой стороны, о координате X можно не беспокоиться, поскольку список-решение должен соответствовать шаблону, у которого X-координаты уже определены. Поэтому X гарантированно получит правильное значение от 1 до 8. Третье условие можно обеспечить с помощью нового отношения небьет. Все это можно записать на Прологе так:<br>   решение( [X/Y | Остальные] ) :-<br>    решение( Остальные),<br>    принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),<br>    небьет( X/Y, Остальные).<br>   Осталось определить отношение небьет:<br>   небьет( Ф, Фспис)<br>   И снова его описание можно разбить на два случая:<br>   (1) Если список Фспис пуст, то отношение, конечно, выполнено, потому что некого бить (нет ферзя, на которого можно было бы напасть).<br>   (2) Если Фспис не пуст, то он имеет форму<br>   [Ф1 | Фспис1]<br>   и должны выполняться два условия:<br>    (а) ферзь на поле Ф не должен бить ферзя на поле Ф1 и<br>    (b) ферзь на поле Ф не должен бить ни одного ферзя из списка Фспис1.<br>   Выразить требование, чтобы ферзь, находящийся на некотором поле, не бил другое поле, довольно просто: эти поля не должны находиться на одной и той же горизонтали, вертикали или диагонали: Наш шаблон решения гарантирует, что все ферзи находятся на разных вертикалях, поэтому остается только обеспечить, чтобы<br>   • Y-координаты ферзей были различны и<br>   • ферзи не находились на одной диагонали, т.е. расстояние между полями по направлению X не должно равняться расстоянию между ними по Y.<br>   На рис. 4.7 приведен полный текст программы. Чтобы облегчить ее использование, необходимо добавить список-шаблон. Это можно сделать в запросе на генерацию решений. Итак:<br>   ?-  шаблон( S), решение( S).<br>
		 <br>   решение( [] ).<br>   решение( [X/Y | Остальные ] ) :-<br>     % Первый ферзь на поле X/Y,<br>     % остальные ферзи на полях из списка Остальные<br>    решение( Остальные),<br>    принадлежит Y, [1, 2, 3, 4, 5, 6, 7, 8] ),<br>    небьет( X/Y | Остальные).<br>     % Первый ферзь не бьет остальных<br>
		 <br>   небьет( _, [ ]). % Некого бить<br>   небьет( X/Y, [X1/Y1 | Остальные] ) :-<br>    Y =\= Y1,       % Разные Y-координаты<br>    Y1-Y =\= X1-X   % Разные диагонали<br>    Y1-Y =\= X-X1,<br>    небьет( X/Y, Остальные).<br>
		 <br>   принадлежит( X, [X | L] ).<br>   принадлежит( X, [Y | L] ) :-<br>    принадлежит( X, L).<br>
		 <br>   % Шаблон решения<br>   шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).<br>   <b>Рис. 4.7.</b>  Программа 1 для задачи о восьми ферзях.<br>
		 <br>   Система будет генерировать решения в таком виде:<br>   S = [1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1];<br>   S = [1/5, 2/2, 3/4, 4/7, 5/3, 6/8, 7/6, 8/1];<br>   S = [1/3, 2/5, 3/2, 4/8, 5/6, 6/4, 7/7, 8/1].<br>   ...<br><h5>Упражнение</h5>   <b>4.6.</b> При поиске решения программа, приведенная на рис. 4.7, проверяет различные значения Y-координат ферзей. В каком месте программы задается порядок перебора альтернативных вариантов? Как можно без труда модифицировать программу, чтобы этот порядок изменился? Поэкспериментируйте с разными порядками, имея в виду выяснить, как порядок перебора альтернатив влияет на эффективность программы.<br></div>
<h4 align="center">
<a name="TOC_id3578339"></a>4.5.2. Программа 2<br></h4>
<div>   В соответствии с принятым в программе 1 представлением доски каждое решение имело вид<br>   [1/Y1, 2/Y2, 3/Y3, ..., 8/Y8]<br>   так как ферзи расставлялись попросту в последовательных вертикалях. Никакая информация не была бы потеряна, если бы X-координаты были пропущены. Поэтому можно применить более экономное представление позиции на доске, оставив в нем только Y-координаты ферзей:<br>   [Y1, Y2, Y3, ..., Y8]<br>   Чтобы не было нападений по горизонтали, никакие два ферзя не должны занимать одну и ту же горизонталь. Это требование накладывает ограничение на Y-координаты: ферзи должны занимать все горизонтали с 1-й по 8-ю. Остается только выбрать <i>порядок</i> следования этих восьми номеров. Каждое решение представляет собой поэтому одну из перестановок списка:<br>   [1, 2, 3, 4, 5, 6, 7, 8]<br>   Такая перестановка S является решением, если каждый ферзь в ней не находится под боем (список S — "безопасный"). Поэтому мы можем написать:<br>   решение( S) :-<br>    перестановка( [1, 2, 3, 4, 5, 6, 7, 8], S),<br>    безопасный( S).<br><div align="center"><img border="1" src="_42.png"></div>   <b>Рис. 4.8.</b> (а) Расстояние по X между Ферзь и Остальные равно 1. (b) Расстояние по X между Ферзь и Остальные равно 3<br>   Отношение перестановка мы уже определила в гл. 3, а вот отношение безопасный нужно еще определить. Это определение можно разбить на два случая:<br>   (1) S — пустой список. Тогда он, конечно, безопасный, ведь нападать не на кого.<br>   (2) S — непустой список вида [Ферзь | Остальные]. Он безопасный, если список Остальные — безопасный и Ферзь не бьет ни одного ферзя из списка Остальные.<br>   На Прологе это выглядит так:<br>   безопасный( []).<br>   безопасный( [Ферзь | Остальные ] :-<br>    безопасный( Остальные),<br>    небьет(Ферзь | Остальные).<br>   В этой программе отношение небьет более хитрое.<br>
		 <br>   решение( Ферзи) :-<br>    перестановка( [1, 2, 3, 4, 5, 6, 7, 8], Ферзи),<br>    безопасный( Ферзи).<br>
		 <br>   перестановка( [], []).<br>   перестановка( [Голова | Хвост], СписПер) :-<br>    перестановка( Хвост, ХвостПер),<br>    удалить( Голова, СписПер, ХвостПер).<br>     % Вставка головы в переставленный хвост<br>
		 <br>   удалить( А, [А | Список).<br>   удалять( А, [В | Список], [В, Список1] ) :-<br>    удалить( А, Список, Список1).<br>
		 <br>   безопасный( []).<br>   безопасный( [Ферзь | Остальные]) :-<br>    безопасный( Остальные),<br>    небьет( Ферзь, Остальные, 1).<br>
		 <br>   небьет( _, [], _ ).<br>   небьет( Y, [Y1 | СписY], РасстХ) :-<br>    Y1-Y =\= РасстХ,<br>    Y-Y1 =\= РасстХ,<br>    Расст1 is РасстХ + 1,<br>    небьет( Y, СписY, Расст1).<br>   <b>Рис. 4.9.</b> Программа 2 для задачи о восьми ферзях.<br>
		 <br>   Трудность состоит в том, что расположение ферзей определяется только их Y-координатами, а X-координаты в представлении позиции не присутствуют в явном виде. Этой трудности можно избежать путем небольшого обобщения отношения небьет, как это показано на рис. 4.8. Предполагается, что цель<br>   небьет( Ферзь, Остальные)<br>   обеспечивает отсутствие нападении ферзя Ферзь на поля списка Остальные в случае, когда расстояние по X между Ферзь и Остальные равно 1. Остается рассмотреть более общий случай произвольного расстояния. Для этого мы добавим его в отношение небьет в качестве третьего аргумента:<br>   небьет( Ферзь, Остальные, РасстХ)<br>   Соответственно и цель небьет в отношении безопасный должна быть изменена на<br>   небьет( Ферзь, Остальные, 1)<br>   Теперь отношение небьет может быть сформулировано в соответствии с двумя случаями, в зависимости от списка Остальные: если он пуст, то бить некого и, естественно, нет нападений; если же он не пуст, то Ферзь не должен бить первого ферзя из списка Остальные (который находится от ферзя Ферзь на расстоянии РасстХ вертикалей), а также ферзей из хвоста списка Остальные, находящихся от него на расстоянии РасстХ + 1. Эти соображения приводят к программе, изображенной на рис. 4.9.<br></div>
<h4 align="center">
<a name="TOC_id3839524"></a>4.5.3. Программа 3<br></h4>
<div>   Наша третья программа для задачи о восьми ферзях опирается на следующие соображения. Каждый ферзь должен быть размещен на некотором поле, т.е. на некоторой вертикали, некоторой горизонтали, а также на пересечении каких-нибудь двух диагоналей. Для того, чтобы была обеспечена безопасность каждого ферзя, все они должны располагаться в разных вертикалях, разных горизонталях и в разных диагоналях (как идущих сверху вниз, так и идущих снизу вверх). Естественно поэтому рассмотреть более богатую систему представления с четырьмя координатами:<br>    <i>x</i> вертикали<br>    <i>у</i> горизонтали<br>    <i>u</i> диагонали, идущие снизу вверх<br>    <i>v</i> диагонали, идущие сверху вниз<br>   Эти координаты не являются независимыми: при заданных <i>x</i> и <i>у</i>, <i>u</i> и <i>v</i> определяются однозначно (пример на рис. 4.10). Например,<br>   <i>u = x - у</i><br>   <i>v = x + у</i><br><div align="center"><img border="1" src="_43.png"></div>   <b>Рис. 4.10.</b> Связь между вертикалями, горизонталями и диагоналями. Помеченное поле имеет следующие координаты: <i>x</i> = 2,  <i>у</i> = 4, <i>u</i> = 2 - 4 = -2, <i>v</i> = 2 + 4 = 6.<br>   Области изменения всех четырех координат таковы:<br>   Dx = [1, 2, 3, 4, 5, 6, 7, 8]<br>   Dy = [1, 2, 3, 4, 5, 6, 7, 8]<br>
		 <br>   Du = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]<br>   Dv = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]<br>   Задачу о восьми ферзях теперь можно сформулировать следующим образом: выбрать восемь четверок (X, Y, U, V), входящих в области изменения (X в Dx, Y в Dy и т.д.), так, чтобы ни один их элемент не выбирался дважды из одной области. Разумеется, выбор X и Y определяет выбор U и V. Решение при такой постановке задачи может быть вкратце таким: при заданных 4-x областях изменения выбрать позицию для первого ферзя, вычеркнуть соответствующие элементы из 4-x областей изменения, а затем использовать оставшиеся элементы этих областей для размещения остальных ферзей. Программа, основанная на таком подходе, показана на рис. 4.11. Позиция на доске снова представляется списком Y-координат. Ключевым отношением в этой программе является отношение<br>   peш( СписY, Dx, Dy, Du, Dv)<br>   которое конкретизирует Y-координаты (в СписY) ферзей, считая, что они размещены в последовательных вертикалях, взятых из Dx. Все Y-координаты и соответствующие координаты U и V берутся из списков Dy, Du и Dv. Главную процедуру решение можно запустить вопросом<br>   ?-  решение( S)<br>   Это вызовет запуск реш с полными областями изменения координат, что соответствует пространству задачи о восьми ферзях.<br>
		 <br>   решение( СписY) :-<br>    реш( СписY, % Y-координаты ферзей<br>    [1, 2, 3, 4, 5, 6, 7, 8],<br>     % Область изменения Y-координат<br>    [1, 2, 3, 4, 5, 6, 7, 8],<br>     % Область изменения X-координат<br>    [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7],<br>     % Диагонали, идущие снизу вверх<br>    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 14, 15, 16] ).<br>     % Диагонали, идущие сверху вниз<br>
		 <br>   реш([], [], Dy, Du, Dv).<br>   реш( [Y | СписY], [X | Dx1], Dy, Du, Dv) :-<br>    удалить( Y, Dy, Dy1), % Выбор Y-координаты<br>    U is X-Y,             % Соответствующая диагональ вверх<br>    удалить( U, Du, Du1), % Ее удаление<br>    V is X+Y,             % Соответствующая диагональ вниз<br>    удалить( V, Dv, Dv1), % Ее удаление<br>    реш( СписY, Dх1, Dy1, Du1, Dv1).<br>     % Выбор из оставшихся значений<br>
		 <br>   удалить( А, [А | Список], Список).<br>   удалить(A, [В | Список ], [В | Список1 ] ) :-<br>    удалить( А, Список, Список1).<br>   <b>Рис. 4.11.</b> Программа 3 для задачи о восьми ферзях.<br>
		 <br>   Процедура реш универсальна в том смысле, что ее можно использовать для решения задачи об N ферзях (на доске размером N&#215;N). Нужно только правильно задеть области Dx, Dy и т.д.<br>   Удобно автоматизировать получение этих областей. Для этого нам потребуется процедура<br>   генератор( N1, N2, Список)<br>   которая для двух заданных целых чисел N1 и N2 порождает список<br>   Список = [N1, N1 + 1, N1 + 2, ..., N2 - 1, N2]<br>   Вот она:<br>   генератор( N, N, [N]).<br>   генератор( Nl, N2, [Nl | Список]) :-<br>    N1 &lt; N2,<br>    М is N1 + 1,<br>    генератор( М, N2, Список).<br>   Главную процедуру решение нужно соответствующим образом обобщить:<br>   решение( N, S)<br>   где N — это размер доски, а S — решение, представляемое в виде списка Y-координат N ферзей. Вот обобщенное отношение решение:<br>   решение( N, S) :-<br>    генератор( 1, N, Dxy),<br>    Nu1 is 1 - N, Nu2 is N - 1,<br>    генератор( Nu1, Nu2, Du),<br>    Nv2 is N + N,<br>    генератор( 2, Nv2, Dv),<br>    реш( S, Dxy, Dxy, Du, Dv).<br>   Например, решение задачи о 12 ферзях будет получено с помощью:<br>   ?-  решение( 12, S).<br>
		 <br>   S = [1, 3, 5, 8, 10, 12, 6, 11, 2, 7, 9, 4]<br></div>
<h4 align="center">
<a name="TOC_id3583811"></a>4.5.4. Заключительные замечания<br></h4>
<div>   Три решения задачи о восьми ферзях показывают, как к одной и той же задаче можно применять различные подходы. Мы варьировали также и представление данных. В одних случаях это представление было более экономным, в других — более наглядным и, до некоторой степени, избыточным. К недостаткам более экономного представления можно отнести то, что какая-то информация всякий раз, когда она требовалась, должна была перевычисляться.<br>   В некоторых случаях основным шагом к решению было обобщение задачи. Как ни парадоксально, но при рассмотрении более общей задачи решение оказывалось проще сформулировать. Принцип такого обобщения — стандартный прием программирования, и его можно часто применять.<br>   Из всех трех программ третья лучше всего показывает, как подходить к общей задаче построения структуры из заданного множества элементов при наличии ограничений.<br>   Возникает естественный вопрос: " Какая из трех программ наиболее эффективна?" В этом отношение программа 2 значительно хуже двух других, а эти последние — одинаковы. Причина в том, что основанная на перестановках программа 2 строит все перестановки, тогда как две другие программы способны отбросить плохую перестановку не дожидаясь, пока она будет полностью построена. Программа 3 наиболее эффективна. Она избегает некоторых арифметических вычислений, результаты которых уже сразу заложены в избыточное представление доски, используемое этой программой.<br><h5>Упражнение</h5>   <b>4.7.</b> Пусть поля доски представлены парами своих координат в виде X/Y, где как X, так и Y принимают значения от 1 до 8.<br>   (а) Определите отношение ходконя( Поле1, Поле2), соответствующее ходу коня на шахматной доске. Считайте, что Поле1 имеет всегда конкретизированные координаты, в то время, как координаты поля Поле2 могут и не быть конкретизированы. Например:<br>   ?- ходконя( 1/1, S).<br>
		 <br>   S = 3/2;<br>   S = 2/3;<br>
		 <br>   no      (нет)<br>   (b) Определите отношение путьконя( Путь), где Путь — список полей, представляющих соответствующую правилам игры последовательность ходов коня по пустой доске.<br>   (с) Используя отношение путьконя, напишите вопрос для нахождения любого пути, состоящего из 4-x ходов, и начинающегося с поля 2/1, а заканчивающегося на противоположном крае доски (Y = 8). Этот путь должен еще проходить после второго хода через поле 5/4.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3583922"></a>Резюме<br></h3>
<div>   Примеры, рассмотренные в данном разделе, иллюстрируют некоторые достоинства и характерные черты программирования на Прологе:<br>   • Базу данных можно естественным образом представить в виде множества прологовских фактов.<br>   • Такие механизмы Пролога, как вопросы и сопоставление, можно гибко использовать для получения информации из базы данных. Кроме этого можно использовать вспомогательные процедуры-утилиты, еще больше облегчающие взаимодействие с конкретной базой данных.<br>   • <i>Абстракцию данных</i> можно рассматривать как метод программирования, который облегчает работу со сложными структурами данных и вносит большую ясность и наглядность в программы. В Прологе легко соблюдать основные принципы абстракции данных.<br>   • Часто легко можно осуществить перевод абстрактных математических конструкций, таких как автоматы, на язык определений Пролога, готовых к выполнению.<br>   • Как это было в случае восьми ферзей, многие задачи допускают различные подходы, связанные с разными представлениями этих задач. Часто внесение избыточности в представление экономит вычисления. Происходит как бы проигрыш в рабочем пространстве, но выигрыш во времени.<br>   • Часто основным шагом на пути к решению оказывается обобщение задачи. Парадоксально, но рассмотрение более общей задачи позволяет облегчить формулировку решения.<br></div>
</div>
<h2 align="center">
<a name="TOC_id3583969"></a>Глава 5<br>Управление перебором<br></h2>
<div>
<div>   Мы уже видели, что программист может управлять процессом вычислений по программе, располагая ее предложения и цели в том или ином порядке. В данной главе мы рассмотрим еще одно средство управления, получившее название "отсечение" (cut) и предназначенное для ограничения автоматического перебора.<br></div>
<h3 align="center">
<a name="TOC_id3583986"></a>5.1. Ограничение перебора<br></h3>
<div>
<div>   В процессе достижения цели пролог-система осуществляет автоматический перебор вариантов, делая возврат при неуспехе какого-либо из них. Такой перебор — полезный программный механизм, поскольку он освобождает пользователя от необходимости программировать его самому. С другой стороны, ничем не ограниченный перебор может стать источником неэффективности программы. Поэтому иногда требуется его ограничить или исключить вовсе. Для этого в Прологе предусмотрена конструкция "отсечение".<br><div align="center"><img border="1" src="_44.png"></div>   <b>Рис. 5.1.</b> Двухступенчатая функция<br>   Давайте сначала рассмотрим простую программу, процесс вычислений, по которой содержит ненужный перебор. Мы выделим те точки этого процесса, где перебор бесполезен и ведет к неэффективности.<br>   Рассмотрим двухступенчатую функцию, изображенную на рис. 5.1. Связь между X и Y можно определить с помощью следующих трех правил:<br>   <i>Правило 1</i>: если X &lt; 3, то Y = 0<br>   <i>Правило 2</i>: если 3 &#8804; X и X &lt; 6, то Y = 2<br>   <i>Правило 3</i>: если 6 &#8804; X, то Y = 4<br>   На Прологе это можно выразите с помощью бинарного отношения<br>   f( X, Y)<br>   так:<br>   f( X, 0) :- X &lt; 3.          % Правило 1<br>   f( X, 2) :- 3 =&lt; X,  X &lt; 6. % Правило 2<br>   f( X, 4) :- 6 =&lt; X.         % Правило 3<br>   В этой программе предполагается, конечно, что к моменту начала вычисления f( X, Y) X уже конкретизирован каким-либо числом; это необходимо для выполнения операторов сравнения.<br>   Мы проделаем с этой программой два эксперимента. Каждый из них обнаружит в ней свой источник неэффективности, и мы устраним оба этих источника по очереди, применив оператор отсечения. <br></div>
<h4 align="center">
<a name="TOC_id3584075"></a>5.1.1. Эксперимент 1<br></h4>
<div>   Проанализируем, что произойдет, если задать следующий вопрос:<br>   ?- f( 1, Y), 2 &lt; Y.<br><div align="center"><img border="1" src="_45.png"></div>   <b>Рис. 5.2.</b> В точке, помеченной словом "ОТСЕЧЕНИЕ", уже известно, что правила 2 и 3 должны потерпеть неудачу.<br>   При вычислении первой цели f( 1, Y) Y конкретизируется нулем. Поэтому вторая цель становится такой:<br>   2 &lt; 0<br>   Она терпит неудачу, а поэтому и весь список целей также терпит неудачу. Это очевидно, однако перед тем как признать, что такому списку целей удовлетворить нельзя, пролог-система при помощи возвратов попытается проверить еще две бесполезные в данном случае альтернативы. Пошаговое описание процесса вычислений приводится на рис. 5.2.<br>   Три правила, входящие в отношение f, являются взаимоисключающими, поэтому успех возможен самое большее в одном из них. Следовательно, мы (но не пролог-система) знаем, что, как только успех наступил в одном из них, нет смысла проверять остальные, поскольку они все равно обречены на неудачу. В примере, приведенном на рис. 5.2, о том, что в правиле 1 наступил успех, становится известно в точке, обозначенной словом "ОТСЕЧЕНИЕ". Для предотвращения бессмысленного перебора мы должны явно указать пролог-системе, что <i>не нужно</i> осуществлять возврат из этой точки. Мы можем сделать это при помощи конструкции отсечения. "Отсечение" записывается в виде символа <b>'</b>!<b>'</b>, который вставляется между целями и играет роль некоторой псевдоцели. Вот наша программа, переписанная с использованием отсечения:<br>   f( X, 0) :- X &lt; 3,  !.<br>   f( X, 2) :- 3 =&lt; X,  X &lt; 6,  !.<br>   f( X, 4) :- 6 =&lt; X.<br>   Символ  '!'  предотвращает возврат из тех точек программы, в которых он поставлен. Если мы теперь спросим<br>   ?- f( 1, Y), 2 &lt; Y.<br>   то пролог-система породит левую ветвь дерева, изображенного на рис. 5.2. Эта ветвь потерпит неудачу на цели 2 &lt; 0.   Система попытается сделать возврат, но вернуться она сможет не далее точки, помеченной в программе символом '!'.  Альтернативные ветви, соответствующие правилу 2 и правилу 3, порождены не будут.<br>   Новая программа, снабженная отсечениями, во всех случаях более эффективна, чем первая версия, в которой они отсутствуют. Неудачные варианты новая программа распознает всегда быстрее, чем старая.<br>   Вывод: добавив отсечения, мы повысили эффективность. Если их теперь убрать, программа породит тот же результат, только на его получение она истратит скорее всего больше времени. Можно сказать, что в нашем случае после введения отсечений мы изменили только процедурный смысл программы, оставив при этом ее декларативный смысл в неприкосновенности. В дальнейшем мы покажем, что использование отсечения может также затронуть и декларативный смысл программы.<br></div>
<h4 align="center">
<a name="TOC_id3584203"></a>5.1.2. Эксперимент 2<br></h4>
<div>   Проделаем теперь еще один эксперимент со второй версией нашей программы. Предположим, мы задаем вопрос:<br>   ?- f( 7, Y).<br>   Y = 4<br>   Проанализируем, что произошло. Перед тем, как был получен ответ, система пробовала применить все три правила. Эти попытки породили следующую последовательность целей:<br>   <i>Попытка применить правило 1:</i><br>    7 &lt; 3 терпит неудачу, происходит возврат, и попытка применить правило 2 (точка отсечения достигнута не была)<br>   <i>Попытка применить правило 2:</i><br>    3 &#8804; 7  успех, но 7 &lt; 6 терпит неудачу; возврат и попытка применить правило 3 (точка отсечения снова не достигнута)<br>   <i>Попытка применить правило 3:</i><br>    6 &#8804; 7 — успех<br>   Приведенные этапы вычисления обнаруживают еще один источник неэффективности. В начале выясняется, что X &lt; 3 не является истиной (7 &lt; 3 терпит неудачу). Следующая цель — 3 =&lt; X (3 &#8804; 7 — успех). Но нам известно, что, если первая проверка неуспешна, то вторая обязательно будет успешной, так как второе целевое утверждение является отрицанием первого. Следовательно, вторая проверка лишняя и соответствующую цель можно опустить. То же самое верно и для цели 6 =&lt; X в правиле 3. Все эти соображения приводят к следующей, более экономной формулировке наших трех правил:<br>    если X &lt; 3, то Y = 0<br>    иначе, если 3 &#8804; X  и X &lt; 6, то Y = 2,<br>    иначе Y = 4.<br>   Теперь мы можем опустить в нашей программе те условия, которые обязательно выполняются при любом вычислении. Получается третья версия программы:<br>   f( X, 0) :- X &lt; 3, !.<br>   f( X, 2) :- X &lt; 6, !.<br>   f( X, 4).<br>   Эта программа дает тот же результат, что и исходная, но более эффективна, чем обе предыдущие. Однако, что будет, если мы <i>теперь</i> удалим отсечения? Программа станет такой:<br>   f( X, 0) :- X &lt; 3.<br>   f( X, 2) :- X &lt; 6.<br>   f( X, 4).<br>   Она может порождать различные решения, часть из которых неверны. Например:<br>   ?- f( 1, Y).<br>
		 <br>   Y = 0;<br>   Y = 2;<br>   Y = 4;<br>   nо    (нет)<br>   Важно заметить, что в последней версии, в отличие от предыдущей, отсечения затрагивают не только процедурное поведение, но изменяют также и декларативный смысл программы.<br>   Более точный смысл механизма отсечений можно сформулировать следующим образом:<br><blockquote>   Назовем "целью-родителем" ту цель, которая сопоставилась с головой предложения, содержащего отсечение. Когда в качестве цели встречается отсечение, такая цель сразу же считается успешной и при этом заставляет систему принять те альтернативы, которые были выбраны с момента активизации цели-родителя до момента, когда встретилось отсечение. Все оставшиеся в этом промежутке (от цели-родителя до отсечения) альтернативы не рассматриваются.<br></blockquote>   Чтобы прояснить смысл этого определения, рассмотрим предложение вида<br>   H :- В1, В2, ..., Вm, !, ..., Вn.<br>   Будем считать, что это предложение активизировалось, когда некоторая цель G сопоставилась с H. Тогда G является целью-родителем. В момент, когда встретилось отсечение, успех уже наступил в целях В1, …, Вm. При выполнении отсечения это (текущее) решение В1, …, Вm "замораживается" и все возможные оставшиеся альтернативы больше не рассматриваются. Далее, цель G связывается теперь с этим предложением: любая попытка сопоставить  G  с головой какого-либо другого предложения пресекается.<br>   Применим эти правила к следующему примеру:<br>   С :- P, Q, R, !, S, T, U.<br>   С :- V.<br>   А :- В, С, D.<br>   ?- А.<br>   Здесь А, В, С, D, P и т.д. имеют синтаксис термов. Отсечение повлияет на вычисление цели С следующим образом. Перебор будет возможен в списке целей P, Q, R; однако, как только точка отсечения будет достигнута, все альтернативные решения для этого списка изымаются из рассмотрения. Альтернативное предложение, входящее в С:<br>   С :- V.<br>   также не будет учитываться. Тем не менее, перебор будет возможен в списке целей S, T, U. "Цель-родитель" предложения, содержащего отсечения, — это цель С в предложении<br>   А :- В, С, D.<br>   Поэтому отсечение повлияет только на цель С. С другой стороны, оно будет "невидимо" из цели А. Таким образом, автоматический перебор все равно будет происходить в списке целей В, С, D, вне зависимости от наличия отсечения в предложении, которое используется для достижения С.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3584444"></a>5.2. Примеры, использующие отсечение <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3584450"></a>5.2.1.  Вычисление максимума<br></h4>
<div>   Процедуру нахождения наибольшего из двух чисел можно запрограммировать в виде отношения<br>   mах( X, Y, Мах)<br>   где Мах = X, если X больше или равен Y, и Мах есть Y, если X меньше Y. Это соответствует двум таким предложениям:<br>   mах( X, Y, X) :- X &gt;= Y.<br>   max( X, Y, Y) :- X &lt; Y.<br>   Эти правила являются взаимно исключающими. Если выполняется первое, второе обязательно потерпит неудачу. Если неудачу терпит первое, второе обязательно должно выполниться. Поэтому возможна более экономная формулировка, использующая понятие "иначе":<br>    если X &#8805; Y, то Мах = X,<br>    иначе Мах = Y.<br>   На Прологе это записывается при помощи отсечения:<br>   mах( X, Y, X) :- X &gt;= Y,  !.<br>   mах( X, Y, Y).<br></div>
<h4 align="center">
<a name="TOC_id3584499"></a>5.2.2. Процедура проверки принадлежности списку, дающая единственное решение <br></h4>
<div>   Для того, чтобы узнать, принадлежит ли X списку L, мы пользовались отношением<br>   принадлежит( X, L)<br>   Программа была следующей:<br>   принадлежит( X, [X | L] ).<br>   принадлежит X, [Y | L] ) :- принадлежит( X, L).<br>   Эта программа дает "недетерминированный" ответ: если X встречается в списке несколько раз, то будет найдено каждое его вхождение. Исправить этот недостаток не трудно: нужно только предотвратить дальнейший перебор сразу же после того, как будет найден первый X, а это произойдет, как только в первом предложении наступит успех. Измененная программа выглядит так:<br>   принадлежит( X, [X | L] ) :- !.<br>   принадлежит( X, [Y | L] ) :- принадлежит( X, L).<br>   Эта программа породит только одно решение. Например:<br>   ?- принадлежит( X, [а, b, с] ).<br>
		 <br>   X = а;<br>   nо    (нет)<br></div>
<h4 align="center">
<a name="TOC_id3584560"></a>5.2.3. Добавление элемента к списку, если он в нем отсутствует (добавление без дублирования)<br></h4>
<div>   Часто требуется добавлять элемент X в список L только в том случае, когда в списке еще нет такого элемента. Если же X уже есть в L, тогда L необходимо оставить без изменения, поскольку нам не нужны лишние дубликаты X. Отношение добавить имеет три аргумента:<br>   добавить( X, L, L1)<br>   где X — элемент, который нужно добавить, L — список, в который его нужно добавить, L1 — результирующий новый список. Правила добавления можно сформулировать так:<br>    если X принадлежит к L, то L1 = L,<br>    иначе L1 — это список L с добавленным к нему элементом X.<br>   Проще всего добавлять X в начало списка L так, чтобы X стал головой списка L1. Запрограммировать это можно так:<br>   добавить( X, L, L) :- принадлежит( X, L), !.<br>   добавить( X, L, [X | L] ).<br>   Поведение этой процедуры можно проиллюстрировать следующим примером:<br>   ?- добавить( а, [b,с], L).<br>   L = [a, b, c]<br>
		 <br>   ?- до6авить( X, [b, с], L).<br>   L = [b, с]<br>   X = b<br>
		 <br>   ?- добавить( а, [b, с, X], L).<br>   L = [b, с, а]<br>   X = а<br>   Этот пример поучителен, поскольку мы не можем легко запрограммировать "недублирующее добавление", не используя отсечения или какой-либо другой конструкции, полученной из него. Если мы уберем отсечение в только что рассмотренной программе, то отношение добавить будет добавлять дубликаты элементов, уже имеющихся в списке. Например:<br>   ?- добавить( a, [a, b, c], L),<br>   L = [а, b, с]<br>   L = [а, а, b, с]<br>   Поэтому отсечение требуется здесь для правильного определения отношения, а не только для повышения эффективности. Этот момент иллюстрируется также и следующим примером.<br></div>
<h4 align="center">
<a name="TOC_id3584672"></a>5.2.4. Задача классификации объектов<br></h4>
<div>   Предположим, что у нас есть база данных, содержащая результаты теннисных партий, сыгранных членами некоторого клуба. Подбор пар противников для каждой партия не подчинялся какой-либо системе, просто каждый игрок встречался с несколькими противниками. Результаты представлены в программе в виде фактов, таких как<br>   победил( том, джон).<br>   победил( энн, том).<br>   победил( пат, джим).<br>   Мы хотим определить<br>   отношение класс( Игрок, Категория)<br>   которое распределяет игроков по категориям. У нас будет три категории:<br>    победитель — любой игрок, победивший во всех сыгранных им играх<br>    боец — любой игрок, в некоторых играх победивший, а в некоторых проигравший<br>    спортсмен — любой игрок, проигравший во всех сыгранных им партиях<br>   Например, если в нашем распоряжении есть лишь приведенные выше результаты, то ясно, что Энн и Пат — победители. Том — боец и Джим — спортсмен.<br>   Легко сформулировать правило для бойца:<br>    X — боец, если существует некоторый Y, такой, что X победил Y, и<br>     существует некоторый Z, такой, что Z победил X.<br>   Теперь правило для победителя:<br>    X — победитель, если<br>     X победил некоторого Y и<br>     X не был побежден никем.<br>   Эта формулировка содержит отрицание "не", которое нельзя впрямую выразить при помощи тех возможностей Пролога, которыми мы располагаем к настоящему моменту. Поэтому оказывается, что формулировка отношения победитель должна быть более хитрой. Та же проблема возникает и при формулировке правил для отношения спортсмен. Эту проблему можно обойти, объединив определения отношений победитель и боец и использовав связку "иначе". Вот такая формулировка:<br>    Если X победил кого-либо и X был кем-то побежден,<br>    то X — боец,<br>    иначе, если X победил кого-либо,<br>     то X — победитель, <br>     иначе, если X был кем-то побежден,<br>      то X — спортсмен.<br>   Такую формулировку можно сразу перевести на Пролог. Взаимные исключения трех альтернативных категорий выражаются при помощи отсечений:<br>   класс( X, боец) :-<br>    победил( X, _ ),<br>    победил( _, X),  !.<br>
		 <br>   класс( X, победитель) :-<br>    победил( X, _ ),  !.<br>
		 <br>   класс( X, спортсмен) :-<br>    победил( _, X).<br>   Заметьте, что использование отсечения в предложении для категории победитель не обязательно, что связано с особенностями наших трех классов.<br><h5>Упражнения</h5>   <b>5.1.</b> Пусть есть программа:<br>   p( 1).<br>   p( 2) :- !.<br>   p( 3).<br>   Напишите все ответы пролог-системы на следующие вопросы:<br>   (a) ?- p( X).<br>   (b) ?- p( X), p(Y).<br>   (c) ?- p( X), !, p(Y).<br>   <b>5.2.</b> Следующие отношения распределяют числа на три класса - положительные, нуль и отрицательные:<br>   класс( Число, положительные) :- Число &gt; 0.<br>   класс( 0, нуль).<br>   класс( Число, отрицательные) :- Число &lt; 0.<br>   Сделайте эту процедуру более эффективной при помощи отсечений.<br>   <b>5.3.</b> Определите процедуру<br>   разбить( Числа, Положительные, Отрицательные)<br>   которая разбивает список чисел на два списка: список, содержащий положительные числа (и нуль), и список отрицательных чисел. Например,<br>   разбить( [3, -1, 0, 5, -2], [3, 0, 5], [-1, -2] )<br>   Предложите две версии: одну с отсечением, другую — без.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3584929"></a>5.3. Отрицание как неуспех<br></h3>
<div>   "Мэри любит всех животных, кроме змей". Как выразить это на Прологе? Одну часть этого утверждения выразить легко: "Мэри любит всякого X, если X — животное". На Прологе это записывается так:<br>   любит( мэри, X) :- животное ( X).<br>   Но нужно исключить змей. Это можно сделать, использовав другую формулировку:<br>    Если X — змея, то "Мэри любит X" — не есть истина,<br>    иначе, если X — животное, то Мэри любит X.<br>   Сказать на Прологе, что что-то не есть истина, можно при помощи специальной цели fail (неуспех), которая всегда терпит неудачу, заставляя потерпеть неудачу и ту цель, которая является ее родителем. Вышеуказанная формулировка, переведенная на Пролог с использованием fail, выглядит так:<br>   любит( мэри, X) :-<br>    змея( X),  !,  fail.<br>   любит( Мэри, X) :-<br>    животное ( X).<br>   Здесь первое правило позаботится о змеях: если X — змея, то отсечение предотвратит перебор (исключая таким образом второе правило из рассмотрения), а fail вызовет неуспех. Эти два предложения можно более компактно записать в виде одного:<br>   любит( мэри, X):-<br>    змея( X), !, fail;<br>    животное ( X).<br>   Ту же идею можно использовать для определения отношения<br>   различны( X, Y)<br>   которое выполняется, если X и Y не совпадают. При этом, однако, мы должны быть точными, потому что "различны" можно понимать по-разному:<br>   • X и Y не совпадают буквально;<br>   • X и Y не сопоставимы;<br>   • значения арифметических выражений X и Y не равны.<br>   Давайте считать в данном случае, что X и Y различны, если они не сопоставимы. Вот способ выразить это на Прологе:<br>    Если X и Y сопоставимы, то<br>     цель различны( X, Y) терпит неуспех<br>     иначе цель различны( X, Y) успешна.<br>   Мы снова используем сочетание отсечения и fail:<br>   различны( X, X) :- !, fail.<br>   различны( X, Y).<br>   То же самое можно записать и в виде одного предложения:<br>   различны( X, Y) :-<br>    X = Y, !, fail;<br>    true.<br>   Здесь true — цель, которая всегда успешна.<br>   Эти примеры показывают, что полезно иметь унарный предикат "not" (не), такой, что<br>   nоt( Цель)<br>   истинна, если Цель не истинна. Определим теперь отношение not следующим образом:<br>    Если Цель успешна, то not( Цель) неуспешна,<br>    иначе not( Цель) успешна.<br>   Это определение может быть записано на Прологе так:<br>   not( P) :-<br>    P, !, fail;<br>    true.<br>   Начиная с этого момента мы будем предполагать, что  not — это встроенная прологовская процедура, которая ведет себя так, как это только что было определено. Будем также предполагать, что оператор not определен как префиксный, так что цель<br>   not( змея( X) )<br>   можно записывать и как<br>   not змея( X)<br>   Многие версии Пролога поддерживают такую запись. Если же приходится иметь дело с версией, в которой нет встроенного оператора not, его всегда можно определить самим.<br>   Следует заметить, что not, как он здесь определен с использованием неуспеха, не полностью соответствует отрицанию в математической логике. Эта разница может породить неожиданности в поведении программы, если оператором not пользоваться небрежно. Этот вопрос будет рассмотрен в данной главе позже.<br>   Тем не менее not — полезное средство, и его часто можно с выгодой применять вместо отсечения. Наши два примера можно переписать с not:<br>   любит( мэри, X) :-<br>    животное ( X),<br>    not змея( X).<br>
		 <br>   различны( X, Y) :-<br>    not( X = Y).<br>   Это, конечно, выглядит лучше, нежели наши прежние формулировки. Вид предложений стал более естественным, и программу стало легче читать.<br>   Нашу программу теннисной классификации из предыдущего раздела можно переписать с использованием not так, чтобы ее вид был ближе к исходным определениям наших трех категорий:<br>   класс( X, боец) :-<br>    победил( X, _ ),<br>    победил( _, X).<br>
		 <br>   класс( X, победитель) :-<br>    победил( X, _ ),<br>    not победил( _, X).<br>
		 <br>   класс( X, спортсмен) :-<br>    not победил( X, _ ).<br>   В качестве еще одного примера использования not рассмотрим еще раз программу 1 для решения задачи о восьми ферзях из предыдущей главы (рис. 4.7). Мы определили там отношение небьет между некоторым ферзем и остальными ферзями. Это отношение можно определить также и как отрицание отношения "бьет". На рис. 5.3 приводится соответствующим образом измененная программа.<br>
		 <br>   решение( []).<br>   решение( [X/Y | Остальные] ) :-<br>    решение( Остальные),<br>    принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),<br>    not бьет( X/Y, Остальные).<br>
		 <br>   бьет( X/Y, Остальные) :-<br>    принадлежит( X1/Y1, Остальные),<br>    ( Y1 = Y;<br>      Y1 is Y + X1 - X;<br>      Y1 is Y - X1 + X ).<br>    принадлежит( А, [А | L] ).<br>
		 <br>   принадлежит( А, [В | L] ) :-<br>    принадлежит( А, L).<br>
		 <br>   % Шаблон решения<br>   шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).<br>   <b>Рис. 5.3.</b>  Еще одна программа для решения задачи о восьми ферзях.<br>
		 <br><h5>Упражнения</h5>   <b>5.4.</b> Даны два списка Кандидаты и Исключенные, напишите последовательность целей (используя принадлежит и not), которая, при помощи перебора, найдет все элементы списка Кандидаты, не входящие в список Исключенные.<br>   <b>5.5.</b> Определите отношение, выполняющее вычитание множеств:<br>   разность( Множ1, Множ2, Разность)<br>   где все три множества представлены в виде списков. Например,<br>   разность( [a, b, c, d], [b, d, e, f], [a, c] )<br>   Посмотреть ответ<br>   <b>5.6.</b> Определите предикат<br>   унифицируемые( Спис1, Терм, Спис2)<br>   где Спис2 — список всех элементов Спис1, которые сопоставимы с Терм'ом, но не конкретизируются таким сопоставлением. Например:<br>   ?-  унифицируемые( [X, b, t( Y)], t( a), Спис).<br>   Спис = [ X, t( Y)]<br>   Заметьте, что и X и Y должны остаться неконкретизированными, хотя сопоставление с t( a) вызывает их конкретизацию. Указание: используйте not ( Терм1 = Терм2). Если цель Терм1 = Терм2 будет успешна, то not( Терм1 = Tepм2) потерпит неудачу и получившаяся конкретизация будет отменена!<br></div>
<h3 align="center">
<a name="TOC_id3585465"></a>5.4. Трудности с отсечением и отрицанием<br></h3>
<div>   Используя отсечение, мы кое-что выиграли, но не совсем даром. Преимущества и недостатки применения отсечения были показаны на примерах из предыдущих разделов. Давайте подытожим сначала преимущества:<br>   (1) При помощи отсечения часто можно повысить эффективность программы. Идея состоит в том, чтобы прямо сказать пролог-системе: не пробуй остальные альтернативы, так как они все равно обречены на неудачу.<br>   (2) Применяя отсечение, можно описать взаимоисключающие правила, поэтому есть возможность запрограммировать утверждение:<br>    <i>если</i> условие P, <i>то</i> решение Q,<br>    <i>иначе</i> решение R<br>   Выразительность языка при этом повышается.<br>   Ограничения на использование отсечения проистекают из того, что есть опасность потерять такое важное для нас соответствие между декларативным и процедурным смыслами программы. Если в программе нет отсечений, то мы можем менять местами порядок предложений и целей, что повлияет только на ее эффективность, но не на декларативный смысл. Если же отсечения в ней присутствуют, то изменение порядка предложений может повлиять на ее декларативный смысл. Это значит, что программа с измененным порядком, возможно, будет давать результаты, отличные от результатов исходной программы. Вот пример, демонстрирующий этот факт:<br>   p :- а, b.<br>   p :- с.<br>   Декларативный смысл программы: p истинно тогда и только тогда, когда истинны одновременно и а, и b или истинно с. Это можно записать в виде такой логической формулы:<br>    p &lt;===&gt; (а &amp; b) U с<br>   Можно поменять порядок этих двух предложений, но декларативный смысл останется прежним. Введем теперь отсечение<br>   p :- а, !, b.<br>   p :- с.<br>   Декларативный смысл станет теперь таким:<br>    p &lt;===&gt; (а &amp; b) U ( ~а &amp; с)<br>   Если предложения поменять местами<br>   p :- с.<br>   p :- а, !, b.<br>   декларативный смысл станет таким:<br>    p &lt;===&gt; с U ( а &amp; b)<br>   Важным моментом здесь является то, что при использовании отсечения требуется уделять больше внимания процедурным аспектам. К несчастью, эта дополнительная трудность повышает вероятность ошибок программирования.<br>   В наших примерах из предыдущего раздела мы видели, что удаление отсечений из программы может привести к изменению ее декларативного смысла. Но были также в такие случаи, когда отсечение на него не влияло. Использование отсечений последнего типа требует меньшей осторожности, и поэтому такие отсечения иногда называют "зелеными отсечениями". С точки зрения наглядности программы такие отсечения "невинны" и их использование вполне приемлемо. При чтении программы их можно просто игнорировать.<br>   Напротив, отсечения, влияющие на декларативный смысл, называются "красными". Красные отсечения — это такие отсечения, которые делают программу трудной для понимания, и их нужно применять с особой осторожностью.<br>   Отсечение часто используется в комбинации со специальной целью fail. В частности, мы определили отрицание какой-либо цели (not), как ее неуспех. Определенное таким образом отрицание представляет собой просто особый (более ограниченный) вид отсечения. Из соображений ясности программ мы предпочтем пользоваться not вместо комбинации <i>отсечение — неуспех</i> (всюду, где возможно), поскольку отрицание является понятием более высокого уровня, чем <i>отсечение — неуспех</i>.<br>   Следует заметить, что использование оператора not также может приводить к неприятностям, и его тоже следует применять с осторожностью. Трудность заключается в том, что тот оператор not, который был нами определен, не в точности соответствует отрицанию в математике. Если спросить<br>   ?- not человек( мэри).<br>   система, возможно, ответит "да". Не следует понимать этот ответ как "мэри не человек". Что в действительности пролог-система хочет сказать своим "да", так это то, что программе не хватает информации для доказательства утверждения "Мэри — человек". Это происходит потому, что при обработке цели not система не пытается доказать истинность этой цели впрямую. Вместо этого она пытается доказать противоположное утверждение, и если такое противоположное утверждение доказать не удается, система считает, что цель not — успешна. Такое рассуждение основано на так называемом <i>предположении о замкнутости мира</i>. В соответствии с этим постулатом <i>мир замкнут</i> в том смысле, что все в нем существующее либо указано в программе, либо может быть из нее выведено. И наоборот — если что-либо не содержится в программе (или не может быть из нее выведено), то оно не истинно и, следовательно, истинно его отрицание. Это обстоятельство требует особого внимания, поскольку мы обычно не считаем мир замкнутым: если в программе явно не сказано, что<br>   человек( мэри)<br>   то мы этим обычно вовсе не хотим сказать, что Мэри не человек.<br>   Дальнейшее изучение опасных аспектов использования not проведем на таком примере:<br>   r( а).<br>   g( b).<br>   p( X) :- not r( X).<br>   Если спросить теперь<br>   ?-  g( X), p( X).<br>   система ответит<br>   X = b<br>   Если же задать тот же вопрос, но в такой форме<br>   ?- p( X), g( X).<br>   система ответит<br>   nо        (нет)<br>   Читателю предлагается проследить работу программы по шагам, чтобы понять, почему получились разные ответы. Основная разница между вопросами состоит в том, что переменная X к моменту вычисления p( X) в первом случае была уже конкретизирована, в то время как во втором случае этого еще не произошло.<br>   Мы детально обсудили аспекты применения отсечения, которое неявно присутствует в not. При этом нами руководило желание предупредить пользователей о соблюдении необходимой осторожности, а вовсе не желание убедить их совсем не пользоваться этим оператором. Отсечение полезно, а часто и необходимо. А что касается трудностей Пролога, порождаемых отсечением, то подобные неудобства часто возникают и при программировании на других языках.<br></div>
<h3 align="center">
<a name="TOC_id3585752"></a>Резюме<br></h3>
<div>   • Отсечение подавляет перебор. Его применяют как для повышения эффективности программ, так и для повышения выразительности языка.<br>   • Эффективность повышается путем прямого указания (при помощи отсечения) пролог — системе не проверять альтернативы, про которые нам заранее известно, что они должны потерпеть неудачу.<br>   • Отсечение дает возможность сформулировать взаимно исключающие утверждения при помощи правил вида:<br>    <i>если</i> <b>Условие</b> <i>то</i> <b>Утверждение1</b> <i>иначе</i> <b>Утверждение2</b><br>   • Отсечение дает возможность ввести <i>отрицание как неуспех</i>: not( Цель) определяется через неуспех цели Цель.<br>   • Иногда бывают полезными две особые цели true и fail. true — всегда успешна и fail — всегда терпит неудачу.<br>   • Существуют ограничения в применении отсечения: его появление может нарушить, соответствие между декларативным и процедурным смыслами программы. Поэтому хороший стиль программирования предполагает осторожное применение отсечений и отказ от их применения без достаточных оснований.<br>   • Оператор not, определенный через неуспех, не полностью соответствует отрицанию в математической логике. Поэтому not тоже нужно применять с осторожностью.<br><h5>Литература</h5>   Различать "зеленые и "красные" отсечения предложил ван Эмден (1982).<br>   van Emden M. (1982). Red and green cuts. <i>Logic Programming Newsletter:  2</i>.<br></div>
</div>
<h2 align="center">
<a name="TOC_id3585865"></a>Глава 6<br>Ввод и вывод<br></h2>
<div>
<div>   В этой главе мы рассмотрим некоторые встроенные средства для записи данных в файл и считывания их из файла. Такие средства можно также применять и для форматирования объектов данных программы, чтобы получить желаемую форму их внешнего представления. Одновременно мы рассмотрим и средства синтеза и декомпозиции атомов.<br></div>
<h3 align="center">
<a name="TOC_id3585882"></a>6.1. Связь с файлами<br></h3>
<div>   До сих пор мы применяли только один метод связи пользователя с программой — пользователь задает программе вопросы, а программа ему отвечает, конкретизируя переменные. Такой механизм связи прост и практичен и, несмотря на свою простоту, обеспечивает ввод и вывод информации. Однако он обладает слишком малой гибкостью и поэтому часто не совсем удобен. В следующих случаях требуется расширение этого основного механизма связи:<br>   • ввод данных в форме, отличной от вопроса - например, в виде предложений, написанных на английском языке<br>   • вывод информации в произвольном формате<br>   • обмен информацией с произвольным файлом, а не только с пользовательским терминалом<br>   Встроенные предикаты, предназначенные для этого расширения, отличаются в разных реализациях Пролога. Мы изучим здесь простой и удобный набор таких предикатов, применяемый во многих реализациях. Однако за деталями и специфическими особенностями следует, конечно, обращаться к руководствам по конкретным пролог-системам.<br><div align="center"><img border="1" src="_46.png"></div>   <b>Рис. 6. 1.</b>  Связь между пролог-программой и различными файлами.<br>   Рассмотрим вначале вопрос о том, как обмениваться информацией с файлами, а затем — как можно вводить и выводить данные в разных форматах.<br>   На рис. 6.1 показана общая ситуация, в которой пролог-программа взаимодействует с несколькими файлами. Она может, в принципе, считывать данные из нескольких входных файлов, называемых также <i>входными потоками</i>, и выводить данные в несколько выходных файлов, называемых <i>выходными потоками</i>. Информация, поступающая с пользовательского терминала, рассматривается просто как еще один входной поток. Аналогично информация, выводимая на этот терминал, рассматривается как один из выходных потоков. На оба этих "псевдофайла" ссылаются с помощью имени user (пользователь). Имена остальных файлов программист должен выбирать в соответствии с правилами именования файлов, принятыми в используемой компьютерной системе.<br>   В каждый момент выполнения пролог-программы лишь два файла являются "активными": один для ввода, другой — для вывода. Эти два файла называются <i>текущим входным потоком</i> и <i>текущим выходным потоком</i> соответственно. В начальный момент эти два потока соответствуют терминалу. Текущий входной поток может быть заменен на другой файл ИмяФайла посредством цели<br>   see( ИмяФайла)              ( Смотри(ИмяФайла) )<br>   Такая цель всегда успешна (если только с файлом ИмяФайла все в порядке), а в качестве побочного эффекта происходит переключение ввода с предыдущего входного потока на файл ИмяФайла. Поэтому типичным примером использования предиката see является следующая последовательность целей, которая считывает информацию из файла файл1, а затем переключается обратно на терминал:<br>   ...<br>   see( файл1),<br>   читать_из_файла( Информация),<br>   see( user),                  ( user — пользователь)<br>   ...<br>   Текущий выходной поток может быть изменен при помощи цели вида<br>   tell( ИмяФайла)              ( сообщить( ИмяФайла) )<br>   Следующая последовательность целей выводит некоторую информацию в файл3, а после этого перенаправляет последующий вывод обратно на терминал:<br>   ...<br>   tell( файл3),<br>   записать_в_файл( Информация),<br>   tell( user),<br>   ...<br>   Цель<br>   seen                          ( конец чтения)<br>   закрывает текущий входной файл. Цель<br>   told                          ( конец записи)<br>   закрывает текущий выходной файл.<br>   Файлы могут обрабатываться только последовательно. В этом смысле все файлы ведут себя так же, как терминал. Каждый запрос на чтение из входного файла приводит к чтению в текущей позиции текущего входного потока. После этого чтения текущая позиция, естественно, будет перемещена на следующий, еще не прочитанный элемент данных. Следующий запрос на чтение приведет к считыванию, начиная с этой новой текущей позиции. Если запрос на чтение делается в конце файла, то в качестве ответа на такой запрос выдается атом end_of_file (конец файла). Считанную один раз информацию считать вторично невозможно.<br>   Запись производится точно так же, каждый запрос на вывод информации приведет к тому, что она будет присоединена в концу текущего выходного потока. Невозможно сдвинуться назад и переписать часть файла.<br>   Все файлы являются "текстовыми", т.е. файлами, состоящими из символов. Символы — это буквы, цифры и специальные знаки. О некоторых из них говорят, что они непечатаемые, поскольку, будучи выведенными на терминал, они не появляются на экране. Однако их присутствие может сказаться каким-либо другим образом, например появятся пробелы или пустые строки.<br>   Существуют два основных способа, с помощью которых файлы рассматриваются в Прологе в зависимости от формы записанной в них информации. Один способ - рассматривать символ как основной элемент файла. Соответственно один запрос на ввод или вывод приведет к чтению или записи одного символа. Для этой цели предназначены встроенные предикаты get, get0 и put (получить, получить0 и выдать).<br>   Другой способ рассматривать файл — считать, что в качестве основных элементов построения файла используются более крупные единицы текста. Такой естественной более крупной единицей является прологовский терм. Поэтому каждый запрос на ввод/вывод такого типа приведет к переносу целого терма из текущего входного потока или в текущий выходной поток соответственно. Предикатами для переноса термов являются предикаты read и write (читать и писать). В этом случае информация в файле должна, конечно, по форме соответствовать синтаксису термов.<br>   Очевидно, что выбор формы организации файла зависит от задачи. Всякий раз, когда особенности задачи допускают естественное представление информации в соответствии с синтаксисом термов, следует предпочесть файлы, состоящие из термов. Тогда появится возможность за одно обращение и вводу или выводу пересылать целые осмысленные фрагменты информации. С другой стороны, существуют задачи, природа которых диктует иную организацию файлов. Примером такого рода задачи является обработка предложений естественного языка, скажем, для организации диалога между системой и пользователем на английском языке. В таких случаях файлы следует рассматривать как последовательности символов, которые не укладываются в синтаксис термов.<br></div>
<h3 align="center">
<a name="TOC_id3586164"></a>6.2. Обработка файлов термов <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3586170"></a>6.2.1. <i>reаd</i> и <i>write</i><br></h4>
<div>   Встроенный предикат read используется для чтения термов из текущего входного потока. Цель<br>   read( X)<br>   вызывает чтение следующего терма T и сопоставление его с X. Если X — переменная, то в результате X конкретизируется и становится равным T. Если сопоставление терпит неудачу, цель read( X) тоже терпит неудачу. Предикат read — детерминированный в том смысле, что в случае неуспеха не происходит возврата для ввода следующего терма. После каждого терма во входном файле должна стоять точка или пробел, или символ возврата каретки.<br>   Если read( X) вычисляется в тот момент, когда достигнут конец текущего входного файла, тогда X конкретизируется атомом end_of_file (конец файла).<br>   Встроенный предикат write выводит терм. Поэтому цель<br>   write( X)<br>   выведет терм X в текущий выходной файл. X будет выведен в той же стандартной форме, в какой обычно пролог-система изображает на экране или распечатке значения переменных. Полезной особенностью Пролога является то, что процедура write "знает", как изображать любой терм, как бы сложен он не был.<br>   Существуют дополнительные встроенные предикаты для форматирования вывода. Они вставляют пробелы в дополнительные строки в выходной поток. Цель<br>   tab( N)<br>   выводит N пробелов. Предикат nl (без аргументов) приводит к переходу на новую строку.<br>   Следующие примеры иллюстрируют использование этих процедур.<br>   Предположим, у нас есть процедура для вычисления кубов чисел:<br>   куб( N, С) :-<br>    С is N * N * N.<br>   Предположим далее, что мы хотим применить ее для вычисления кубов элементов некоторой последовательности чисел. Это можно сделать с помощью последовательности вопросов:<br>   ?- куб( 2, X).<br>   X = 8<br>
		 <br>   ?- ку6( 5, Y).<br>   Y = 125<br>
		 <br>   ?-  куб( 12, Z).<br>   Z = 1728<br>   Для получения каждого результата нам придется набирать соответствующую цель. Давайте теперь изменим эту программу так, чтобы процедура куб сама читала соответствующие данные. Теперь программа будет сама читать данные и выводить их кубы до тех пор, пока не будет прочитан атом стоп:<br>   куб :-<br>    read( X),<br>    обработать( X).<br>
		 <br>   обработать( стоп) :- !.<br>   обработать( N) :-<br>    С is N * N * N,<br>    write( С),<br>    куб.<br>   Это был пример программы, декларативный смысл которой трудно сформулировать. В то же время ее процедурный смысл совершенно ясен: чтобы вычислить куб, сначала нужно считать X, а затем его обработать; если X = стоп, то все сделано, иначе вывести X&#179; и рекурсивно запустить процедуру куб для обработки остальных чисел.<br>   С помощью этой новой процедуры таблица кубов чисел может быть получена таким образом:<br>   ?- куб.<br>
		 <br>   2.<br>   8<br>   5.<br>   125<br>   12.<br>   1728<br>   стоп.<br>   yes<br>   Числа 2, 5 и 12 были введены пользователем с терминала, остальные числа были выведены программой. Заметьте, что после каждого числа, введенного пользователем, должна стоять точка, которая сигнализирует о конце терма.<br>   Может показаться, что приведённую процедуру куб можно упростить. Однако следующая попытка такого упрощения является ошибочной:<br>   куб :-<br>    read( стоп), !.<br>   куб :-<br>    read( N),<br>    С is N * N * N,<br>    write( С),<br>    куб.<br>   Причина, по которой эта процедура работает неправильно, станет очевидной, если проследить, какие действия она выполняет с входным аргументом, скажем с числом 5. Цель read( стоп) потерпит неудачу при чтении этого числа, и оно будет потеряно навсегда. Следующая цель read введет следующий терм. С другой стороны может случиться, что сигнал стоп будет считан целью read( N), что приведет к попытке перемножить нечисловую информацию.<br>   Процедура куб ведет диалог между пользователем и программой. В таких случаях обычно желательно, чтобы программа перед тем, как читать с терминала новые данные, дала сигнал пользователю о том, что она готова к приему информации, а также, возможно, и о том, какого вида информация ожидается. Это делается обычно путем выдачи "приглашения" перед чтением. Нашу процедуру куб можно для этого изменить, например, так:<br>   куб :-<br>    write( 'Следующее число, пожалуйста:'),<br>    read( X),<br>    обработать( X).<br>
		 <br>   обработать( стоп) :- !.<br>   обработать( N) :-<br>    С is N * N * N,<br>    write( 'Куб'), write( N), write( 'равен'),<br>    write( С), nl,<br>    куб.<br>   Разговор с новой версией мог бы быть, например, таким:<br>   ?- куб.<br>
		 <br>   Следующее число, пожалуйста: 5.<br>   Куб 5 равен 125<br>
		 <br>   Следующее число, пожалуйста: 12.<br>   Куб 12 равен 1728<br>
		 <br>   Следующее число, пожалуйста: стоп.<br>   yes<br>   В некоторых реализациях для того, чтобы приглашение появилось на экране перед чтением, необходимо выдать дополнительный запрос (такой, скажем, как ttyflush) после записи.<br>   В последующих разделах мы увидим некоторые типичные примеры операций, в которых участвуют чтение и запись.<br></div>
<h4 align="center">
<a name="TOC_id3586594"></a>6.2.2. Вывод списков <br></h4>
<div>   Кроме стандартного прологовского формата для списков существуют несколько других естественных форм их внешнего представления, которые в некоторых ситуациях являются более предпочтительными. Следующая процедура<br>   вывспис( L)<br>   выводит список L так, что каждый его элемент занимает отдельную строку:<br>   вывспис( []).<br>   вывспис( [X | L) :-<br>    write( X), nl,<br>    вывспис( L).<br>   Если у нас есть список списков, то одной из естественных форм его выводе является такая, при которой все элементы каждого списка записываются на отдельной строке. Для этого мы определим процедуру вывспис2. Вот пример ее использования:<br>   ?- вывспис2( [ [а, b, с], [d, e, f], [g, h, i] ] ).<br>
		 <br>   а b с<br>   d e f<br>   g h i<br>   Процедура, выполняющая эту работу, такова:<br>   вывспис2( []).<br>   вывспис2( [L | LL] ) :-<br>    строка( L), nl,<br>    вывспис1( LL).<br>
		 <br>   строка( []).<br>   строка( [X | L] ) :-<br>    write( X), tab( 1),<br>    строка( L).<br>   Список целых чисел иногда удобно представить в виде диаграммы. Следующая процедура диагр выводит список в такой форме (предполагается, что числа списка заключены между 0 и 80). Пример ее использования:<br>   ?- диагр( [3, 4, 6, 5] ).<br>
		 <br>   ***<br>   ****<br>   ******<br>   *****<br>   Процедуру диагр можно определить так:<br>   диагр( [N | L]) :-<br>    звездочки( N), nl,<br>    диагр( L).<br>
		 <br>   звеэдочки( N) :-<br>    N &gt; 0,<br>    write( *),<br>    N1 is N - 1,<br>    звездочки( N1).<br>   звездочки( N) :-<br>    N =&lt; 80.<br></div>
<h4 align="center">
<a name="TOC_id3586773"></a>6.2.3. Формирование термов<br></h4>
<div>   Предположим, наша программа имеет дело с семьями, которые представлены в виде термов так, как это сделано в гл. 4 (рис. 4.1). Тогда, если, переменная F конкретизирована термом, изображенный на рис. 4.1, то цель<br>   write( F)<br>   вызовет вывод этого терма в стандартной форме примерно так:<br>   семья( членсемьи( том, фокс, дата( 7, май, 1950),<br>    работает( bbс, 15200)),<br>    членсемьи( энн, фокс, дата( 9, май, 1951),<br>     неработает),<br>    [членсемьи( пат, фокс, дата( 5, май, 1973),<br>      неработает),<br>     членсемьи( джим, фокс, дата( 5, май, 1973),<br>      неработает)])<br>
		 <br>   родители<br>    том фокс, датарожд 7 май 1950, работает bbс,<br>     оклад 15200<br>    энн фокс, датарожд 9 май 1951, неработает<br>   дети<br>    пат фокс, датарожд 5 май 1973, неработает<br>    джим фокс, датарожд 5 май 1973, неработает<br>   <b>Рис. 6.2.</b> Улучшенный формат вывода термов, представляющих семью.<br>
		 <br>   Здесь содержится полная информация, однако форма представления легко может запутать, поскольку трудно проследить, какие ее части образуют самостоятельные семантические единицы. Поэтому обычно предпочитают выводить такую информацию в каком-либо формате, например так, как показано на рис. 6.2. Процедура<br>   вывсемью( F)<br>   с помощью которой это достигается, приведена на рис. 6.3.<br>
		 <br>   вывсемью( семья ( Муж, Жена, Дети) :-<br>    nl, write( родители), nl, nl,<br>    вывчленсемьи( Муж), nl,<br>    вывчленсемьи( Жена), nl, nl,<br>    write( дети), nl, nl,<br>    вывчленсемьи( Дети).<br>
		 <br>   вывчленсемьи( членсемьи( Имя, Фамилия, дата( Д, М, Г), Работа) ) :-<br>    tab(4), write( Имя),<br>    tab(1), write( Фамилия),<br>    write( ', дата рождения'),<br>    write( Д), tab( 1),<br>    write( M), tab( 1),<br>    write( Г), write( ','),<br>    вывработу( Работа).<br>
		 <br>   вывсписчлсемьи( []).<br>   вывсписчлсемьи( [P | L]) :-<br>    вывчленсемьи( P), nl,<br>    вывсписчлсемьи( L).<br>
		 <br>   вывработу( неработает) :-<br>    write( неработает).<br>   вывработу( работает Место, Оклад) ) :-<br>    write(' работает '), write( Место),<br>    write( ', оклад '), write( Оклад).<br>   <b>Рис. 6.3.</b>  Программа, обеспечивающая вывод в формате, представленном на рис. 6.2.<br></div>
<h4 align="center">
<a name="TOC_id3586988"></a>6.2.4. Обработка произвольного файла термов<br></h4>
<div>   Типичная последовательность целей для обработки файла F от начала до конца будет выглядеть примерно так:<br>   ... , see( F), обработкафайла, sеe( user), ...<br>   Здесь обработкафайла — процедура, которая читает и обрабатывает последовательно каждый терм файла F один за другим до тех пор, пока не встретится конец файла. Приведем типичную схему для процедуры обработкафайла:<br>   обработкафайла :-<br>    read( Терм),<br>    обработка( Терм).<br>
		 <br>   обработка( end_of_file) :- !.<br>    % Все сделано<br>   обработка( Терм) :-<br>    обраб( Терм),<br>     % Обработать текущий элемент<br>    обработкафайла.<br>     % Обработать оставшуюся часть файла<br>   Здесь обраб( Терм) представляет процедуру обработки отдельного терма. В качестве примера такой обработки рассмотрим процедуру, которая выдает на терминал каждый терм вместе с его порядковым номером. Назовем эту процедуру показфайла. У нее должен быть дополнительный аргумент для подсчета прочитанных термов:<br>   показфайла( N) :-<br>    read( Терм),<br>    показ( Терм, N).<br>
		 <br>   показ( Терм, N) :- !<br>    write( N), tab( 2), write( Терм),<br>    N1 is N + 1,<br>    показфайла( N1).<br>   Вот другой пример программы обработки файлов, построенной по подобной схеме. Пусть есть файл с именем файл1, термы которого имеют форму<br>   изделие( НомерИзд, Описание, Цена, ИмяПоставщика)<br>   Каждый терм описывает одну строку каталога изделий. Нужно построить новый файл. содержащий только те изделия, которые выпускаются каким-то конкретным поставщиком. Поскольку поставщик в этом новом файле у всех изделий будет одинаков, его имя нужно записать только один раз в самом начале и убрать из всех остальных термов. Процедура будет называться<br>   создатьфайл( Поставщик)<br>   Например, если исходный каталог хранится в файле файл1, а мы хотим создать специальный каталог в файле файл2, содержащий всю информацию о том, что поставляет Гаррисон, тогда мы применим процедуру создатьфайл следующим образом:<br>   ?- seе( файл1), tеll( файл2), создатьфайл( гаррисон),<br>    see( user), tell( user).<br>   Процедуру создатьфайл можно определить так:<br>   создатьфайл( Поставщик) :-<br>    write( Поставщик), write( '.'), nl,<br>    создатьостальное( Поставщик).<br>
		 <br>   создатьостальное( Поставщик) :-<br>    read( Изделие),<br>    обработать( Изделие, Поставщик).<br>
		 <br>   обработать( end_ot_file) :- !.<br>   обработать( Изделие( Ном, Опис, Цена, Поставщик),<br>    Поставщик) :- !,<br>    write( Изделие( Ном, Опис, Цена) ),<br>    write( '.'), nl,<br>    создатьостальное( Поставщик).<br>
		 <br>   обработать ( _, Поставщик) :-<br>    создатьостальное( Поставщик).<br>   Обратите внимание на то, что обработать вписывает точки между термами, чтобы впоследствии файл мог быть прочитан процедурой read.<br><h5>Упражнения</h5>   <b>6.1.</b> Пусть f — файл термов. Определите процедуру<br>   найтитерм( Терм)<br>   которая выводит на терминал новый терм из f, сопоставимый с Терм'ом.<br>   <b>6.2.</b> Пусть f — файл термов. Напишите процедуру<br>   найтивсетермы( Терм)<br>   которая выводит на экран все термы из f, сопоставимые с Tepм'ом. Обеспечьте при этом, чтобы во время поиска Терм не конкретизировался (это могло бы помешать ему сопоставиться с другими термами дальше по файлу).<br></div>
</div>
<h3 align="center">
<a name="TOC_id3587297"></a>6.3. Обработка символов<br></h3>
<div>   Символ записывается в текущий выходной поток при помощи цели<br>   put( С)<br>   где С — символ, который нужно вывести, в кодировке ASCII (число от 0 до 127), например, вопрос<br>   ?- put( 65), put( 66), put( 67).<br>   породит следующий вывод:<br>   АВС<br>   65 — ASCII-код 'А', 66 — 'В', 67 — 'С'.<br>   Одиночный символ можно считать из текущего входного потока при помощи цели<br>   get0( С)<br>   Она вызывает чтение символа из входного потока, и переменная С конкретизируется ASCII-кодом этого символа. Вариантом предиката get0 является get, который используется для чтения символов, отличных от пробела. Поэтому цель<br>   get( С)<br>   вызовет пропуск всех непечатаемых символов (в частности пробелов) от текущей позиции во входном потоке до первого печатаемого символа. Этот символ затем тоже считывается и С конкретизируется его ASCII-кодом.<br>   В качестве примера использования предикатов, переносящих одиночные символы, давайте рассмотрим процедуру сжатие, выполняющую следующую работу: считывание из входного потока произвольного предложения и вывод его же, но в форматированном виде — все группы идущих подряд пробелов заменены на одиночные пробелы. Для простоты будем считать, что все предложения входного потока, обрабатываемые процедурой сжатие, оканчиваются точками, а слова в них отделены одно от другого одним или несколькими пробелами, и только ими. Тогда следующее предложение будет допустимым:<br>   Робот    пытался     налить    вина    из     бутылки.<br>   Цель сжатие выведет его в таком виде:<br>   Робот пытался налить вина из бутылки.<br>   Процедура сжатие будет иметь такую же структуру, как и процедуры обработки файлов из предыдущего раздела. Сначала она прочтет первый символ, выведет его, а затем завершит обработку, в зависимости от того, каким был этот символ. Есть три альтернативы, которые соответствуют следующим случаям: символ является точкой, пробелом или буквой. Взаимное исключение этих трех альтернатив обеспечивается в программе отсечениями:<br>   сжатие :-<br>    get0( С),<br>    put( С).<br>
		 <br>   сделатьостальное( С).<br>    сделатьостальное( 46) :- !.<br>     % 46 -АSСII-код точки, Все сделано<br>
		 <br>   сделатьостальное( 32) :- !,<br>     % 32 - ASCII-код пробела<br>    get( С),<br>    put( С),<br>    сделатьостальное( С).<br>
		 <br>   сделатьостальное( Буква) :-<br>    сжатие.<br><h5>Упражнение</h5>   <b>6.3.</b> Обобщите процедуру сжатие на случай запятых. Все пробелы, стоящие непосредственно перед запятой, нужно убрать, а после каждой запятой нужно поместить единственный пробел.<br></div>
<h3 align="center">
<a name="TOC_id3587472"></a>6.4. Создание и декомпозиция атомов<br></h3>
<div>   Часто желательно информацию, считанную как последовательность символов, иметь в программе в виде атома. Для этой цели существует встроенный предикат name. Он устанавливает взаимосвязь между атомами и их кодировкой в ASCII. Таким образом,<br>   name( A, L)<br>   истинно, если L — список кодов ASCII, кодирующих атом. Например,<br>   name( zx232, [122, 120, 50, 51, 50] )<br>   истинно. Существуют два типичных способа использования name:<br>   (1) дан атом, разбить его на отдельные символы;<br>   (2) дан список символов, объединить их в один атом.<br>   Примером первого случая применения предиката является программа, которая имеет дело с заказами такси и водителями. Все это представлено в программе атомами<br>   заказ1, заказ2, водитель1, водитель2, такси1, таксилюкс<br>   Предикат<br>   такси( X)<br>   проверяет, относится ли атом X к тем атомам, которые представляют такси:<br>   такси( X) :-<br>    name( X, Хспис),<br>    nаmе( такси, Тспис),<br>    конк( Тспис, _, Хспис).<br>
		 <br>   конк( [], L, L).<br>   конк( [А | L1], L2, [А | L3] ) :-<br>    конк( L1, L2, L3).<br>   Предикаты заказ и водитель можно определить аналогично.<br>   Наш следующий пример иллюстрирует применение объединения отдельных символов в один атом. Мы определим предикат<br>   читпредложение( Списслов)<br>   который считает предложение с произвольной формой на естественном языке и конкретизирует Списслов некоторым внутренним представлением этого предложения. В качестве внутреннего представления, обеспечивающего возможность дальнейшей обработки предложения, естественно избрать следующее: каждое слово входного предложения представляется прологовским атомом, а все предложение представляется списком этих атомов. Например, если входной поток таков:<br>   Мэри было приятно видеть неудачу робота.<br>   то цель читпредложение( Предложение) вызовет конкретизацию<br>   Предложение=['Мэри', было, приятно, видеть, неудачу, робота]<br>   Для простоты будем считать, что каждое предложение оканчивается точкой и внутри него не используются никакие знаки препинания.<br>   Программа для читпредложение показана на рис. 6.4. Вначале процедура читает текущий входной символ Симв, а затем передает его процедуре читостальное для завершения работы. Процедура читостальное должна правильно обработать следующие три случая:<br>   (1) Симв — точка, тогда все сделано.<br>   (2) Симв — пробел, — игнорировать его и читпредложение от остального ввода.<br>   (3) Симв — буква, — сначала считать слово Слово, которое начинается с Симв, а затем запустить читпредложение, чтобы считать оставшуюся часть предложения, породив при этом Списслов. Общим результатом этого будет список [Слово | Списслов].<br>   Процедура, считывающая символы одного слова, такова:<br>   читбуквы( Буква, Буквы, Сделсимв)<br>   Ее три аргумента:<br>   (1) Буква — текущая буква (уже считанная) читаемого слова.<br>   (2) Буквы — список букв (начинающийся с буквы Буква), оставшихся до конца слова.<br>   (3) Следсимв — входной символ, непосредственно следующий за читаемым словом. Следсимв не должен быть буквой.<br>   Мы завершим данный пример замечанием о возможном применения процедуры читпредложение. Ее можно использовать в программе обработки текста на естественном языке. Предложения, представленные в виде списков слов, имеют удобную форму для дальнейшей обработки при помощи Пролога. В простейшем случае такой обработкой мог бы быть поиск во входном предложении определенных ключевых слов. Значительно более сложной задачей является понимание предложения, т.е. извлечение из него смысла, представленного в некотором избранном формализме. Это важная область исследований в искусственном интеллекте.<br>
		 <br>   /*<br>   Процедура читпредложение считывает предложение<br>   и из его слов создает список атомов. Например,<br>    читпредложение( Списслов)<br>   порождает<br>    Списслов=['Мэри', было, приятно, видеть, неудачу, робота]<br>   если входным было предложение<br>    Мэри было приятно видеть неудачу робота.<br>   */<br>   читпредложение( Списслов) :-<br>    gеt0( Симв),<br>    читостальное( Симв, Списслов).<br>
		 <br>   читостальное( 46, []) :- !.<br>     % Конец предложения: 46 = ASCII-код для '.'<br>    читостальное( 32, Списслов) :- !,<br>     % 32 = ASCII-код для пробела<br>    читпредложение( Списслов).<br>     % Пропустить пробел<br>
		 <br>   читостальное( Буква, [Слово | Списслов]) :-<br>    читбуквы( Буква, Буквы, Следсимв),<br>     % Считать буквы текущего слова<br>    nаmе( Слово, Буквы),<br>     читостальное( Следсимв, Списслов).<br>
		 <br>   читбуквы( 46, [], 46) :- !.<br>    % Конец слова: 46 = точка<br>   читбуквы( 32, [], 32) :- !.<br>    % Конец слова: 32 = пробел<br>   читбуквы( Бкв, [Бкв | Буквы], Следсимв) :-<br>    get0( Симв),<br>    читбуквы( Симв, Буквы, Следсимв).<br>   <b>Рис. 6.4.</b> Процедура для преобразования предложения в список атомов.<br>
		 <br><h5>Упражнения</h5>   <b>6.4.</b> Определите отношение<br>   начинается( Атом, Символ)<br>   для проверки, начинается ли Атом с символа Символ.<br>   <b>6.5.</b> Определите процедуру plural, которая преобразует английские существительные из единственного числа во множественное, добавляя к слову окончание s. Например:<br>   ?- plural( table, X).<br>   X  =  tables<br>   <b>6.6.</b> Напишите процедуру<br>   поиск( Ключслово, Предложение)<br>   которая при каждом вызове находит в текущем входном файле предложение, содержащее заданное ключевое слово Ключслово. Предложение в своей исходной форме должно быть представлено в виде последовательности символов или в виде атома (процедуру читпредложение из данного раздела можно соответственно модифицировать).<br></div>
<h3 align="center">
<a name="TOC_id3587954"></a>6.5. Ввод программ: <i>consult, reconsult</i><br></h3>
<div>   Передавать программы пролог-системе можно при помощи двух встроенных предикатов: consult и reconsult. Чтобы система считала программу из файла F, нужно поставить цель<br>   ?- consult( F).<br>   В результате все предложения программы, содержащейся в F, будут использованы пролог-системой при ответе на дальнейшие вопросы пользователя. Если позже в том же сеансе произойдет "консультация" с другим файлом, предложения этого нового файла будут просто добавлены в конец текущего множества предложений.<br>   Для того, чтобы запустить программу, не обязательно записывать ее в файл, а затем "консультироваться" с ним. Вместо чтения файла система может принимать программу прямо с терминала, который соответствует псевдофайлу user. Добиться этого можно так:<br>   ?- consult( user).<br>   После этого система будет ожидать ввода предложений программы с терминала.<br>   В некоторых пролог-системах применяется сокращенная запись для чтения программ из файлов. Файлы, из которых предстоит чтение, просто помещаются в список и этот список используется в качестве цели. Например:<br>   ?- [файл1, файл2, файл3].<br>   Это в точности эквивалентно следующим трем целям:<br>   ?-  соnsult( файл1), соnsult( файл2), соnsult( файл3).<br>   Встроенный предикат reconsult аналогичен consult. Цель<br>   ?- reconsult( F).<br>   даст тот же эффект, что и consult( F) с одним исключением. Если в F есть предложения, касающиеся отношений, которые уже были определены ранее, старые определения заменяются на новые из F. Разница между consult и reconsult в том, что consult всегда добавляет новые предложения, в то время как reconsult переопределяет ранее введенные определения. Однако reconsult не произведет никакого эффекта на те отношения, о которых в F ничего не сказано.<br>   Следует еще раз заметить, что детали "консультирования" с файлами зависят от конкретной реализации Пролога. Это замечание касается и большинства остальных встроенных процедур.<br></div>
<h3 align="center">
<a name="TOC_id3588074"></a>Резюме<br></h3>
<div>   • Ввод и вывод (отличный от связанного с вопросами к программе) осуществляется посредством встроенных процедур. В данной главе описан простой и практичный набор таких процедур, имеющихся во многих реализациях Пролога.<br>   • Файлы являются последовательными. Существуют <i>текущие входной</i> и <i>выходной потоки</i>. Пользовательский терминал рассматривается как файл с именем user.<br>   • Переключение между потоками осуществляется с помощью процедур:<br>   sее( Файл)<br>    Файл становится текущим входным потоком<br>   tell( Файл)<br>    Файл становится текущим выходным потоком<br>   seen<br>    закрывается текущий входной поток<br>   told<br>    закрывается текущий выходной поток<br>   • Файлы читаются и записываются двумя способами:<br>     как последовательности символов<br>     как последовательности термов<br>   Встроенные процедуры для чтения и записи символов и термов таковы:<br>   rеad( Терм)<br>     вводит следующий терм<br>   write( Терм)<br>     выводит Терм<br>   put( КодСимвола)<br>     выводит символ с заданным ASCII-кодом<br>   get0( КодСимвола)<br>     вводит следующий символ<br>   gеt( КодСимвола) <br>     вводит ближайший следующий "печатаемый" символ<br>   • Две процедуры облегчают форматирование:<br>   nl      начинает новую строку<br>   tab( N) выводит N пробелов<br>   • Процедура nаmе( Атом, СписокКодов) осуществляет синтез и декомпозицию атомов. СписокКодов — список ASCII кодов символов, образующих Атом. <br></div>
</div>
<h2 align="center">
<a name="TOC_id3588224"></a>Глава 7<br>Другие встроенные процедуры<br></h2>
<div>
<div>   В данной главе мы изучим некоторые другие, не упоминавшиеся ранее встроенные процедуры, предназначенные для более серьезного программирования на Прологе. Эта новые процедуры дают возможность запрограммировать операции, которые известными нам средствами запрограммировать невозможно. Один набор таких процедур касается обработки термов: эти процедуры проверяют, была ли некоторая переменная конкретизирована целым числом, они разбирают термы на части, конструируют новые термы и т.д. Другой полезный набор процедур работает с "базой данных": процедуры из этого набора добавляют новые отношения в программу или удаляют из нее существующие.<br>   Множество встроенных процедур сильно зависит от конкретной реализации Пролога. Однако процедуры, обсуждаемые в данной главе, имеются во многих реализациях. Различные реализации могут иметь свои наборы дополнительных средств.<br></div>
<h3 align="center">
<a name="TOC_id3588252"></a>7.1. Проверка типов термов <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3588258"></a>7.1.1. Предикаты <i>var</i>, <i>nоnvar</i>, <i>atom</i>, <i>integer</i>, <i>atomic</i><br></h4>
<div>   Термы бывают разных типов: переменные, целые числа, атомы и т.д. Если терм — переменная, то в некоторый момент выполнения программы он может оказаться конкретизированным или не конкретизированным. Далее, если он конкретизирован, то его значение может быть атомом, структурой и т.п. Иногда бывает полезно узнать, каков тип этого значения. Например, пусть мы хотим сложить значения двух переменных X и Y:<br>   Z is X + Y<br>   Перед вычислением этой цели необходимо, чтобы X и Y были конкретизированы целыми числами. Если у нас нет уверенности в том, что X и Y действительно конкретизированы целыми числами, то перед выполнением арифметического действия нужно проверить это программно.<br>   Для этого следует воспользоваться встроенным предикатом integer (целое). Предикат integer( X) принимает значение истина, если X — целое или если X — переменная, имеющая целое значение. Будем говорить в этом случае, что X "обозначает" целое. Цель для сложения X и Y можно тогда "защитить" такой проверкой переменных X и Y:<br>   ..., integer( X), integer( Y), Z is X + Y, ...<br>   Если неверно, что X и Y оба являются целыми, то система и не будет пытаться их сложить. Таким образом, цели integer "охраняют" цель Z is X + Y от бессмысленного вычисления.<br>   Встроенные предикаты этого типа таковы: var (переменная), nonvar (непеременная), atom (атом), integer (целое), atomic (атомарный). Они имеют следующий смысл:<br>   var( X)<br>   Эта цель успешна, если X в текущий момент — не конкретизированная переменная.<br>   nonvar( X)<br>   Эта цель успешна, если X — терм, отличный от переменной, или если X — уже конкретизированная переменная.<br>   atom( X)<br>   Эта цель истинна, если X обозначает атом.<br>   integer( X)<br>   Цель истинна, если X обозначает целое.<br>   atomic( X)<br>   Цель истинна, если X обозначает целое или атом.<br>   Следующие примеры вопросов к пролог-системе иллюстрируют применение этих встроенных предикатов:<br>   ?- var( Z), Z = 2.<br>   Z = 2<br>
		 <br>   ?- Z = 2, var( Z).<br>   no<br>
		 <br>   ?- integer( Z), Z = 2.<br>   no<br>
		 <br>   ?- Z = 2, integer( Z), nonvar( Z).<br>   Z = 2<br>
		 <br>   ?- atom( 22).<br>   no<br>
		 <br>   ?- atomic( 22).<br>   yes<br>
		 <br>   ?- atom( ==&gt;).<br>   yes<br>
		 <br>   ?- atom( p( 1) ).<br>   no<br>   Необходимость в предикате atom продемонстрируем на следующем примере. Пусть мы хотим подсчитать, сколько раз заданный атом встречается в некоторой списке объектов. Для этого мы определим процедуру<br>   счетчик( А, L, N)<br>   где А — атом, L — список и N — количество вхождений этого атома. В качестве первой попытки можно было бы определить счетчик так:<br>   счетчик( _, [], 0).<br>   счетчик( A, [A | L], N) :- !,<br>    счетчик( A, L, N1),<br>     % N1 - число вхождений атома в хвост<br>    N is N1 + 1.<br>   счетчик( А, [ _ | L], N) :-<br>    счетчик( A, L, N).<br>   Теперь на нескольких примерах посмотрим, как эта процедура работает:<br>   ?- счетчик( а, [а, b, а, а], N).<br>   N = 3<br>
		 <br>   ?- счетчик( a, [a, b, X, Y], Na).<br>   Na = 3<br>   ...<br>
		 <br>   ?- счетчик( b, [a, b, X, Y], Nb).<br>   Nb = 3<br>   ...<br>
		 <br>   ?- L=[a, b, X, Y], счетчик( а, L, Na), счетчик( b, L, Nb).<br>   Na = 3<br>   Nb = 1<br>   X = a<br>   Y = a<br>   ...<br>   В последнем примере как X, так и Y после конкретизации получили значение а, и поэтому Nb оказалось равным только 1, однако мы хотели не этого. Нас интересовало количество реальных появлений конкретного <i>атома</i>, а вовсе не число термов, <i>сопоставимых</i> с этим атомом. В соответствии с этим более точным определением отношения счетчик мы должны теперь проверять, является ли голова списка атомом. Усовершенствованная программа выглядит так:<br>   счетчик( _, [], 0).<br>   счетчик( А, [В | L], N) :-<br>    atom( В), А = В, !, % B равно атому А?<br>   счетчик( A, L, N1),  % Подсчет в хвосте<br>    N is N1 + 1;<br>   счетчик( А, L, N).<br>     % Иначе - подсчитать только в хвосте<br>   В следующем более сложном упражнении по программированию числовых ребусов используется предикат nonvar.<br></div>
<h4 align="center">
<a name="TOC_id3588660"></a>7.1.2. Решение числового ребуса с использованием <i>nonvar</i><br></h4>
<div>   Известным примером числового ребуса является<br>   D O N A L D<br>   +<br>   G E R A L D<br>   -----------<br>   R O B E R T<br>   Задача состоит в том. чтобы заменить буквы D, О, N и т.д. на цифры таким образом, чтобы вышеприведенная сумма была правильной. Разным буквам должны соответствовать разные цифры, иначе возможно тривиальное решение, например, все буквы можно заменить на нули.<br>   Определим отношение<br>   сумма( N1, N2, N)<br>   где N1, N2 и N представляют три числа данного ребуса. Цель cyммa(N1, N2, N) достигается, если существует такая замена букв цифрами, что N1+N2 = N.<br>   Первым шагом к решению будет выбор представления чисел N1, N2 и N в программе. Один из способов - представить каждое число в виде списка его цифр. Например, число 255 будет тогда представляться списком [2, 2, 5]. Поскольку значения цифр нам не известны заранее, каждая цифра будет обозначаться соответствующей неинициализированной переменной. Используя это представление, мы можем сформулировать задачу так:<br>     [ D, O, N, A, L, D ]<br>   + [ G, E, R, A, L, D ]<br>   = [ R, О, B, E, R, T ]<br>   Теперь задача состоит в том. чтобы найти такую конкретизацию переменных D, О, N и т.д., для которой сумма верна. После того, как отношение сумма будет запрограммировано, задание для пролог-системы на решение ребуса будет иметь вид<br>   ?- сумма( [D, O, N, A, L, D], [G, E, R, A, L, D],<br>    [R, O, В, E, R, T ).<br><div align="center"><img border="1" src="_47.png"></div>   <b>Рис. 7.1. </b>Поразрядное сложение. Отношения в показанном i-м разряде такие: D<sub>3i </sub>= (C1 + D<sub>1i</sub> + D<sub>2i</sub>) mod 10; C = (C1 + D<sub>1i</sub> + D<sub>2i</sub>) div 10 (div — целочисленное деление, mod — остаток от деления).<br>   Для определения отношения сумма над списками цифр нам нужно запрограммировать реальные правила суммирования в десятичной системе счисления. Суммирование производится цифра за цифрой, начиная с младших цифр в сторону старших, всякий раз учитывая цифру переноса справа. Необходимо также сохранять множество допустимых цифр, т.е. цифр, которые еще не были использованы для конкретизации уже встретившихся переменных. Поэтому, вообще говоря, кроме трех чисел N1, N2 и N в рассмотрении должна участвовать некоторая дополнительная информация, как показано на рис. 7.1:<br>   • перенос перед сложением<br>   • перенос после сложения<br>   • множество цифр, доступных перед сложением<br>   • оставшиеся цифры, не использованные при сложении<br>   Для формулировки отношения сумма мы снова воспользуемся принципом обобщения задачи: введем вспомогательное, более общее отношение сумма1. Это отношение будет иметь несколько дополнительных аргументов, соответствующих той дополнительной информации, о которой говорилось выше:<br>   сумма1( N1, N2, N, C1, С, Цифры1, Цифры)<br>   Здесь N1, N2 и N — наши три числа, как и в отношении сумма, C1 — перенос справа (до сложения N1 и N2), а С — перенос влево (после сложения). Пример:<br>   ?- сумма1( [H, E], [6, E], [U, S], 1, 1,<br>    [1, 3, 4, 7, 8, 9], Цифры ).<br>
		 <br>   H = 8<br>   E = 3<br>   S = 7<br>   U = 4<br>   Цифры = [1, 9]<br>   Если N1 и N удовлетворяют отношению сумма, то, как показано на рис. 7.1, C1 и С должны быть равны 0. Цифры1 — список цифр, которые не были использованы для конкретизации переменных. Поскольку мы допускаем использование в отношении сумма любых цифр, ее определение в терминах отношения сумма1 выглядит так:<br>   сумма( N1, N2, N) :-<br>    cyммa1( N1, N2, N, 0, 0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).<br>   Бремя решения задачи переложено теперь на отношение сумма1. Но это отношение является уже достаточно общим, чтобы можно было определить его рекурсивно. Без ограничения общности мы предположим, что все три списка, представляющие три числа, имеют одинаковую длину. Наш пример, конечно, удовлетворяет этому условию, но если это не так, то всегда можно приписать слева нужное количество нулей к более "короткому" числу.<br>   Определение отношения сумма1 можно разбить на два случая:<br>   (1) Все три числа представляются пустыми списками. Тогда<br>   сумма1( [], [], [], 0, 0, Циф, Циф).<br>   (2) Все три числа имеют какую-то самую левую цифру и справа от нее - остальные цифры. То есть, они имеют вид:<br>   [D1 | N1], [D2 | N2], [D | N]<br>   В этом случае должны выполняться два условия:<br>    (а) Оставшиеся цифры, рассматриваемые как три числа N1, N2 и N, сами должны удовлетворять отношению сумма1, выдавая влево некоторый перенос C2 и оставляя некоторое подмножество неиспользованных цифр Циф2.<br>    (b) Крайние левые цифры D1, D2 и D, а также перенос C2 должны удовлетворять отношению, показанному на рис. 7.1: C2, D1 и D2 складываются, давая в результате D и перенос влево. Это условие в нашей программе формулируется в виде отношения суммацифр.<br>   Переводя это на Пролог, получаем:<br>   сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-<br>    сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),<br>    суммацифр( D1, D2, C2, D, С, Циф2, Циф).<br>   Осталось только описать на Прологе отношение суммацифр. В его определении есть одна тонкая деталь, касающаяся применения металогического предиката nonvar. D1, D2 и D должны быть десятичными цифрами. Если хоть одна из этих переменных еще не конкретизирована, ее нужно конкретизировать какой-нибудь цифрой из списка Циф2. Как только такая конкретизация произошла, эту цифру нужно удалить из множества доступных цифр. Если D1, D2 и D уже конкретизированы, тогда, конечно, ни одна из доступных цифр "потрачена" не будет. В программе эти действия реализуются при помощи недетерминированного вычеркивания элемента списка. Если этот элемент - не переменная, ничего не вычеркивается (конкретизации не было). Вот эта программа:<br>   удалить( Элемент, Список, Список) :-<br>    nonvar( Элемент), !.<br>   удалить( Элемент, [Элемент | Список ], Список).<br>   удалить(Элемент, [А | Список], [А | Список1]) :-<br>    удалить( Элемент, Список, Список1).<br>   Полная программа для решения арифметических ребусов приводится на рис. 7.2. В программу включены также определения двух ребусов. Вопрос к пролог-системе для ребуса про DONALD'a, GERALD'a и ROBERT'a с использованием этой программы выглядит так:<br>   ?- ребус1( N1, N2, N), сумма( N1, N2, N).<br>
		 <br>   % Решение числовых ребусов<br>   сумма( N1, N2, N) :-<br>     % Числа представлены в виде списков цифр<br>    сумма1( N1, N2, N,<br>     0, 0,<br>      % Перенос справа и перенос влево равны 0<br>     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).<br>      % Все цифры доступны<br>
		 <br>   сумма1( [], [], [], 0, 0, Цифры, Цифры).<br>   сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-<br>    сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),<br>    суммацифр( Dl, D2, C2, С, Циф2, Циф).<br>
		 <br>   суммацифр( Dl, D2, C1, D, С, Циф1, Циф) :-<br>    удалить( D1, Циф1, Циф2),<br>     % Выбор доступной цифры для D1<br>    удалить( D2, Циф2, Циф3),<br>     % Выбор доступной цифры для D2<br>    удалить( D, Циф3, Циф),<br>     % Выбор доступной цифры для D<br>    S is D1 + D2 + C1,<br>    D is S mod 10,<br>    С is S div 10.<br>
		 <br>   удалить( A, L, L) :-<br>    nonvar( A), !.<br>     % Переменная А уже конкретизирована<br>   удалить( А, [А | L], L).<br>   удалить( А, [В | L], [В | L1]) :-<br>    удалить( A, L, L1).<br>
		 <br>   % Примеры ребусов<br>   ребус1( [D, O, N, A, L, D],<br>    [G, E, R, A, L, D],<br>    [R, O, B, E, R, T].<br>
		 <br>   ребус2( [0, S, E, N, D],<br>    [0, M, O, R, E],<br>    [M, O, N, E, Y].<br>   <b>Рис. 7.2.</b>  Программа для арифметических ребусов.<br>
		 <br>   Иногда этот ребус упрощают, сообщая часть решения в виде дополнительного ограничения, например D равно 5. В такой форме ребус можно передать пролог-системе при помощи сумма1:<br>   ?- сумма1( [5, O, N, A, L, 5],<br>    [G, E, R, A, L, 5],<br>    [R, O, B, E, R, T],<br>    0, 0, [0, 1, 2, 3, 4, 6, 7, 8, 9], _ ).<br>   Интересно, что в обоих случаях существует только одно решение, т.е. только один способ заменить буквы цифрами.<br><h5>Упражнения</h5>   <b>7.1.</b> Напишите процедуру упростить для упрощения алгебраических сумм, в которых участвуют числа и символы (строчные буквы). Пусть эта процедура переупорядочивает слагаемые так, чтобы символы предшествовали числам. Вот примеры ее использования:<br>   ?- упростить( 1 + 1 + а, E).<br>   E = а + 2<br>
		 <br>   ?- упростить( 1 + a + 4 + 2 + b + с, E).<br>   E = а + b + с + 7<br>
		 <br>   ?- упростить( 3 + x + x, E).<br>   E = 2*x + 3<br>   <b>7.2.</b> Определите процедуру<br>   добавить( Элемент, Список)<br>   для добавления нового элемента в список. Предполагается, что все элементы, хранящиеся в списке, — атомы. Список состоит из всех хранящихся в нем элементов, а за ними следует хвост, который не конкретизирован и служит для принятия новых элементов. Пусть, например, в списке уже хранятся а, b и с, тогда<br>   Список = [а, b, с | Хвост]<br>   где Хвост — переменная. Цель<br>   добавить( d, Список)<br>   вызовет конкретизацию<br>   Xвoст = [d | НовыйХвост] и<br>   Список = [а, b, с, d | НовыйХвост]<br>   Таким способом структура может наращиваться, включая в себя новые элементы. Определите также соответствующее отношение принадлежности.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3589329"></a>7.2. Создание и декомпозиция термов: <i>=.., functor, arg, name</i><br></h3>
<div>   Имеются три встроенные предиката для декомпозиции и синтеза термов: functor, arg и =... Рассмотрим сначала отношение =.., которое записывается как инфиксный оператор. Цель<br>   Терм =.. L<br>   истинна, если L — список, начинающийся с главного функтора терма Терм, вслед за которым идут его аргументы. Вот примеры:<br>   ?- f( а, b) =.. L.<br>   L = [f, а, b]<br>
		 <br>   ?- T =.. [прямоугольник, 3, 5].<br>   T = прямоугольник( 3, 5)<br>
		 <br>   ?- Z =.. [p, X, f( X,Y) ].<br>   Z = p( X, f( X,Y) )<br>   Зачем может понадобиться разбирать терм на составляющие компоненты — функтор и его аргументы? Зачем создавать новый терм из заданного функтора и аргументов? Следующий пример показывает, что это действительно нужно.<br>   Рассмотрим программу, которая манипулирует геометрическими фигурами. Фигуры — это квадраты, прямоугольники, треугольники, окружности в т.д. В программе их можно представлять в виде термов, функтор которых указывает на тип фигуры, а аргументы задают ее размеры:<br>   квадрат( Сторона)<br>   треугольник( Сторона1, Сторона2, Сторона3)<br>   окружность( R)<br>   Одной из операций над такими фигурами может быть увеличение. Его можно реализовать в виде трехаргументного отношения<br>   увел( Фиг, Коэффициент, Фиг1)<br>   где Фиг и Фиг1 — геометрические фигуры одного типа (с одним в тем же функтором), причем параметры Фиг1 равны параметрам Фиг, умноженным на Коэффициент. Для простоты будем считать, что все параметры Фиг, а также Коэффициент уже известны, т.е. конкретизированы числами. Один из способов программирования отношения увел таков:<br>   увел( квадрат( A), F, квадрат( А1) ) :-<br>    A1 is F*A<br>
		 <br>   увел( окружность( R), F, окружность( R1) ) :-<br>    R1 is F*R1<br>
		 <br>   увел( прямоугольник( А, В), F, прямоугольник( А1, В1)) :-<br>    A1 is F*A, B1 is F*B.<br>   Такая программа будет работать, однако она будет выглядеть довольно неуклюже при большом количестве различных типов фигур. Мы будем вынуждены заранее предвидеть все возможные типы, которые могут когда-либо встретиться. Придется заготовить по предложению на каждый тип, хотя во всех этих предложениях по существу говорится одно и то же: возьми параметры исходной фигуры, умножь их на коэффициент и создай фигуру того же типа с этими новыми параметрами.<br>   Ниже приводится программа, в которой делается попытка (неудачная) справиться для начала хотя бы со всеми однопараметрическими фигурами при помощи одного предложения:<br>   увел( Тип( Пар), F, Тип( Пар1) ):-<br>    Пар1 is F*Пар.<br>   Однако в Прологе подобные конструкции, как правило, запрещены, поскольку функтор должен быть атомом, и, следовательно, переменная Тип синтаксически не будет воспринята как функтор. Правильный метод — воспользоваться предикатом '=..'. Тогда процедура увел будет иметь обобщенную формулировку, пригодную для фигур любых типов:<br>   увел( Фиг, F, Фиг1):-<br>    Фиг =.. [Тип | Параметры],<br>    умножспис( Параметры, F, Параметры1),<br>    Фиг1 =.. [Тип | Параметры)].<br>
		 <br>   умножспис( [], _, []).<br>   умножспис( [X | L], F, [X1 | L1] ) :-<br>    X1 is F*X, умножспис( L, F, L1).<br>   Наш следующий пример использования предиката '=..' связан с обработкой символьных выражений (формул), где часто приходится подставлять вместо некоторого подвыражения другое выражение. Мы определим отношение<br>   подставить( Подтерм, Терм, Подтерм1, Терм1)<br>   следующим образом: если все вхождения Подтерм'а в Терм заменить на Подтерм1, то получится Терм1. Например:<br>   ?- подставить( sin( x), 2*sin( x)*f( sin( x)), t, F ).<br>   F = 2*t*f( t)<br>   Под "вхождением" Подтерм'а в Терм мы будем понимать такой элемент Терм'а, который <i>сопоставим</i> с Подтерм'ом. Вхождения будем искать сверху вниз. Поэтому цель<br>   ?- подставить( а+b, f( а, А+В), v, F).<br>   даст результат<br>   F = f( а, v)<br>   А = а<br>   В = b<br>   а не<br>   F = f( a, v + v)<br>   А = а + b<br>   В = а + b<br>   При определении отношения подставить нам нужно рассмотреть несколько случаев и для каждого принять свое решение:<br>   если Подтерм = Терм, то Терм1 = Подтерм1;<br>   иначе если Терм — "атомарный" (не структура),<br>    то Терм1 = Терм (подставлять нечего),<br>    иначе подстановку нужно выполнить над аргументами Tерм'a.<br>   Эти правила можно превратить в программу, показанную на рис. 7.3.<br>   Термы, полученные при помощи предиката '=..', разумеется, можно использовать и в качестве целей. Это дает возможность программе в процессе вычислений самой порождать и вычислять цели, структура которых не обязательно была известна заранее в момент написания программы. Последовательность целей, иллюстрирующая этот прием, могла бы выглядеть примерно так:<br>   получить( Функтор),<br>    вычислить( Списарг),<br>    Цель =.. [Функтор | Списарг],<br>    Цель<br>   Здесь получить и вычислить — некоторые определенные пользователем процедуры, предназначенные для вычисления компонент цели. После этого цель порождается предикатом '=..', а затем активизируется при помощи простого указания ее имени Цель.<br>
		 <br>   % Отношение<br>   %<br>   % подставить( Подтерм, Терм, Подтерм1, Терм1)<br>   %<br>   % состоит в следующем: если все вхождения Подтерм'а в Терм<br>   % заменить на Подтерм1, то получится Терм1.<br>
		 <br>   % Случай 1: Заменить весь терм<br>   подставить( Терм, Терм, Терм1, Терм1) :- !.<br>
		 <br>   % Случай 2: нечего подставлять<br>   подставить( _, Терм, _, Терм) :-<br>    atomic( Терм), !.<br>
		 <br>   % Случай 3: Проделать подстановку в аргументах<br>   подставить( Под, Терм, Под1, Терм1) :-<br>    Терм =.. [F | Арги],<br>     % Выделить аргументы<br>    подспис( Под, Арги, Под1, Арги1),<br>     % Выполнить над ними подстановку<br>    Терм1 =.. [F | Арги1].<br>
		 <br>   подспис( Под, [Терм | Термы], Под1, [Терм1 | Термы1]) :-<br>    подставить( Под, Терм, Под1, Терм1),<br>    подспис( Под, Термы, Под1, Термы1).<br>   <b>Рис. 7.3.</b>  Процедура подстановки в терм вместо одного из его подтермов некоторого другого подтерма.<br>
		 <br>   Некоторые реализации Пролога могут содержать требование, чтобы все цели, появляющиеся в программе, по своей <i>синтаксической</i> форме были либо атомами, либо структурами с атомом в качестве главного функтора. Поэтому переменная, вне зависимости от ее текущей конкретизации, может по своей синтаксической форме не подойти в качестве цели. Эту трудность можно обойти при помощи еще одного встроенного предиката call (вызов), чьим аргументом является цель, подлежащая вычислению. В соответствий с этим предыдущий пример должен быть переписан так:<br>   ...<br>   Цель = [Функтор | Списарг],<br>   саll( Цель)<br>   Иногда нужно извлечь из терма только его главный функтор или один из аргументов. В этом случае можно, конечно, воспользоваться отношением '=..'. Но более аккуратным и практичным, а также и более эффективным способом будет применение одной из двух новых встроенных процедур: functor и аrg. Вот их смысл: цель<br>   functor( Терм, F, N)<br>   истинна, если F — главный функтор Tepм'a, а N — арность F. Цель<br>   arg( N, Терм, А)<br>   истинна, если А — N-й аргумент в Терм'е, в предположении, что нумерация аргументов идет слева направо и начинается с 1. Примеры для иллюстрации:<br>   ?- functor( t( f( x), X, t), Фун, Арность).<br>   Фун = t<br>   Арность = 3<br>
		 <br>   ?- аrg( 2, f( X, t( a), t( b) ), Y).<br>   Y = t( a)<br>
		 <br>   ?- functor( D, дата, 3),<br>   arg( 1, D, 29),<br>   arg( 2, D, июнь),<br>   arg( 3, D, 1982).<br>   D = дата( 29, июнь, 1982)<br>   Последний пример иллюстрирует особый случай применения предиката functor. Цель functor( D, дата, 3) создает "обобщенный" терм с главным функтором дата и тремя аргументами. Этот терм обобщенный, так как все три его аргумента — не конкретизированные переменные, чья имена генерируются пролог-системой. Например:<br>   D = дата( _5, _6, _7)<br>   Затем эти три переменные конкретизируются при помощи трех целей аrg.<br>   К рассматриваемому множеству встроенных предикатов относится также и введенный в гл. 6 предикат name, предназначенный для синтеза и декомпозиция атомов. Для полноты изложения мы здесь напомним его смысл. Цель<br>   name( A, L)<br>   истинна, если L — список кодов (в кодировке ASCII) символов, входящих в состав атома А.<br><h5>Упражнения</h5>   <b>7.3.</b> Определите предикат конкрет(Терм) так, чтобы он принимал значение истина, когда в Tepм'e нет ни одной неконкретизированной переменной.<br>   <b>7.4.</b> Процедура подставить из данного раздела производит, при наличии разных вариантов, лишь самую "внешнюю" подстановку.<br>   Модифицируйте эту процедуру так, чтобы она находила все возможные варианты при помощи автоматического перебора. Например:<br>   ?- подставить( a+b, f( A+B), новый, НовыйТерм).<br>   А = а<br>   В = b<br>   НовыйТерм = f( новый);<br>
		 <br>   А = а+b<br>   В = а+b<br>   НовыйТерм = f( новый + новый)<br>   Наша исходная версия нашла бы только первый из этих двух ответов.<br>   <b>7.5. </b>Определите отношение<br>   включает( Tepм1, Терм2)<br>   которое выполняется, если Терм1 является более общим, чем Терм2. Например:<br>   ?- включает( X, с).<br>   yes<br>
		 <br>   ?- включает( g( X), g( t( Y))).<br>   yes<br>
		 <br>   ?- включает f( X,X), f( a,b)).<br>   no<br></div>
<h3 align="center">
<a name="TOC_id3590174"></a>7.3. Различные виды равенства<br></h3>
<div>   В каких случаях мы считаем, что два терма равны? До сих пор мы рассматривали три вида равенства в Прологе. Первый был связан с сопоставлением и записывался так:<br>   X = Y<br>   Это равенство верно, если X и Y сопоставимы. Следующий вид равенства записывался в виде<br>   X is E<br>   Такое равенство выполняется, если X сопоставим со значением арифметического выражения E. Мы также рассматривали равенства вида<br>   Е1 =:= Е2<br>   которые верны, если равны значения арифметических выражений Е1 и Е2. Наоборот, если значения двух арифметических выражений не равны, мы пишем<br>   Е1 =/= Е2<br>   Иногда нам может понадобиться более строгий вид равенства - <i>буквальное равенство</i> двух термов. Этот вид реализован еще одним встроенным предикатом, записываемым как инфиксный оператор '==':<br>   Т1 == Т2<br>   Это равенство выполняется, если термы Т1 и Т2 идентичны, т.е. имеют в точности одинаковую структуру, причем все соответствующие компоненты совпадают. В частности, должны совпадать и имена переменных. Отношение "не идентичны", дополнительное к данному, записывается так:<br>   T1 \== T2<br>   Приведем несколько примеров:<br>   ?- f( a, b) == f( а, b).<br>   yes<br>
		 <br>   ?- f( a, b) == f( a, X).<br>   nо<br>
		 <br>   ?- f( a, X) == f( a, Y).<br>   no<br>
		 <br>   ?- X \== Y.<br>   yes<br>
		 <br>   ?- t( X, f( a, Y) ) == t( X, f( a, Y) ).<br>   yes<br>   Давайте в качестве примера переопределим отношение<br>   счетчик( Терм, Список, N)<br>   из разд. 7.1. Пусть на этот раз N будет числом буквальных вхождений Терм'а в Список:<br>   счетчик( _, [], 0).<br>   счетчик( Терм, [Голова | L], N) :-<br>    Терм == Голова, !,<br>    счетчик( Терм, L, N1),<br>    N is N1 + 1;<br>   счетчик( Терм, L, N). <br></div>
<h3 align="center">
<a name="TOC_id3590335"></a>7.4. Работа с базой данных<br></h3>
<div>   Реляционная модель предполагает, что база данных — это описание некоторого множества отношений. Пролог-программу можно рассматривать как именно такую базу данных: описание отношений частично присутствует в ней в явном виде (факты), а частично — в неявном (правила). Более того, встроенные предикаты дают возможность корректировать эту базу данных в процессе выполнения программ. Это делается добавлением к программе (в процессе вычисления) новых предложений или же вычеркиванием из нее уже существующих. Предикаты, используемые для этой цели, таковы: assert (добавить), asserta, assertz и retract (удалить).<br>   Цель<br>   assert( С)<br>   всегда успешна, а в качестве своего побочного эффекта вызывает "констатацию" предложения С, т.е. добавление его к базе данных.<br>   Цель<br>   retract( С)<br>   приводит к противоположному эффекту: удаляет предложение, сопоставимое с С. Следующий диалог иллюстрирует их работу:<br>   ?- кризис.<br>   no<br>
		 <br>   ?- assert( кризис).<br>   yes<br>
		 <br>   ?- кризис.<br>   yes<br>
		 <br>   ?- retract( кризис).<br>   yes<br>
		 <br>   ?- кризис.<br>   no<br>   Предложения, добавленные к программе таким способом, ведут себя точно так же, как и те, что были в "оригинале" программы. Следующий пример показывает, как с помощью assert и retract можно работать в условиях изменяющейся обстановки. Предположим, что у нас есть такая программа о погоде:<br>   хорошая :-<br>    солнечно, not дождь.<br>
		 <br>   необычная :-<br>    солнечно, дождь.<br>
		 <br>   отвратительная :-<br>    дождь, туман.<br>
		 <br>   дождь.<br>
		 <br>   туман.<br>   Ниже приводится пример диалога с этой программой, во время которого база данных постепенно изменяется:<br>   ?- хорошая.<br>   no<br>
		 <br>   ?- отвратительная.<br>   yes<br>
		 <br>   ?- retract( туман).<br>   yes<br>
		 <br>   ?- отвратительная.<br>   no<br>
		 <br>   ?- assert( солнечно).<br>   yes<br>
		 <br>   ?- необычная.<br>   yes<br>
		 <br>   ?- retract( дождь).<br>   yes<br>
		 <br>   ?- хорошая.<br>   yes<br>   Добавлять и удалять можно предложения любой формы. Следующий пример показывает, что, кроме того, retract может работать недетерминировано: используя механизм возвратов с помощью только одной цели retract можно удалить целое множество предложений. Предположим, что в программе, с которой мы "консультируемся", есть такие факты:<br>   быстр( энн).<br>   медл( том).<br>   медл( пат).<br>   К этой программе можно добавить правило:<br>   ?- assert(<br>    ( быстрее( X, Y) :-<br>      быстр( X), медл( Y) ) ).<br>   yes<br>
		 <br>   ?- быстрее( А, В).<br>   А = энн<br>   В = том<br>
		 <br>   ?- retract( медл( X) ).<br>   X = том;<br>   X = пат;<br>   nо<br>
		 <br>   ?- быстрее( энн, _ ).<br>   nо<br>   Заметьте, что при добавлении нового правила синтаксис требует, чтобы оно (как аргумент assert) было заключено в скобки.<br>   При добавлении нового предложения может возникнуть желание указать, на какое место в базе данных его следует поместить. Такую возможность обеспечивают предикаты asserta и assertz. Цель<br>   asserta( С)<br>   помещает С в начале базы данных. Цель<br>   assertz( С)<br>   — в конце. Вот пример, иллюстрирующий работу этих предикатов:<br>   ?- assеrt( p( a)), assertz( p( b) ), asserta( p( c) ).<br>   yes<br>
		 <br>   ?- p( X).<br>   X = с;<br>   X = а;<br>   X = b<br>   Между consult и assertz существует связь. Обращение к файлу при помощи consult можно в терминах assertz определить так: считать все термы (предложения) файла и добавить их в конец базы данных.<br>   Одним из полезных применений предиката asserta является накопление уже вычисленных ответов на вопросы. Пусть, например, в программе определен предикат<br>   решить( Задача, Решение)<br>   Мы можем теперь задать вопрос и потребовать, чтобы ответ на него был запомнен, с тем чтобы облегчить получение ответов на будущие вопросы:<br>   ?- решить( задача1, решение),<br>    asserta( решить( Задача1, Решение) ).<br>   Если в первой из приведенных целей будет успех, ответ ( Решение) будет сохранен, а затем использован так же, как и любое другое предложение, при ответе на дальнейшие вопросы.<br>   Преимущество такого "запоминания" состоит в том, что на дальнейшие вопросы, сопоставимые с добавленным фактом, ответ будет получен, как правило, значительно быстрее, чем в первый раз. Ответ будет теперь получен как факт, а не как результат вычислений, требующих, возможно, длительного времени.<br>   Развитие этой идеи состоит в использовании assert для порождения всех решений в виде таблицы фактов. Например, создать таблицу произведений всех чисел от 0 до 9 можно так: породить пару чисел X и Y, вычислить Z, равное X * Y, добавить эти три числа в виде строки в таблицу произведений, а затем создать искусственно неуспех. Неуспех вызовет возврат, в результате которого будет найдена новая пара чисел, и в таблицу добавится новая строка и т.д. Эта идея реализована в процедуре<br>   таблица :-<br>    L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],<br>    принадлежит( X, L), % Выбрать первый сомножитель<br>    принадлежит( Y, L), % Выбрать второй сомножитель<br>    Z is X*Y,<br>    assert( произв( X,Y,Z) ),<br>    fail.<br>   Вопрос<br>   ?- таблица.<br>   потерпит, конечно, неудачу, однако в качестве своего побочного эффекта приведет к добавлению в базу данных целой таблицы произведений. После этого можно, например, спросить, какие пары дают произведения, равные 8:<br>   ?- произв( А, В, 8).<br>   А = 1<br>   В = 8;<br>
		 <br>   А = 2<br>   В = 4;<br>
		 <br>   ...<br>   Здесь следует сделать одно замечание, относящееся к стилю программирования. Приведенные примеры показали некоторые явно полезные применения assert и retract. Однако использование этих отношений требует особой внимательности. Не рекомендуется применять их слишком часто и без должной осторожности - это плохой стиль программирования. Ведь добавляя и удаляя предложения, мы фактически изменяем программу. Поэтому отношения, выполнявшиеся в некоторой ее точке, могут оказаться неверными в другой. В разные моменты времени ответы на одни и те же вопросы будут различными. Таким образом, большое количество обращений к assert и retract может затемнить смысл программы и станет трудно разобрать, что истинно, а что — нет. В результате поведение программы может стать непонятным, трудно объяснимым, и вряд ли можно будет ей доверять.<br><h5>Упражнения</h5>   <b>7.6.</b><br>    (а) Напишите вопрос к пролог-системе, который удаляет из базы данных всю таблицу произв.<br>    (b) Измените этот вопрос так, чтобы он удалил из таблицы только те строки, в которых произведение равно 0.<br>   <b>7.7.</b> Определите отношение<br>   копия( Терм, Копия)<br>   которое порождает такую копию Терм'а Копия, в которой все переменные переименованы. Это легко сделать, используя assert и retract.<br></div>
<h3 align="center">
<a name="TOC_id3590937"></a>7.5. Средства управления<br></h3>
<div>   К настоящему моменту мы познакомились с большинством дополнительных средств управления, за исключением repeat (повторение). Здесь мы для полноты приводим список всех таких средств.<br>   • <i>отсечение</i>, записывается как '!', предотвращает перебор, введено в гл. 5.<br>   • fail — цель, которая всегда терпит неудачу.<br>   • true — цель, которая всегда успешна.<br>   • not( P) — вид отрицания, который всегда ведет себя в точном соответствии со следующим определением:<br>   not( P) :- P, !, fail; true.<br>   Некоторые проблемы, связанные с отсечением и not детально обсуждались в гл. 5.<br>   • саll( P) активизирует цель P. Обращение к саll имеет успех, если имеет успех P.<br>   • repeat — цель, которая всегда успешна. Ее особое свойство состоит в том, что она недетерминирована, поэтому всякий раз, как до нее доходит перебор, она порождает новую ветвь вычислений. Цель repeat ведет себя так, как если бы она была определена следующим образом:<br>   repeat.<br>   repeat :- repeat.<br>   Стандартный способ применения repeat показан в процедуре квадраты, которая читает последовательность чисел и выдает их квадраты. Последовательность чисел заканчивается атомом стоп, который служит для процедуры сигналом окончания работы.<br>   квадраты :-<br>    repeat,<br>    read( X),<br>    ( X = стоп, !;<br>      Y is X*X, write( Y), fail ).<br></div>
<h3 align="center">
<a name="TOC_id3591073"></a>7.6. <i>bagof</i>, <i>setof</i> и <i>findall</i><br></h3>
<div>   При помощи механизма автоматического перебора можно получить одни за другим все объекты, удовлетворяющие некоторой цели. Всякий раз, как порождается новое решение, предыдущее пропадает и становится с этого момента недоступным. Однако у нас может возникнуть желание получить доступ ко всем порожденным объектам сразу, например собрав их в список. Встроенные предикаты bagof (набор) и setof (множество) обеспечивают такую возможность; вместо них иногда используют предикат findall (найти все).<br>   Цель<br>   bagof( X, P, L)<br>   порождает список L всех объектов X, удовлетворяющих цели P. Обычно bagof имеет смысл применять только тогда, когда X и P содержат общие переменные. Например, допустим, что мы включили в программу следующую группу предложений для разбиения букв (из некоторого множества) на два класса — гласные и согласные:<br>   класс( а, глас).<br>   класс( b, согл).<br>   класс( с, согл).<br>   класс( d, согл).<br>   класс( e, глас).<br>   класс( f, согл).<br>   Тогда мы можем получить список всех согласных, упомянутых в этих предложениях, при помощи цели:<br>   ?- bagof( Буква, класс( Буква, согл), Буквы).<br>   Буквы = [d, c, d, f]<br>   Если же мы в указанной цели оставим класс букв неопределенным, то, используя автоматический перебор, получим два списка букв, каждый из которых соответствует одному из классов:<br>   ?- bagof( Буква, класс( Буква, Класс), Буквы).<br>
		 <br>   Класс = глас<br>   Буквы = [а,e]<br>
		 <br>   Класс = согл<br>   Буквы = [b, c, d, f]<br>   Если bagof( X, P, L) не находит ни одного решения для P, то цель bagof просто терпит неуспех. Если один и тот же X найден многократно, то все его экземпляры будут занесены в L, что приведет к появлению в L повторяющихся элементов.<br>   Предикат setof работает аналогично предикату bagof. Цель<br>   setof( X, P, L)<br>   как и раньше, порождает список L объектов X, удовлетворяющих P. Только на этот раз список L будет упорядочен, а из всех повторяющихся элементов, если таковые есть, в него попадет только один. Упорядочение происходит по алфавиту или по отношению '&lt;', если элементы списка — числа. Если элементы списка — структуры, то они упорядочиваются по своим главным функторам. Если же главные функторы совпадают, то решение о порядке таких термов принимается по их первым несовпадающим функторам, расположенным выше и левее других (по дереву). На вид объектов, собираемых в список, ограничения нет. Поэтому можно, например, составить список пар вида<br>   Класс / Буква<br>   при этом гласные будут расположены в списке первыми ("глас" по алфавиту раньше "согл"):<br>   ?- setof( Класс/Буква, класс( Буква, Класс), Спис).<br>   Спис = [глас/а, глас/e, согл/b, согл/с, согл/d, согл/f]<br>   Еще одним предикатом этого семейства, аналогичным bagof, является findall.<br>   findall( X, P, L)<br>   тоже порождает список объектов, удовлетворяющих P. Он отличается от bagof тем, что собирает в список <i>все</i> объекты X, не обращая внимание на (возможно) отличающиеся для них конкретизации тех переменных из P, которых нет в X. Это различие видно из следующего примера:<br>   ?- findall( Буква, класс( Буква, Класс), Буквы).<br>   Буквы = [a, b, c, d, e, f]<br>   Если не существует ни одного объекта X, удовлетворяющего P, то findall все равно имеет успех и выдает L = [].<br>   Если в используемой реализации Пролога отсутствует встроенный предикат findall, то его легко запрограммировать следующим образом. Все решения для P порождаются искусственно вызываемыми возвратами. Каждое решение, как только оно получено, немедленно добавляется к базе данных, чтобы не потерять его после нахождения следующего решения. После того, как будут получены и сохранены все решения, их нужно собрать в список, а затем удалить из базы данных при помощи retract. Весь процесс можно представлять себе как построение очереди из порождаемых решений. Каждое вновь порождаемое решение добавляется в конец этой очереди при помощи assert. Когда все решения собраны, очередь расформировывается. Заметим также, что конец очереди надо пометить, например, атомом "дно" (который, конечно, должен отличаться от любого ожидаемого решения). Реализация findall в соответствии с описанным методом показана на рис. 7.4.<br>
		 <br>   findall( X, Цель, ХСпис) :-<br>    саll( Цель),           % Найти решение<br>    assert( очередь( X) ), % Добавить егo<br>    fail;                  % Попытаться найти еще решения<br>    assertz( очередь( дно) ),<br>     % Пометить конец решений<br>    собрать( ХСпис).       % Собрать решения в список<br>
		 <br>   собрать( L) :-<br>    retract( очередь(X) ), !,<br>     % Удалить следующее решение<br>    ( X == дно, !, L = [];<br>     % Конец решений?<br>    L = [X | Остальные], собрать( Остальные) ).<br>     % Иначе собрать остальные<br>   <b>Рис. 7.4.</b> Реализация отношения findall.<br>
		 <br><h5>Упражнения</h5>   <b>7.8.</b> Используя bagof, определите отношение<br>   множподмножеств( Мн, Подмн)<br>   для вычисления множества всех подмножеств данного множества (все множества представлены списками).<br>   <b>7.9.</b> Используя bagof, определите отношение<br>   копия( Терм, Копия)<br>   чтобы Копия представляла собой Терм, в котором все переменные переименованы.<br></div>
<h3 align="center">
<a name="TOC_id3591463"></a>Резюме<br></h3>
<div>   • В любой реализации Пролога обычно предусматривается набор встроенных процедур для выполнения различных полезных операций, несуществующих в чистом Прологе. В данной главе мы рассмотрели подобное множество предикатов, имеющееся во многих реализациях.<br>   • Тип терма можно установить при помощи следующих предикатов:<br>   var( X)     X — (неконкретизированная) переменная<br>   nonvar( X)  X — не переменная<br>   atom( X)    X — атом<br>   integer( X) X — целое<br>   atomic( X)  X — или атом, или целое<br>   • Термы можно синтезировать или разбирать на части:<br>   Терм =.. [Функтор [ СписокАргументов]<br>   functor( Терм, Функтор, Арность)<br>   arg( N, Терм, Аргумент)<br>   name( атом, КодыСимволов)<br>   • Программу на Прологе можно рассматривать как реляционную базу данных, которую можно изменять при помощи следующих процедур:<br>   аssert( Предл)  добавляет предложение Предл к программе<br>   аssеrtа( Предл) добавляет в начало<br>   assertz( Предл) добавляет в конец<br>   rеtrасt( Предл) удаляет предложение, сопоставимое с предложением Предл<br>   • Все объекты, отвечающие некоторому заданному условию, можно собрать в список при помощи предикатов:<br>   bagof( X, P, L)   L — список всех X, удовлетворяющих условию P<br>   setof( X, P, L)   L — отсортированный список всех X, удовлетворяющих условию P<br>   findall( X, P, L) аналогичен bagof<br>   • repeat — средство управления, позволяющее порождать неограниченное число альтернатив для автоматического перебора.<br></div>
</div>
<h2 align="center">
<a name="TOC_id3591593"></a>Глава 8<br>Стиль и методы программирования<br></h2>
<div>
<div>   В этой главе мы рассмотрим некоторые общие принципы хорошего программирования и обсудим, в частности, следующие вопросы: "Как представлять себе прологовские программы? Из каких элементов складывается хороший стиль программирования на Прологе? Как отлаживать пролог-программы? Как повысить их эффективность?"<br></div>
<h3 align="center">
<a name="TOC_id3591610"></a>8.1. Общие принципы хорошего программирования<br></h3>
<div>   Главный вопрос, касающийся хорошего программирования, — это вопрос о том, что такое хорошая программа. Ответ на этот вопрос не тривиален, поскольку существуют разные критерии качества программ.<br>   Следующие критерии общеприняты:<br>   • <i>Правильность</i>. Хорошая программа в первую очередь должна быть правильной, т.е. она должна делать именно то, для чего предназначалась. Это требование может показаться тривиальным и самоочевидным. Однако в случае сложных программ правильность достигается не так часто. Распространенной ошибкой при написании программ является пренебрежение этим очевидным критерием, когда большее внимание уделяется другим критериям — таким, как эффективность.<br>   • <i>Эффективность</i>. Хорошая программа не должна попусту тратить компьютерное время и память.<br>   • <i>Простота, читабельность</i>. Хорошая, программа должна быть легка для чтения и понимания. Она не должна быть более сложной, чем это необходимо. Следует избегать хитроумных программистских трюков, затемняющих смысл программы. Общая организация программы и расположение ее текста должны облегчать ее понимание.<br>   • <i>Удобство модификации</i>. Хорошая программа должна быть легко модифицируема и расширяема. Простота и модульная организация программы облегчают внесение в нее изменений.<br>   • <i>Живучесть</i>. Хорошая программа должна быть живучей. Она не должна сразу "ломаться", если пользователь введет в нее неправильные или непредусмотренные данные. В случае подобных ошибок программа должна сохранять работоспособность и вести себя разумно (сообщать об ошибках).<br>   • <i>Документированность</i>. Хорошая программа должна быть хорошо документирована. Минимальная документация — листинг с достаточно подробными комментариями.<br>   Степень важности того или иного критерия зависит от конкретной задачи, от обстоятельств написания программы, а также от условий ее эксплуатации. Наивысшим приоритетом пользуется, без сомнения, правильность. Обычно простоте, удобству модификации, живучести и документированности придают во крайней мере не меньший приоритет, чем эффективности.<br>   Существует несколько общих соображений, помогающих реализовать вышеупомянутые критерии на практике. Одно важное правило состоит в том, чтобы сначала <i>продумать</i> задачу, подлежащую решению, и лишь затем приступать к написанию текста программы на конкретном языке программирования. Как только мы хорошо поймем задачу, и способ ее решения будет нами полностью и во всех деталях продуман, само программирование окажется быстрым и легким делом и появится неплохой шанс за короткое время получить правильную программу.<br>   Распространенной ошибкой является попытка начать писать программу даже до того, как была уяснена полная постановка задачи. Главная причина, по которой следует воздерживаться от преждевременного начала программирования, состоит в том, что обдумывание задачи и поиск метода ее решения должны проводиться в терминах, наиболее адекватных самой этой задаче. Эти термины чаще всего далеки от синтаксиса применяемого языка программирования и могут быть утверждениями на естественном языке и рисунками.<br>   Исходная формулировка способа решения задачи должна быть затем трансформирована в программу, но этот процесс трансформации может оказаться нелегким. Неплохим подходом к его осуществлению является применение принципа <i>пошаговой детализации</i>. Исходная формулировка рассматривается как "решение верхнего уровня", а окончательная программа - как "решение низшего уровня".<br>   В соответствии с принципом пошаговой детализации окончательная программа получается после серии трансформаций или "детализаций" решения. Мы начинаем с первого решения — решения верхнего уровня, а затем последовательно проходим по цепочке решений; все эти решения эквивалентны, но каждое следующее решение выражено более детально, чей предыдущее. На каждом шагу детализации понятия, использовавшиеся в предыдущих формулировках, прорабатываются более подробно, а их представление все более приближается к языку программирования. Следует отдавать себе отчет в том, что детализация касается не только процедур, но и структур данных. На начальных шагах работают обычно с более абстрактными, более крупными информационными единицами, детальная структура которых уточняется впоследствии.<br>   Стратегия нисходящей пошаговой детализации имеет следующие преимущества:<br>   • она позволяет сформулировать грубое решение в терминах, наиболее адекватных решаемой задаче;<br>   • в терминах таких мощных понятий решение будет сжатым и простым, а потому скорее всего правильным;<br>   • каждый шаг детализации должен быть достаточно малым, чтобы не представлять больших интеллектуальных трудностей, если это удалось — трансформация решения в новое, более детальное представление скорее всего будет выполнена правильно, а следовательно, таким же правильным окажется и полученное решение следующего шага детализации.<br>   В случае Пролога мы можем говорить о пошаговой детализации <i>отношений</i>. Если существо задачи требует мышления в алгоритмических терминах, то мы можем также говорить и о детализации <i>алгоритмов</i>, приняв процедурную точку зрения на Пролог.<br>   Для того, чтобы удачно сформулировать решение на некотором уровне детализации и придумать полезные понятия для следующего, более низкого уровня, нужны идеи. Поэтому программирование — это творческий процесс, что верно в особенности, когда речь идет о начинающих программистах. По мере накопления опыта работа программиста постепенно становится все менее искусством и все более ремеслом. И все же главным остается вопрос: как возникают идеи? Большинство идей приходит из опыта, из тех задач, решения которых уже известны. Если мы не знаем прямого решения задачи, то нам может помочь уже решенная задача, похожая на нашу. Другим источником идей является повседневная жизнь. Например, если необходимо запрограммировать сортировку списка, то можно догадаться, как это сделать, если задать себе вопрос: "А как бы я сам стал действовать, чтобы расположить экзаменационные листы студентов по их фамилиям в алфавитном порядке?"<br>   Общие принципы, изложенные в данном разделе, известны также как составные части "структурного программирования"; они, в основном, применимы и к программированию на Прологе. В следующих разделах мы обсудим их более детально, обращая особое внимание на применение этих принципов программирования к Прологу.<br></div>
<h3 align="center">
<a name="TOC_id3591800"></a>8.2. Как представлять себе программы на Прологе<br></h3>
<div>
<div>   Одной из характерных особенностей Пролога является то, что в нем допускается как процедурный, так и декларативный стиль мышления при составлении программы. Эти два подхода детально обсуждались в гл. 2 и затем многократно иллюстрировались на примерах. Какой из этих подходов окажется более эффективным и практичным, зависит от конкретной задачи. Обычно построение декларативного решения задачи требует меньших усилий, но может привести к неэффективной программе. В процессе построения решения мы должны сводить задачу к одной или нескольким более легким подзадачам. Возникает важный вопрос: как находить эти подзадачи? Существует несколько общих принципов, которые часто применяются при программировании на Прологе. Они будут обсуждаться в следующих разделах.<br></div>
<h4 align="center">
<a name="TOC_id3591821"></a>8.2.1. Использование рекурсии<br></h4>
<div>   Этот принцип состоит в том, чтобы разбить задачу на случаи, относящиеся к двум группам:<br>   (1) тривиальные, или "граничные" случаи;<br>   (2) "общие" случаи, в которых решение получается из решений для (более простых) вариантов самой исходной задачи.<br>   Этот метод мы использовали в Прологе постоянно. Рассмотрим еще один пример: обработка списка элементов, при которой каждый элемент преобразуется по одному и тому же правилу. Пусть это будет процедура<br>   преобрспис( Спис, F, НовСпиc)<br>   где Спис — исходный список, F — правило преобразования (бинарное отношение), а НовСпиc — список всех преобразованных элементов. Задачу преобразования списка Спис можно разбить на два случая:<br>   (1) Граничный случай: Спис = []<br>   Если Спис = [], то НовСпиc = [], независимо от F<br>   (2) Общий случай: Спис = [X | Хвост]<br>   Чтобы преобразовать список вида [X | Хвост], необходимо:<br>     преобразовать список Хвост; результат — НовХвост;<br>     элемент X по правилу F; результат — НовХ;<br>     результат преобразования всего списка — [НовХ | НовХвост].<br>   Тот же алгоритм, изложенный на Прологе:<br>   преобрспис( [], _, []).<br>   преобрспис( [X | Хвост], F, [НовХ | НовХвост] :-<br>    G =.. [F, X, НовХ],<br>    саll( G),<br>    пpeoбpcпиc( Хвост, F, НовХвост).<br>   Одна из причин того, что рекурсия так естественна для определения отношений на Прологе, состоит в том, что объекты данных часто сами имеют рекурсивную структуру. К таким объектам относятся списки и деревья. Список либо пуст (граничный случай), либо имеет голову и хвост, который сам является списком (общий случай). Двоичное дерево либо пусто (граничный случай), либо у него есть корень и два поддерева, которые сами являются двоичными деревьями (общий случай). Поэтому для обработки всего непустого дерева необходимо сначала что-то сделать с его корнем, а затем обработать поддеревья.<br></div>
<h4 align="center">
<a name="TOC_id3591969"></a>8.2.2. Обобщение<br></h4>
<div>   Часто бывает полезно обобщить исходную задачу таким образом, чтобы полученная более общая задача допускала рекурсивную формулировку. Исходная задача решается, тогда как частный случай ее более общего варианта. Обобщение отношения обычно требует введения одного или более дополнительных аргументов. Главная проблема состоит в отыскании подходящего обобщения, что может потребовать более тщательного изучения задачи. В качестве примера рассмотрим еще раз задачу о восьми ферзях. Исходная задача состояла в следующем: разместить на доске восемь ферзей так, чтобы обеспечить отсутствие взаимных нападений. Соответствующее отношение назовем<br>   восемьферзей( Поз)<br>   Оно выполняется (истинно), если Поз — представленная тем или иным способом позиция, удовлетворяющая условию задачи. Можно предложить следующую полезную идею: обобщить задачу, перейдя от 8 ферзей к произвольному количеству — N. Количество ферзей станет дополнительным аргументом:<br>   n_ферзей( Поз, N)<br>   Преимущество такого обобщения состоит в том, что отношение n_ферзей допускает непосредственную рекурсивную формулировку:<br>   (1) Граничный случай: N = 0<br>   Разместить 0 ферзей — тривиальная задача.<br>   (2) Общий случай: N &gt; 0<br>   Для "безопасного" размещения N ферзей необходимо:<br>   • получить требуемое размещение для (N - 1) ферзей и<br>   • добавить оставшегося ферзя так, чтобы он не бил ни одного из уже поставленных ферзей.<br>   Как только мы научимся решать более общую задачу, решить исходную уже не составит труда:<br>   восемьферзей( Поз) :- n_ферзей( Поз, 8)<br></div>
<h4 align="center">
<a name="TOC_id3592042"></a>8.2.3. Использование рисунков<br></h4>
<div>   В поиске идей для решения задачи часто бывает полезным обратиться к ее графическому представлению. Рисунок может помочь выявить в задаче некоторые существенные отношения. После этого останется только описать на языке программирования то, что мы <i>видим</i> на рисунке.<br>   Использование графического представления при решении задач полезно всегда, однако похоже, что в Прологе оно работает особенно хорошо. Происходит это по следующим причинам:<br>   (1) Пролог особенно хорошо приспособлен для задач, в которых фигурируют объекты и отношения между ними. Часто такие задачи естественно иллюстрировать графами, в которых узлы соответствуют объектам, а дуги — отношениям.<br>   (2) Естественным наглядным изображением структурных объектов Пролога являются деревья.<br>   (3) Декларативный характер пролог-программ облегчает перевод графического представления на Пролог. В принципе, порядок описания "картинки" не играет роли, мы просто помещаем в программу то, что видим, в произвольном порядке. (Возможно, что из практических соображений этот порядок впоследствии придется подправить с целью повысить эффективность программы.) <br></div>
</div>
<h3 align="center">
<a name="TOC_id3592081"></a>8.3. Стиль программирования<br></h3>
<div>
<div>   Подчиняться при программировании некоторым стилистическим соглашениям нужно для того, чтобы<br>   • уменьшить опасность внесения ошибок в программы и<br>   • создавать программы, которые легко читать, понимать, отлаживать и модифицировать.<br>   Ниже дается обзор некоторых из составных частей хорошего стиля программирования на Прологе. Мы рассмотрим некоторые общие правила хорошего стиля, табличную организацию длинных процедур и вопросы комментирования программ.<br></div>
<h4 align="center">
<a name="TOC_id3592105"></a>8.3.1. Некоторые правила хорошего стиля<br></h4>
<div>   • Предложения программы должны быть короткими. Их тела, как правило, должны содержать только несколько целей.<br>   • Процедуры должны быть короткими, поскольку длинные процедуры трудны для понимания. Тем не менее длинные процедуры вполне допустимы в том случае, когда они имеют регулярную структуру (этот вопрос еще будет обсуждаться в данной главе).<br>   • Следует применять мнемонические имена процедур и переменных. Они должны отражать смысл отношений и роль объектов данных.<br>   • Существенное значение имеет расположение текста программы. Для улучшения читабельности программы нужно постоянно применять пробелы, пустые строки и отступы. Предложения, относящиеся к одной процедуре, следует размещать вместе в виде отдельной группы строк; между предложениями нужно вставлять пустую строку (этого не нужно делать, возможно, только в случае перечисления большого количества фактов, касающихся одного отношения); каждую цель можно размещать на отдельной строке. Пролог-программы иной раз напоминают стихи по эстетической привлекательности своих идей и формы.<br>   • Стилистические соглашения такого рода могут варьироваться от программы к программе, так как они зависят от задачи и от личного вкуса. Важно, однако, чтобы на протяжении одной программы постоянно применялись одни и те же соглашения.<br>   • Оператор отсечения следует применять с осторожностью. Если легко можно обойтись без него — не пользуйтесь им. Всегда, когда это возможно, предпочтение следует отдавать "зеленым отсечениям" перед "красными". Как говорилось в гл. 5, отсечение называется "зеленым", если его можно убрать, на затрагивая декларативный смысл предложения. Использование "красных отсечений" должно ограничиваться четко определенными конструкциями, такими как оператор not или конструкция выбора между альтернативами. Примером последней может служить<br>   <i>если</i>Условие<i>то</i>Цель1<i>иначе</i>Цель2<br>   С использованием отсечения эта конструкция переводится на Пролог так:<br>   Условие, !. % Условие выполнено?<br>   Цель1;      % Если да, то Цель1<br>   Цель2       % Иначе - Цель2<br>   • Из-за того, что оператор not связан с отсечением, он тоже может привести к неожиданностям. Поэтому, применяя его, следует всегда помнить точное прологовское определение этого оператора. Тем не менее, если приходится выбирать между not и отсечением, то лучше использовать not, чем какую-нибудь туманную конструкцию с отсечением.<br>   • Внесение изменений в программу при помощи assert и retract может сделать поведение программы значительно менее понятным. В частности, одна и та же программа на одни и те же вопросы будет отвечать по-разному в разные моменты времени. В таких случаях, если мы захотим повторно воспроизвести исходное поведение программы, нам придется предварительно убедиться в том, что ее исходное состояние, нарушенное при обращении к assert и retract, полностью восстановлено.<br>   • Применение точек с запятой может затемнять смысл предложений. Читабельность можно иногда улучшить, разбивая предложения, содержащие точки с запятой, на несколько новых предложений, однако за это, возможно, придется заплатить увеличенном длины программы и потерей в ее эффективности.<br>   Для иллюстрации некоторых положений данного раздела рассмотрим отношение<br>   слить( Спис1, Спис2, Спис3)<br>   где Спис1 и Спис2 — упорядоченные списки, а Спис3 — результат их слияния (тоже упорядоченный). Например:<br>   слить( [2, 4, 7], [1, 3, 4, 8], [1, 2, 3, 4, 4, 7, 8] )<br>   Вот стилистически неудачная реализация этого отношения:<br>   слить( Спис1, Спис2, Спис3) :-<br>    Спис1 = [], !, Спис3 = Спис2;<br>     % Первый список пуст<br>    Спис2 = [], !,  Спис3 = Спис1;<br>     % Второй список пуст<br>    Спис1 = [X | Остальные],<br>    Спис2 = [Y | Остальные],<br>    ( X &lt; Y, !,<br>      Z = X, % Z - голова Спис3<br>    слить( Остальные1, Спис2, Остальные3 );<br>    Z = Y,<br>    слить( Спис1, Остальные2, Остальные3 ) ),<br>    Спис3 = [Z | Остальные3].<br>   Вот более предпочтительный вариант, не использующий точек с запятой:<br>   слить( [], Спис, Спис).<br>   слить( Спис, [], Спис).<br>   слить( [X | Остальные1], [Y | Остальные2], [X | Остальные3] ) :-<br>    X &lt; Y, !,<br>    слить(Остальные1, [Y | Остальные2], Остальные3).<br>   слить( Спис1, [Y | Остальные2], [Y | Остальные3]): -<br>    слить( Спис1, Остальные2, Остальные3 ).<br></div>
<h4 align="center">
<a name="TOC_id3592362"></a>8.3.2. Табличная организация длинных процедур<br></h4>
<div>   Длинные процедуры допустимы, если они имеют регулярную структуру. Обычно эта структура представляет собой множество фактов, соответствующее определению какого-либо отношения в табличной форме. Преимущества такой организации длинной процедуры состоят в том, что:<br>   • Ее структуру легко понять.<br>   • Ее удобно совершенствовать: улучшать ее можно, просто добавляя новые факты.<br>   • Ее легко проверять и модифицировать (просто заменяя отдельные факты, независимо от остальных). <br></div>
<h4 align="center">
<a name="TOC_id3592385"></a>8.3.3. Комментирование<br></h4>
<div>   Программные комментарии должны объяснять в первую очередь, для чего программа предназначена и как ею пользоваться, и только затем — подробности используемого метода решения и другие программные детали. Главная цель комментариев — обеспечить пользователю возможность применять программу, понимать ее и, может быть, модифицировать. Комментарии должны содержать в наиболее краткой форме всю необходимую для этого информацию. Недостаточное комментирование — распространенная ошибка, однако, программу можно и перенасытить комментариями. Объяснения деталей, которые и так ясны из самого текста программы, являются ненужной перегрузкой.<br>   Длинные фрагменты комментариев следует располагать перед текстом, к которому они относятся, в то время как короткие комментарии должны быть вкраплены в сам текст. Информация, которую в самом общем случае следует включать в комментарии, должна схватывать следующие вопросы:<br>   • Что программа делает, как ею пользоваться (например, какую цель следует активизировать и каков вид ожидаемых результатов), примеры ее применения.<br>   • Какие предикаты относятся к верхнему уровню?<br>   • Как представлены основные понятия (объекты)?<br>   • Время выполнения и требования по объему памяти.<br>   • Каковы ограничения на программу?<br>   • Использует ли она какие-либо средства, связанные с конкретной операционной системой?<br>   • Каков смысл предикатов программы? Каковы их аргументы? Какие аргументы являются "входными" и какие — "выходными", если это известно? (В момент запуска предиката входные аргументы имеют полностью определенные значения, не содержащие не конкретизированных переменных.)<br>   • Алгоритмические и реализационные детали.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3592441"></a>8.4. Отладка<br></h3>
<div>   Когда программа не делает того, чего от нее ждут, главной проблемой становится отыскание ошибки (или ошибок). Всегда легче найти ошибку в какой-нибудь части программы (или в отдельном модуле), чем во всей программе. Поэтому следует придерживаться следующего хорошего принципа: проверять сначала более мелкие программные единицы и только после того, как вы убедились, что им можно доверять, начинать проверку большего модуля или всей программы.<br>   Отладка в Прологе облегчается двумя обстоятельствами: во-первых, Пролог — интерактивный язык, поэтому можно непосредственно обратиться к любой части программы, задав пролог-системе соответствующий вопрос; во-вторых, в реализациях Пролога обычно имеются специальные средства отладки. Следствием этих двух обстоятельств является то, что отладка программ на Прологе может производиться, вообще говоря, значительно эффективнее, чем в других языках программирования.<br>   Основным средством отладки является <i>трассировка</i> (tracing). "Трассировать цель" означает: предоставить пользователю информацию, относящуюся к достижению этой цели в процессе ее обработки пролог-системой. Эта информация включает:<br>   • Входную информацию — имя предиката и значении аргументов в момент активизации цели.<br>   • Выходную информацию — в случае успеха, значения аргументов, удовлетворяющих цели; в противном случае — сообщение о неуспехе.<br>   • Информацию о повторном входе, т.е. об активизации той же цели в результате автоматического возврата.<br>   В промежутке между входом и выходом можно получить трассировочную информацию для всех подцелей этой цели. Таким образом, мы можем следить за обработкой нашего вопроса на всем протяжении нисходящего пути от исходной цели к целям самого нижнего уровня, вплоть до отдельных фактов. Такая детальная трассировка может оказаться непрактичной из-за непомерно большого количества трассировочной информации. Поэтому пользователь может применить "селективную" трассировку. Существуют два механизма селекции: первый подавляет выдачу информации о целях, расположенных ниже некоторого уровня; второй трассирует не все предикаты, а только некоторые, указанные пользователем.<br>   Средства отладки приводятся в действие при помощи системно-зависимых встроенных предикатов. Обычно используется следующий стандартный набор таких предикатов:<br>   trace<br>   запускает полную трассировку всех целей, следующих за trace.<br>   notrace<br>   прекращает дальнейшее трассирование.<br>   spy( P) (следи за P)<br>   устанавливает режим трассировки предиката P. Обращение к spy применяют, когда хотят получить информацию только об указанном предикате и избежать трассировочной информации от других целей (как выше, так и ниже уровня запуска P). "Следить" можно сразу за несколькими предикатами.<br>   nospy( P)<br>   прекращает "слежку" за P.<br>   Трассировка ниже определенной глубины может быть подавлена во время выполнения программы при помощи специальных команд. Существуют и другие команды отладки, такие как возврат к предыдущей точке процесса вычислений. После такого возврата можно, например, повторить вычисления с большей степенью детализации трассировки.<br></div>
<h3 align="center">
<a name="TOC_id3592554"></a>8.5. Эффективность<br></h3>
<div>
<div>   Существует несколько аспектов эффективности программ, включая такие наиболее общие, как время выполнения и требования по объему памяти. Другим аспектом является время, необходимое программисту для разработки программы.<br>   Традиционная архитектура вычислительных машин не очень хорошо приспособлена для реализации прологовского способа выполнения программ, предусматривающего достижение целей из некоторого списка. Поэтому ограниченность ресурсов по времени и пространству сказывается в Прологе, пожалуй, в большей степени, чем в большинстве других языков программирования. Вызовет ли это трудности в практических приложениях, зависит от задачи. Фактор времени практически не имеет значения, если пролог-программа, которую запускают по несколько раз в день, занимает 1 секунду процессорного времени, а соответствующая программа на каком-либо другом языке, скажем на Фортране, — 0.1 секунды. Разница в эффективности становится существенной, если эти две программы требуют 50 и 5 минут соответственно.<br>   С другой стороны, во многих областях применения Пролога он может существенно сократить время разработки программ. Программы на Прологе, вообще говоря, легче писать, легче понимать и отлаживать, чем программы, написанные на традиционных языках. Задачи, тяготеющие к "царству Пролога", включают в себя обработку символьной, нечисловой информации, структурированных объектов данных и отношений между ними. Пролог успешно применяется, в частности. в таких областях, как символьное решение уравнений, планирование, базы данных, автоматическое решение задач, машинное макетирование, реализация языков программирования, дискретное и аналоговое моделирование, архитектурное проектирование, машинное обучение, понимание естественного языка, экспертные системы и другие задачи искусственного интеллекта. С другой стороны, применение Пролога в области вычислительной математики вряд ли можно считать естественным.<br>   Прогон <i>откомпилированной</i> программы обычно имеет большую эффективность, чем <i>интерпретация</i>. Поэтому, если пролог-система содержит как интерпретатор, так и компилятор, следует пользоваться компилятором, если время выполнения критично.<br>   Если программа страдает неэффективностью, то ее обычно можно кардинально улучшить, изменив сам алгоритм. Однако для того, чтобы это сделать, необходимо изучить процедурные аспекты программы. Простой способ сокращения времени выполнения состоит в нахождении более удачного порядка предложений в процедуре и целей — в телах процедур. Другой, относительно простой метод заключается в управлении действиями системы посредством отсечений.<br>   Полезные идеи, относящиеся к повышению эффективности, обычно возникают только при достижении более глубокого понимания задачи. Более эффективный алгоритм может, вообще говоря, привести к улучшениям двух видов:<br>   • Повышение эффективности поиска путем скорейшего отказа от ненужного перебора и от вычисления бесполезных вариантов.<br>   • Применение cтруктур данных, более приспособленных для представления объектов программы, с целью реализовать операции над ними более эффективно.<br>   Мы изучим оба вида улучшений на примерах. Кроме того, мы рассмотрим на примере еще один метод повышения эффективности. Этот метод основан на добавлении в базу данных тех промежуточных результатов, которые с большой вероятностью могут потребоваться для дальнейших вычислений. Вместо того, чтобы вычислять их снова, программа просто отыщет их в базе данных как уже известные факты.<br></div>
<h4 align="center">
<a name="TOC_id3592644"></a>8.5.1. Повышение эффективности решения задачи о восьми ферзях<br></h4>
<div>   В качестве простого примера повышения эффективности давайте вернемся к задаче о восьми ферзях (см. рис. 4.7). В этой программе Y-координаты ферзей перебираются последовательно — для каждого ферзя пробуются числа от 1 до 8. Этот процесс был запрограммирован в виде цели<br>   принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] )<br>   Процедура принадлежит работает так: вначале пробует Y = 1, затем Y = 2, Y = 3 и т.д. Поскольку ферзи расположены один за другим в смежных вертикалях доски, очевидно, что такой порядок перебора не является оптимальным. Дело в том, что ферзи, расположенные в смежных вертикалях будут бить друг друга, если они не будут разнесены по вертикали на расстояние, превышающее, по крайней мере одно поле. В соответствии с этим наблюдением можно попытаться повысить эффективность, просто изменив порядок рассмотрения координат-кандидатов. Например:<br>   принадлежит( Y, [1, 5, 2, 6, 3, 7, 4, 8] )<br>   Это маленькое изменение уменьшит время, необходимое для нахождения первого решения, в 3-4 раза.<br>   В следующем примере такая же простая идея, связанная с изменением порядка, превращает практически неприемлемую временную сложность в тривиальную.<br></div>
<h4 align="center">
<a name="TOC_id3592688"></a>8.5.2. Повышение эффективности программы раскраски карты<br></h4>
<div>   Задача раскраски карты состоит в приписывании каждой стране на заданной карте одного из четырех заданных цветов с таким расчетом, чтобы ни одна пара соседних стран не была окрашена в одинаковый цвет. Существует теорема, которая гарантирует, что это всегда возможно.<br>   Пусть карта задана отношением соседства<br>   соседи( Страна, Соседи)<br>   где Соседи — список стран, граничащих со страной Страна. При помощи этого отношения карта Европы с 20-ю странами будет представлена (в алфавитном порядке) так:<br>   соседи( австрия, [венгрия, запгермания, италия,<br>    лихтенштейн, чехословакия,<br>    швейцария, югославия]).<br>   соседи( албания, [греция, югославия]).<br>   соседи( андорра, [испания, франция]).<br>   ...<br>   Решение представим в виде списка пар вида<br>   Страна / Цвет<br>   которые устанавливают цвет для каждой страны на данной карте. Для каждой карты названия стран всегда известны заранее, так что задача состоит в нахождении цветов. Таким образом, для Европы задача сводится к отысканию подходящей конкретизации переменных C1, C2, СЗ и т.д. в списке<br>   [австрия/C1, албания/C2, андорра/С3, ...]<br>   Теперь определим предикат<br>   цвета( СписЦветСтран)<br>   который истинен, если СписЦветСтран удовлетворяет тем ограничениям, которые наложены на раскраску отношением соседи. Пусть четырьмя цветами будут желтый, синий, красный и зеленый. Условие запрета раскраски соседних стран в одинаковый цвет можно сформулировать на Прологе так:<br>   цвета( []).<br>   цвета( [Страна/Цвет | Остальные] ) :-<br>    цвета( Остальные),<br>    принадлежит( Цвет, [желтый, синий, красный, зеленый]),<br>    not( принадлежит( Страна1/Цвет, Остальные),<br>    сосед( Страна, Страна1) ).<br>
		 <br>   сосед( Страна, Страна1) :-<br>    соседи( Страна, Соседи),<br>    принадлежит( Страна1, Соседи).<br>   Здесь принадлежит( X, L) — как всегда, отношение принадлежности к списку. Для простых карт с небольшим числом стран такая программа будет работать. Что же касается Европы, то здесь результат проблематичен. Если считать, что мы располагаем встроенным предикатом setof, то можно попытаться раскрасить карту Европы следующим образом. Определим сначала вспомогательное отношение:<br>   страна( С) :- соседи( С, _ ).<br>   Тогда вопрос для раскраски карты Европы можно сформулировать так:<br>   ?- sеtоf( Стр/Цвет, страна( Стр), СписЦветСтран),<br>    цвета( СписЦветСтран).<br>   Цель setof — построить "шаблон" списка СписЦветСтран, в котором в элементах вида страна/ цвет вместо цветов будут стоять неконкретизированные переменные. Предполагается, что после этого цель цвета конкретизирует их. Такая попытка скорее всего потерпит неудачу вследствие неэффективности работы программы.<br>   Тщательное исследование способа, при помощи которого пролог-система пытается достичь цели цвета, обнаруживает источник неэффективности. Страны расположены в списке в алфавитном порядке, а он не имеет никакого отношения к их географическим связям. Порядок, в котором странам приписываются цвета, соответствует порядку их расположения в списке (с конца к началу), что в нашем случае никак не связано с отношением соседи. Поэтому процесс раскраски начинается в одном конце карты, продолжается в другой и т.д., перемещаясь по ней более или менее случайно. Это легко может привести к ситуации, когда при попытке раскрасить очередную страну окажется, что она окружена странами, уже раскрашенными во все четыре доступных цвета. Подобные ситуации приводят к возвратам, снижающим эффективность.<br>   Ясно поэтому, что эффективность зависит от порядка раскраски стран. Интуиция подсказывает простую стратегию раскраски, которая должна быть лучше, чем случайная: начать со страны, имеющей иного соседей, затем перейти к ее соседям, затем — к соседям соседей и т.д. В случае Европы хорошим кандидатом для начальной страны является Западная Германия (как имеющая наибольшее количество соседей — 9). Понятно, что при построении шаблона списка элементов вида страна/цвет Западную Германию следует поместить в конец этого списка, а остальные страны - добавлять со стороны его начала. Таким образом, алгоритм раскраски, который начинает работу с конца списка, в начале займется Западной Германией и продолжит работу, переходя от соседа к соседу.<br>   Новый способ упорядочивания списка стран резко повышает эффективность по отношению к исходному, алфавитному порядку, и теперь возможные раскраски карты Европы будут получены без труда.<br>   Можно было бы построить такой правильно упорядоченный список стран вручную, но в этом нет необходимости. Эту работу выполнит процедура создспис. Она начинает построение с некоторой указанной страны (в нашем случае — с Западной Германии) и собирает затем остальные страны в список под названием Закрытый. Каждая страна сначала попадает в другой список, названный Открытый, а потом переносится в Закрытый. Всякий раз, когда страна переносится из Открытый в Закрытый, ее соседи добавляются в Открытый.<br>   создспис( Спис) :-<br>    собрать( [запгермания], [], Спис ).<br>
		 <br>   собрать( [], Закрытый, Закрытый).<br>     % Кандидатов в Закрытый больше нет<br>   собрать( [X | Открытый], Закрытый, Спис) :-<br>    принадлежит( X | Закрытый), !,<br>     % X уже собран ?<br>    собрaть( Открытый, Закрытый, Спис).<br>     % Отказаться от X<br>   собрать( [X | Открытый], Закрытый, Спис) :-<br>    соседи( X, Соседи),<br>     % Найти соседей X<br>    конк( Соседи, Открытый, Открытый1),<br>     % Поместить их в Открытый<br>    собрать( Открытый1, [X | Закрытый], Спис).<br>     % Собрать остальные<br>   Отношение конк — как всегда — отношение конкатенации списков.<br></div>
<h4 align="center">
<a name="TOC_id3593033"></a>8.5.3. Повышение эффективности конкатенации списков за счет совершенствования структуры данных<br></h4>
<div>   До сих пор в наших программах конкатенация была определена так:<br>   конк( [], L, L).<br>   конк( [X | L1], L2, [X | L3] ) :-<br>    конк( L1, L2, L3 ).<br>   Эта процедура неэффективна, если первый список — длинный. Следующий пример объясняет, почему это так:<br>   ?- конк( [а, b, с], [d, e], L).<br>   Этот вопрос порождает следующую последовательность целей:<br>   конк( [а, b, с], [d, e], L)<br>    конк( [b, с], [d, e], L') где L = [a | L']<br>     конк( [с], [d, e], L'')   где L' = [b | L''']<br>      конк( [], [d, e], L''')   где L'' = [c | L''']<br>       true  (истина) где L''' = [d, e]<br>   Ясно, что программа фактически сканирует весь первый список, пока не обнаружит его конец.<br>   А нельзя ли было бы проскочить весь первый список за один шаг и сразу подсоединить к нему второй список, вместо того, чтобы постепенно продвигаться вдоль него? Но для этого необходимо знать, где расположен конец списка, а следовательно, мы нуждаемся в другом его представлении. Один из вариантов — представлять список парой списков. Например, список<br>   [а, b, с]<br>   можно представить следующими двумя списками:<br>   L1 = [a, b, c, d, e]<br>   L2 = [d, e]<br>   Подобная пара списков, записанная для краткости как L1-L2, представляет собой "разность" между L1 и L2. Это представление работает только при том условии, что L2 — "конечный участок" списка L1. Заметим, что один и тот же список может быть представлен несколькими "разностными парами". Поэтому список [а, b, с] можно представить как<br>   [а, b, с]-[]<br>   или<br>   [a, b, c, d, e]-[d, e]<br>   или<br>   [a, b, c, d, e | T]-[d, e | T]<br>   или<br>   [а, b, с | T]-T<br>   где T — произвольный список, и т.п. Пустой список представляется любой парой L-L.<br>   Поскольку второй член пары указывает на конец списка, этот конец доступен сразу. Это можно использовать для эффективной реализации конкатенации. Метод показан на рис. 8.1. Соответствующее отношение конкатенации записывается на Прологе в виде факта<br>   конкат( A1-Z1, Z1-Z2, A1-Z2).<br>   Давайте используем конкат для конкатенации двух списков: списка [а, b, с], представленного парой [а, b, с | Т1]-Т1, и списка [d, e], представленного парой [d, e | Т2]-Т2:<br>   ?- конкат( [а, b, с | Т1]-T1, [d, e | Т2]-Т2, L ).<br>   Оказывается, что для выполнения конкатенации достаточно простого сопоставления этой цели с предложением конкат. Результат сопоставления:<br>   T1 = [d, e | Т2]<br>   L = [a, b, c, d, e | T2]-T2<br><div align="center"><img border="1" src="_48.png"></div>   <b>Рис. 8.1.</b> Конкатенация списков, представленных в виде разностных пар. L1 представляется как A1-Z1, L2 как A2-Z2 и результат L3 — как A1-Z2. При этом должно выполняться равенство Z1 = А2.<br></div>
<h4 align="center">
<a name="TOC_id3593271"></a>8.5.4. Повышение эффективности зa счет добавления вычисленных фактов к базе данных<br></h4>
<div>   Иногда в процессе вычислений приходится одну и ту же цель достигать снова и снова. Поскольку в Прологе отсутствует специальный механизм выявления этой ситуации, соответствующая цепочка вычислений каждый раз повторяется заново.<br>   В качестве примера рассмотрим программу вычисления N-го числа Фибоначчи для некоторого заданного N. Последовательность Фибоначчи имеет вид:<br>   1, 1, 2, 3, 5, 8, 13, …<br>   Каждый член последовательности, за исключением первых двух, представляет собой сумму предыдущих двух членов. Для вычисления N-гo числа Фибоначчи F определим предикат<br>   фиб( N, F)<br>   Нумерацию чисел последовательности начнем с N = 1. Программа для фиб обрабатывает сначала первые два числа Фибоначчи как два особых случая, а затем определяет общее правило построения последовательности Фибоначчи:<br>   фиб( 1, 1).    % 1-e число Фибоначчи<br>   фиб( 2, 1).    % 2-e число Фибоначчи<br>   фиб( N, F) :-  % N-e число Фиб., N &gt; 2<br>    N &gt; 2,<br>    N1 is N - 1, фиб( N1, F1),<br>    N2 is N - 2, фиб( N2, F2),<br>    F is F1 + F2. % N-e число есть сумма двух<br>                  % предыдущих<br>   Процедура фиб имеет тенденцию к повторению вычислений. Это легко увидеть, если трассировать цель<br>   ?- фиб( 6, F).<br>   На рис. 8.2 показано, как протекает этот вычислительный процесс. Например, третье число Фибоначчи f( 3) понадобилось в трех местах, и были повторены три раза одни и те же вычисления.<br>   Этого легко избежать, если запоминать каждое вновь вычисленное число. Идея состоит в применении встроенной процедуры assert для добавления этих (промежуточных) результатов в базу данных в виде фактов. Эти факты должны предшествовать другим предложениям, чтобы предотвратить применение общего правила в случаях, для которых результат уже известен. Усовершенствованная процедура фиб2 отличается от фиб только этим добавлением:<br>   фиб2( 1, 1).            % 1-e число Фибоначчи<br>   фиб2( 2, 1).            % 2-e число Фибоначчи<br>   фиб2( N, F) :-          % N-e число Фиб., N &gt; 2<br>    N &gt; 2,<br>    N1 is N - 1, фиб2( N1, F1),<br>    N2 is N - 2, фиб2( N2, F2),<br>    F is F1 + F2,           % N-e число есть сумма<br>                            % двух предыдущих<br>    asserta( фиб2( N, F) ). % Запоминание N-го числа<br>   Эта программа, при попытке достичь какую-либо цель, будет смотреть сперва на накопленные об этом отношении факты и только после этого применять общее правило. В результате, после вычисления цели фиб2( N, F), все числа Фибоначчи вплоть до N-го будут сохранены. На рис. 8.3 показан процесс вычислении 6-го числа при помощи фиб2. Сравнение этого рисунка с рис. 8.2. показывает, на сколько уменьшилась вычислительная сложность. Для больших N такое уменьшение еще более ощутимо.<br>   Запоминание промежуточных результатов — стандартный метод, позволяющий избегать повторных вычислений. Следует, однако, заметить, что в случае чисел Фибоначчи повторных вычислений можно избежать еще и применением другого алгоритма, а не только запоминанием промежуточных результатов.<br><div align="center"><img border="1" src="_49.png"></div>   <b>Рис. 8.2.</b>  Вычисление 6-го числа Фибоначчи процедурой фиб.<br><div align="center"><img border="1" src="_50.png"></div>   <b>Рис. 8.3.</b> Вычисление 6-го числа Фибоначчи при помощи процедуры фиб2, которая запоминает предыдущие результаты. По сравнению с процедурой фиб здесь вычислений меньше (см. рис. 8.2).<br>   Этот новый алгоритм позволяет создать программу более трудную для понимания, зато более эффективную. Идея состоит на этот раз не в том, чтобы определить N-e число Фибоначчи просто как сумму своих предшественников по последовательности, оставляя рекурсивным вызовам организовать вычисления "сверху вниз" вплоть до самых первых двух чисел. Вместо этого можно работать "снизу вверх": начать с первых двух чисел и продвигаться вперед, вычисляя члены последовательности один за другим. Остановиться нужно в тот момент, когда будет достигнуто N-e число. Большая часть работы в такой программе выполняется процедурой<br>   фибвперед( М, N, F1, F2, F)<br>   Здесь F1 и F2 — (М – 1)-e и М-e числа, а F — N-e число Фибоначчи. Рис. 8.4 помогает понять отношение фибвперед. В соответствии с этим рисунком фибвперед находит последовательность преобразований для достижения конечной конфигурации (в которой М = N) из некоторой заданной начальной конфигурации. При запуске фибвперед все его аргументы, кроме F, должны быть конкретизированы, а М должно быть меньше или равно N. Вот эта программа:<br>   фиб3( N, F) :-<br>    фибвперед( 2, N, 1, 1, F).<br>     % Первые два числа Фиб. равны 1<br>
		 <br>   фибвперед( М, N, F1, F2, F2) :-<br>    М &gt;= N. % N-e число достигнуто<br>   фибвперед( M, N, F1, F2, F) :-<br>    M &lt; N,  % N-e число еще не достигнуто<br>    СледМ is М + 1,<br>    СледF2 is F1 + F2,<br>    фибвперед( СледМ, N, F2, СледF2, F).<br><div align="center"><img border="1" src="_51.png"></div>   <b>Рис. 8.4.</b> Отношения в последовательности Фибоначчи. "Конфигурация" изображается здесь в виде большого круга и определяется тремя параметрами: индексом М и двумя последовательными числами f( M-1) и f( М).<br><h5>Упражнения</h5>   <b>8.1.</b> Все показанные ниже процедуры подсп1, подсп2 и подсп3 реализуют отношение взятия подсписка. Отношение подсп1 имеет в значительной мере процедурное определение, тогда как подсп2 и подсп3 написаны в декларативном стиле. Изучите поведение этих процедур на примерах нескольких списков, обращая внимание на эффективность работы. Две из них ведут себя одинаково и имеют одинаковую эффективность. Какие? Почему оставшаяся процедура менее эффективна?<br>   подсп1( Спис, Подспис) :-<br>    начало( Спис, Подспис).<br>   подсп1( [ _ | Хвост], Подспис) :-<br>     % Подспис - подсписок хвоста<br>    подсп1( Хвост, Подспис).<br>
		 <br>   начало( _, []).<br>   начало( [X | Спис1], [X | Спис2] ) :-<br>    начало( Спис1, Спис2).<br>
		 <br>   подсп2( Спис, Подспис) :-<br>    конк( Спис1, Спис2, Спис),<br>    конк( Спис3, Подспис, Cпис1).<br>
		 <br>   подсп3( Спис, Подспис) :-<br>    конк( Спис1, Спис2, Спис),<br>    конк( Подспис, _, Спис2).<br>   <b>8.2.</b> Определите отношение<br>   добавить_в_конец( Список, Элемент, НовыйСписок)<br>   добавляющее Элемент в конец списка Список; результат — НовыйСписок. Оба списка представляйте разностными парами.<br>   <b>8.3.</b> Определите отношение<br>   обратить( Список, ОбращенныйСписок)<br>   где оба списка представлены разностными парами.<br>   <b>8.4.</b> Перепишите процедуру собрать из разд. 8.5.2, используя разностное представление списков, чтобы конкатенация выполнялась эффективнее.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3593724"></a>Резюме<br></h3>
<div>   • Для оценки качества программы существует несколько критериев: <br>     правильность<br>     эффективность<br>     простота, читабельность<br>     удобство модификации<br>     документированность<br>   • Принцип <i>пошаговой детализации</i> — хороший способ организации процесса разработки программ. Пошаговая детализация применима к отношениям, алгоритмам и структурам данных.<br>   • Следующие методы часто помогают находить идеи для совершенствования программ на Прологе:<br>     <i>Применение рекурсии</i>: выявить граничные и общие случаи рекурсивного определения.<br>     <i>Обобщение</i>: рассмотреть такую более общую задачу, которую проще решить, чем исходную.<br>     <i>Использование рисунков</i>: графическое представление помогает в выявлении важных отношений.<br>   • Полезно следовать некоторым стилистическим соглашениям для уменьшения опасности внесения ошибок в программы и создания программ, легких для чтения, отладки и модификации.<br>   • В пролог-системах обычно имеются средства отладки. Наиболее полезными являются средства трассировки программ.<br>   • Существует много способов повышения эффективности программы. Наиболее простые способы включают в себя:<br>     изменение порядка целей и предложений<br>     управляемый перебор при помощи введения отсечений<br>     запоминание (с помощью assert) решений, которые иначе пришлось бы перевычислять<br>   Более тонкие и радикальные методы связаны с улучшением алгоритмов (особенно, в части повышения эффективности перебора) и с совершенствованием структур данных. <br></div>
</div>
</div>
<h1 align="center">
<a name="TOC_id3593816"></a>Часть 2<br>Пролог в искусственном интеллекте<br></h1>
<div>
<div align="center"><img border="1" src="_52.png"></div>
<h2 align="center">
<a name="TOC_id3593828"></a>Глава 9<br>Операции над структурами данных<br></h2>
<div>
<div>   Один из фундаментальных вопросов программирования — это вопрос о представлении сложных объектов (таких как, например, множества), а также вопрос об эффективной реализации операций над подобными объектами. В этой главе мы рассмотрим несколько часто используемых структур данных, принадлежащих к трем большим семействам: спискам, деревьям и графам. Мы изучим способы представления этих структур на Прологе и составим программы, реализующие некоторые операции над ними, в том числе, сортировку списков, работу с множествами как древовидными структурами, запись элементов данных в дерево, поиск данных в дереве, нахождение пути в графе и т.п. Мы подробно разберем несколько примеров, чрезвычайно поучительных с точки зрения программирования на Прологе.<br></div>
<h3 align="center">
<a name="TOC_id3593852"></a>9.1. Представление списков. Сортировка<br></h3>
<div>
<h4 align="center">
<a name="TOC_id3593858"></a>9.1.1. Замечания в некоторых альтернативных способах представления списков<br></h4>
<div>   В главе 3 была введена специальная система обозначений для списков (специальная прологовская нотация), которую мы и использовали в последующем изложении. Разумеется, это был всего лишь один из способов представления списков на Прологе. <i>Список</i> — это, в самом общем смысле, структура, которая либо<br>   • <i>пуста</i>, либо<br>   • состоит из <i>головы</i> и <i>хвоста</i>, причем хвост должен быть сам списком.<br>   Поэтому для представления этой структуры нам необходимо иметь всего лишь два языковых средства: специальный символ, обозначающий пустой список, и функтор для соединения головы с хвостом. Мы могли бы, например, выбрать<br>   ничего_не_делать<br>   в качестве символа, обозначающего пустой список, и атом<br>   затем<br>   в качестве инфиксного оператора для построения списка по заданным голове и хвосту. Этот оператор мы можем объявить в программе, например, так:<br>   :- op( 500, xfy, затем).<br>   Список<br>   [ войти, сесть, поужинать]<br>   можно было бы тогда записать как<br>   войти затем сесть затем поужинать<br>    затем ничего_не_делать<br>   Важно заметить, что на соответствующем уровне абстракции специальная прологовская нотация и всевозможные альтернативные способы обозначения списков сводятся, фактически, к одному и тому же представлению. В связи с этим типовые операции над списками, такие как<br>   принадлежит ( X, L)<br>   конк( L1, L2, L3)<br>   удалить( X, L1, L2)<br>   запрограммированные нами в специальной прологовской нотации, легко поддаются перепрограммированию в различные системы обозначений, выбранные пользователем. Например, отношение конк транслируется на язык "затем — ничего_не_делать" следующим образом. Определение, которое мы использовали до сих пор, имеет вид<br>   конк( [], L, L).<br>   конк( [X | L1], L2, [X | L3] ) :-<br>    конк( L1, L2, L3).<br>   В новой системе обозначений оно превращается в<br>   конк( ничего_не_делать, L, L).<br>   конк( X затем L1, L2, X затем L3) :-<br>    конк(L1, L2, L3).<br>   Этот пример показывает, как легко наши определения отношений над списками обобщаются на весь класс структур этого типа. Решение о том, какой именно способ записи списков будет использоваться в той или иной программе, следует принимать в соответствии с тем смыслом, который мы придаем списку в каждом конкретном случае. Если, например, список — это просто множество элементов, то наиболее удобна обычная прологовская нотация, поскольку в ней непосредственно выражается то, что программист имел в виду. С другой стороны, некоторые типы выражений также можно трактовать как своего рода списки. Например, для конъюнктов в исчислении высказываний подошло бы следующее спископодобное представление:<br>   • истина соответствует пустому списку,<br>   • &amp; — оператор для соединения головы с хвостом, определяемый, например, как<br>   :- op( 300, xfy, &amp;)<br>   Конъюнкция членов а, b, и с выглядела бы тогда как<br>   а &amp; b &amp; с &amp; истина<br>   Все приведенные примеры базируются, по существу, на одной и той же структуре, представляющей список. Однако в гл. 8 мы рассмотрели существенно другой способ, влияющий на эффективность вычислений. Уловка состояла в том, что список представлялся в виде пары списков, являясь их "разностью". Было показано, что такое представление приводит к очень эффективной реализации отношения конкатенации.<br>   Материал настоящего раздела проливает свет и на то различие, которое существует между применением операторов в математике и применением их в Прологе. В математике с каждым оператором всегда связано некоторое действие, в то время как в Прологе операторы используются просто для представления структур.<br><h5>Упражнения</h5>   <b>9.1.</b> Определите отношение<br>   список( Объект)<br>   для распознавания случаев, когда Объект является стандартным прологовским списком.<br>   <b>9.2.</b> Определите отношение принадлежности к списку, используя систему обозначений, введенную в этой разделе: "затем — ничего_не_делать".<br>   <b>9.3.</b> Определите отношение<br>   преобр( СтандСпис, Спис)<br>   для преобразования списков из стандартного представления в систему "затем — ничего_не_делать". Например:<br>   преобр( [а, b], а затем b затем ничего_не_делать)<br>   ответ<br>   <b>9.4.</b> Обобщите отношение преобр на случай произвольного альтернативного представления списков. Конкретное представление задается символом, обозначающим пустой список, и функтором для соединения головы с хвостом. В отношении преобр придется добавить два новых аргумента:<br>   преобр( СтандСпис, Спис, Функтор, ПустСпис)<br>   Примеры применения этого отношения:<br>   ?- пpeoбp( [а, b], L, затем, ничего_не_делать).<br>   L = а затем b затем ничего_не_делать<br>
		 <br>   ?-  преобр( [а, b, с], L, +, 0).<br>   L = а+(b+(с+0) )<br></div>
<h4 align="center">
<a name="TOC_id3594142"></a>9.1.2. Сортировка списков<br></h4>
<div>   Сортировка применяется очень часто. Список можно отсортировать (упорядочить), если между его элементами определено отношение порядка. Для удобства изложения мы будем использовать отношение порядка<br>   больше( X, Y)<br>   означающее, что X <i>больше, чем</i> Y, независимо от того, что мы в действительности понимаем под "больше, чем". Если элементами списка являются числа, то отношение больше будет, вероятно, определено как<br>   больше( X, Y) :- X &gt; Y.<br>   Если же элементы списка — атомы, то отношение больше может соответствовать алфавитному порядку между ними.<br>   Пусть<br>   сорт( Спис, УпорСпис)<br>   обозначает отношение, в котором Спис — некоторый список, а УпорСпис — это список, составленный из тех же элементов, но упорядоченный по возрастанию в соответствия с отношением больше. Мы построим три определения этого отношения на Прологе, основанные на трех различных идеях о механизме сортировки. Вот первая идея:<br><blockquote>   Для того, чтобы упорядочить список Спис, необходимо:<br>   • Найти в Спис два смежных элемента X и Y, таких, что больше( X, Y), и поменять X и Y местами, получив тем самым новый список Спис1; затем отсортировать Спис1.<br>   • Если в Спис нет ни одной пары смежных элементов X и Y, таких, что больше( X, Y), то считать, что Спис уже отсортирован.<br></blockquote>   Мы переставили местами 2 элемента X и Y, расположенные в списке "не в том порядке", с целью приблизить список к своему упорядоченному состоянию. Имеется в виду, что после достаточно большого числа перестановок все элементы списка будут расположены в правильном порядке. Описанный принцип сортировки принято называть <i>методом пузырька</i>, поэтому соответствующая прологовская процедура будет называться пузырек.<br>   пузырек( Спис, УпорСпис) :-<br>    перест( Спис, Спис1), !, % Полезная перестановка?<br>    пузырек( Спис1, УпорСпис).<br>   пузырек( УпорСпис, УпорСпис).<br>     % Если нет, то список уже упорядочен<br>
		 <br>   перест( [X, Y | Остаток], [Y, X ) Остаток] ):-<br>    % Перестановка первых двух элементов<br>    больше( X, Y).<br>   перест( [Z | Остаток], [Z | Остаток1] ):-<br>    перест( Остаток, Остаток1). % Перестановка в хвосте<br>   Еще один простой алгоритм сортировки называется <i>сортировкой со вставками.</i> Он основан на следующей идее:<br><blockquote>   Для того, чтобы упорядочить непустой список L = [X | Хв], необходимо:<br>   (1) Упорядочить хвост Хв списка  L.<br>   (2) Вставить голову X списка L в упорядоченный хвост, поместив ее в такое место, чтобы получившийся список остался упорядоченным. Список отсортирован.<br></blockquote>   Этот алгоритм транслируется в следующую процедуру вставсорт на Прологе:<br>   вставсорт([], []).<br>   вставсорт( [X | Хв], УпорСпис) :-<br>    вставсорт( Хв, УпорХв), % Сортировка хвоста<br>
		 <br>   встав( X, УпорХв, УпорСпис).<br>     % Вставить X на нужное место<br>   встав( X, [Y | УпорСпис], [Y | УпорСпис1]):-<br>    больше( X, Y), !,<br>    встав( X, УпорСпис, УпорСпис1).<br>   встав( X, УпорСпис, [X | УпорСпис] ).<br><div align="center"><img border="1" src="_53.png"></div>   <b>Рис. 9.1.</b> Сортировка списка процедурой быстрсорт.<br>   Процедуры сортировки пузырек и вставсорт просты, но не эффективны. Из этих двух процедур процедура со вставками более эффективна, однако среднее время, необходимое для сортировки списка длиной  <i>n</i>  процедурой вставсорт, возрастает с ростом <i>n</i> пропорционально <i>n</i>&#178;. Поэтому для длинных списков значительно лучше работает алгоритм <i>быстрой сортировки</i>, основанный на следующей идее (рис. 9.1):<br><blockquote>   Для того, чтобы упорядочить непустой список L,  необходимо:<br>   (1) Удалить из списка L какой-нибудь элемент X и разбить оставшуюся часть на два списка, называемые Меньш и Больш, следующим образом: все элементы большие, чем X, принадлежат списку Больш, остальные — списку Меньш.<br>   (2) Отсортировать список Меньш, результат — список УпорМеньш.<br>   (3) Отсортировать список Больш, результат — список УпорБольш.<br>   (4) Получить результирующий упорядоченный список как конкатенацию списков УпорМеньш и [ X | УпорБольш].<br></blockquote>   Заметим, что если исходный список пуст, то результатом сортировки также будет пустой список. Реализация быстрой сортировки на Прологе показана на рис. 9.2. Здесь в качестве элемента X, удаляемого из списка, всегда выбирается просто голова этого списка. Разбиение на два списка запрограммировано как отношение с четырьмя аргументами:<br>   разбиение( X, L, Больш, Меньш).<br>   Временная сложность нашего алгоритма зависит от того, насколько нам повезет при разбиении сортируемого списка. Если списки всегда разбиваются на два списка примерно равной длины, то процедура сортировки имеет временную сложность порядка <i>n </i>log <i>n</i>, где <i>n</i> — длина исходного списка. Если же, наоборот, разбиение всегда приводит к тому, что один из списков оказывается значительно больше другого, то сложность будет порядка  <i>n</i>&#178;. Анализ показывает, что, к счастью, средняя производительность быстрой сортировки ближе к лучшему случаю, чем к худшему.<br>   Программу, показанную на рис. 9.2, можно усовершенствовать, если реализовать операцию конкатенации более эффективно. Напомним, что конкатенация становится тривиальной операцией после применения разностного представления списков, введенного в гл. 8. Для того, чтобы использовать эту идею в нашей процедуре сортировки, нужно представить встречающиеся в ней списки в форме пар вида A-Z следующим образом:<br>    УпорМеньш имеет вид A1-Z1<br>    УпорБольш имеет вид A2-Z2<br>
		 <br>   быстрсорт( [], [] ).<br>   быстрсорт( [X | Хвост], УпорСпис) :-<br>    разбиение( X, Хвост, Меньш, Больш),<br>    быстрсорт( Меньш, УпорМеньш),<br>    быстрсорт( Больш, УпорБольш),<br>    конк( УпорМеньш, [X | УпорБольш], УпорСпис).<br>
		 <br>   разбиение( X, [], [], [] ).<br>   разбиение( X, [Y | Хвост], [Y | Меньш], Больш ) :-<br>    больше( X, Y), !,<br>    разбиение( X, Хвост, Меньш, Больш).<br>   разбиение( X, [Y | Хвост], Меньш, [Y | Больш] ) :-<br>    разбиение( X, Хвост, Меньш, Больш).<br>
		 <br>   конк( [], L, L).<br>   конк( [X | L1], L2, [X | L3] ) :-<br>    конк( L1, L2, L3 ).<br>   <b>Рис. 9.2.</b> Быстрая сортировка.<br>
		 <br>   Тогда конкатенации списков<br>   УпорМеньш и [ X | УпорБольш]<br>   будет соответствовать конкатенация пар<br>   A1-Z1 и [ X | A2]-Z2<br>   В результате мы получим<br>   А1-Z2, причем Z1 = [ X | А2]<br>   Пустой список представляется парой Z-Z. Систематически вводя изменения в программу рис. 9.2, мы получим более эффективный способ реализации процедуры быстрсорт, показанный на рис. 9.3 под именем быстрсорт2. Здесь, как и раньше, процедура быстрсорт использует обычное представление списков, но в действительности сортировку выполняет более эффективная процедура быстрсорт2, использующая разностное представление. Эти две процедуры связаны между собой, соотношением<br>   быстрсорт( L, S) :-<br>    быстрсорт2( L, S-[] ).<br>
		 <br>   быстрсорт( Спис, УпорСпис) :-<br>    быстрсорт2( Спис, УпорСпис-[] ).<br>
		 <br>   быстрсорт2( [], Z-Z).<br>   быстрсорт2( [X | Хвост], A1-Z2) :-<br>    разбиение( X, Хвост, Меньш, Больш),<br>    быстрсорт2( Меньш, А1-[X | A2] ),<br>    быстрсорт2( Больш, A2-Z2).<br>   <b>Рис. 9.3.</b> Более эффективная реализация процедуры быстрсортс использованием разностного представления списков. Отношение разбиение( X, Спис, Меньш, Больш) определено, как на рис. 9.2.<br>
		 <br><h5>Упражнения</h5>   <b>9.5.</b> Напишите процедуру слияния двух упорядоченных списков в один третий список. Например:<br>   ?- слить( [2, 5, 6, 6, 8], [1, 3, 5, 9], L).<br>   L = [1, 2, 3, 5, 5, 6, 6, 8, 9]<br>   <b>9.6.</b> Программы сортировки, показанные на рис. 9.2 и 9.3, отличаются друг от друга способом представления списков. Первая из них использует обычное представление, в то время как вторая — разностное представление. Преобразование из одного представления в другое очевидно и может быть автоматизировано. Введите в программу рис. 9.2 необходимые изменения, чтобы преобразовать ее в программу рис. 9.3.<br>   <b>9.7.</b> Наша программа быстрсорт в случае, когда исходный список уже упорядочен или почти упорядочен, работает очень неэффективно. Проанализируйте причины этого явления.<br>   <b>9.8.</b> Существует еще одна хорошая идея относительно механизма сортировки списков, позволяющая избавиться от недостатков программы быстрсорт, а именно: разбить список на два меньших списка, отсортировать их, а затем слить вместе. Итак, для того, чтобы отсортировать список L, необходимо<br>   • разбить L на два списка L1 и L2 примерно одинаковой длины;<br>   • произвести сортировку списков L1 и L2,получив списки S1 и S2;<br>   • слить списки S1 и S2, завершив на этом сортировку списка L.<br>   Реализуйте этот принцип сортировки и сравните его эффективность с эффективностью программы быстрсорт.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3594853"></a>9.2. Представление множеств двоичными деревьями<br></h3>
<div>   Списки часто применяют для представления множеств. Такое использование списков имеет тот недостаток, что проверка принадлежности элемента множеству оказывается довольно неэффективной. Обычно предикат принадлежит( X, L) для проверки принадлежности X к L программируют так:<br>   принадлежит X, [X | L] ).<br>   принадлежит X, [ Y | L] ) :-<br>    принадлежит( X, L).<br>   Для того, чтобы найти X в списке L, эта процедура последовательно просматривает список элемент за элементом, пока ей не встретится либо элемент X, либо конец списка. Для длинных списков такой способ крайне неэффективен.<br>   Для облегчения более эффективной реализация отношения принадлежности применяют различные древовидные структуры. В настоящем разделе мы рассмотрим двоичные деревья.<br>   Двоичное дерево либо пусто, либо состоит из следующих трех частей:<br>   • корень<br>   • левое поддерево<br>    правое поддерево<br>   Корень может быть чем угодно, а поддеревья должны сами быть двоичными деревьями. На рис. 9.4 показано представление множества [а, b, с, d] двоичным деревом. Элементы множества хранятся в виде вершин дерева. Пустые поддеревья на рис. 9.4 не показаны. Например, вершина b имеет два поддерева, которые оба пусты.<br>   Существует много способов представления двоичных деревьев на Прологе. Одна из простых возможностей — сделать корень главным функтором соответствующего терма, а поддеревья — его аргументами. Тогда дерево рис. 9.4 примет вид<br>   а( b, с( d) )<br>   Такое представление имеет среди прочих своих недостатков то слабое место, что для каждой вершины дерева нужен свой функтор. Это может привести к неприятностям, если вершины сами являются структурными объектами.<br><div align="center"><img border="1" src="_54.png"></div>   <b>Рис. 9.4.</b> Двоичное дерево.<br>   Существует более эффективный и более привычный способ представления двоичных деревьев: нам нужен специальный символ для обозначения пустого дерева и функтор для построения непустого дерева из трех компонент (корня и двух поддеревьев). Относительно функтора и специального символа сделаем следующий выбор:<br>   • Пусть атом nil представляет пустое дерево.<br>   • В качестве функтора примем дер, так что дерево с корнем X, левым поддеревом L и правым поддеревом R будет иметь вид терма дер( L, X, R) (см. рис. 9.5).<br>   В этом представлении дерево рис. 9.4 выглядит как<br>   дер( дер( nil, b, nil), a,<br>    дер( дер( nil, d, nil), с, nil) ).<br>   Теперь рассмотрим отношение принадлежности, которое будем обозначать внутри. Цель<br>   внутри( X, T)<br>   истинна, если X есть вершина дерева T. Отношение внутри можно определить при помощи следующих правил:<br><blockquote>   X есть вершина дерева T, если<br>   • корень дерева T совпадает с X, или<br>   • X — это вершина из левого поддерева, или<br>   • X — это вершина из правого поддерева.<br></blockquote>
<div align="center"><img border="1" src="_55.png"></div>   <b>Рис. 9.5.</b> Представление двоичных деревьев.<br>   Эти правила непосредственно транслируются на Пролог следующим образом:<br>   внутри( X, дер( _, X, _) ).<br>   внутри( X, дер( L, _, _) ) :-<br>    внутри( X, L).<br>   внутри( X, дер( _, _, R) ) :-<br>    внутри( X, R).<br>   Очевидно, что цель<br>   внутри( X, nil)<br>   терпит неудачу при любом X.<br>   Посмотрим, как ведет себя наша процедура. Рассмотрим рис. 9.4. Цель<br>   внутри( X, T)<br>   используя механизм возвратов, находит все элементы данных, содержащиеся в множестве, причем обнаруживает их в следующем порядке:<br>   X = а; X = b; X = с; X = d<br>   Теперь рассмотрим вопрос об эффективности. Цель<br>   внутри( а, T)<br>   достигается сразу же после применения первого предложения процедуры внутри. С другой стороны, цель<br>   внутри( d, T)<br>   будет успешно достигнута только после нескольких рекурсивных обращений. Аналогично цель<br>   внутри( e, T)<br>   потерпит неудачу только после того, как будет просмотрено все дерево в результате рекурсивного применения процедуры внутри ко <i>всем</i> поддеревьям дерева T.<br>   В этом последнем случае мы видим такую же неэффективность, как если бы мы представили множество просто списком. Положение можно улучшить, если между элементами множества существует отношение порядка. Тогда можно упорядочить данные в дереве слева направо в соответствии с этим отношением.<br><div align="center"><img border="1" src="_56.png"></div>   <b>Рис. 9.6.</b> Двоичный справочник. Элемент 6 найден после прохода по отмеченному пути 5&#8594;8&#8594;6.<br>   Будем говорить, что непустое дерево дер( Лев, X, Прав) упорядочено слева направо, если<br>   (1) все вершины левого поддерева Лев меньше X;<br>   (2) все вершины правого поддерева Прав больше X;<br>   (3) оба поддерева упорядочены.<br>   Будем называть такое двоичное дерево <i>двоичным справочником</i>. Пример показан на рис. 9.6.<br>   Преимущество упорядочивания состоит в том, что для поиска некоторого объекта в двоичном справочнике всегда достаточно просмотреть не более одного поддерева. Экономия при поиске объекта X достигается за счет того, что, сравнив X с корнем, мы можем сразу же отбросить одно из поддеревьев. Например, пусть мы ищем элемент 6 в дереве, изображенной на рис. 9.6. Мы начинаем с корня 5, сравниваем 6 с 5, получаем 6 &gt; 5. Поскольку все элементы данных в левом поддереве должны быть меньше, чем 5, единственная область, в которой еще осталась возможность найти элемент 6, — это правое поддерево. Продолжаем поиск в правом поддереве, переходя к вершине 8, и т.д.<br>   Общий метод поиска в двоичном справочнике состоит в следующем:<br><blockquote>   Для того, чтобы найти элемент X в справочнике Д, необходимо:<br>   • если X — это корень справочника Д, то считать, что X уже найден, иначе<br>   • если X меньше, чем корень, то искать X в левом поддереве, иначе<br>   • искать X в правом поддереве;<br>   • если справочник Д пуст, то поиск терпит неудачу.<br></blockquote>   Эти правила запрограммированы в виде процедуры, показанной на рис. 9.7. Отношение больше( X, Y), означает, что X больше, чем Y. Если элементы, хранимые в дереве, — это числа, то под "больше, чем" имеется в виду просто X &gt; Y.<br>   Существует способ использовать процедуру внутри также и для <i>построения</i> двоичного справочника. Например, справочник Д, содержащий элементы 5, 3, 8, будет построен при помощи следующей последовательности целей:<br>   ?- внутри( 5, Д), внутри( 3, Д), внутри( 8, Д).<br>   Д = дер( дер( Д1, 3, Д2), 5, дер( Д3, 8, Д4) ).<br>   Переменные Д1, Д2, Д3 и Д4 соответствуют четырем неопределенным поддеревьям. Какими бы они ни были, все равно дерево Д будет содержать заданные элементы 3, 5 и 8. Структура построенного дерева зависит от того порядка, в котором указываются цели (рис. 9.8).<br>
		 <br>   внутри( X, дер( _, X, _ ).<br>   внутри( X, дер( Лев, Корень, Прав) ) :-<br>    больше( Корень, X), % Корень больше, чем X<br>   внутри( X, Лев).     % Поиск в левом поддереве<br>   внутри( X, дер( Лев, Корень, Прав) ) :-<br>    больше( X, Корень), % X больше, чем корень<br>    внутри( X, Прав).   % Поиск в правом поддереве<br>   <b>Рис. 9.7.</b> Поиск элемента X в двоичном справочнике.<br>
		 <br><div align="center"><img border="1" src="_57.png"></div>   <b>Рис. 9.8.</b> (а) Дерево Д, построенное как результат достижения целей: внутри( 5, Д), внутри( 3, Д), внутри( 8, Д). (b) Дерево, полученное при другом порядке целей: внутри( 5, Д), внутри( 3, Д), внутри( 8, Д).<br>   Здесь уместно сделать несколько замечаний относительно эффективности поиска в справочниках. Вообще говоря, поиск элемента в справочнике эффективнее, чем поиск в списке. Но насколько? Пусть <i>n</i> — число элементов множества. Если множество представлено списком, то ожидаемое время поиска будет пропорционально его длине <i>n</i>. В среднем нам придется просмотреть примерно половину списка. Если множество представлено двоичным деревом, то время поиска будет пропорционально глубине дерева. Глубина дерева — это длина самого длинного пути между корнем и листом дерева. Однако следует помнить, что глубина дерева зависит от его формы.<br>   Мы говорим, что дерево (приближенно) сбалансировано, если для каждой вершины дерева соответствующие два поддерева содержат примерно равное число элементов. Если дерево хорошо сбалансировано, то его глубина пропорциональна log <i>n</i>. В этом случае мы говорим, что дерево имеет логарифмическую сложность. Сбалансированный справочник лучше списка настолько же, насколько log <i>n</i> меньше <i>n</i>. К сожалению, это верно только для приближенно сбалансированного дерева. Если происходит разбалансировка дерева, то производительность падает. В случае полностью разбалансированных деревьев, дерево фактически превращается в список. Глубина дерева в этом случае равна <i>n</i>, а производительность поиска оказывается столь же низкой, как и в случае списка. В связи с этим мы всегда заинтересованы в том, чтобы справочники были сбалансированы. Методы достижения этой цели мы обсудим в гл. 10.<br><h5>Упражнения</h5>   <b>9.9.</b> Определите предикаты<br>   двдерево( Объект)<br>   справочник( Объект)<br>   распознающие, является ли Объект двоичным деревом или двоичным справочником соответственно. Используйте обозначения, введенные в данном разделе.<br>   <b>9.10.</b> Определите процедуру<br>   глубина( ДвДерево, Глубина)<br>   вычисляющую глубину двоичного дерева в предположении, что глубина пустого дерева равна 0, а глубина одноэлементного дерева равна 1.<br>   <b>9.11.</b> Определите отношение<br>   линеаризация( Дерево, Список)<br>   соответствующее "выстраиванию" всех вершин дерева в список.<br>   <b>9.12.</b> Определите отношение<br>   максэлемент( Д, Элемент)<br>   таким образом, чтобы переменная Элемент приняла значение наибольшего из элементов, хранящихся в дереве Д.<br>   <b>9.13.</b> Внесите изменения в процедуру<br>   внутри( Элемент, ДвСправочник)<br>   добавив в нее третий аргумент Путь таким образом, чтобы можно было бы получить путь между корнем справочника и указанным элементом.<br></div>
<h3 align="center">
<a name="TOC_id3595469"></a>9.3. Двоичные справочники: добавление и удаление элемента<br></h3>
<div>   Если мы имеем дело с динамически изменяемым множеством элементов данных, то нам может понадобиться внести в него новый элемент или удалить из него один из старых. В связи с этим набор основных операций, выполняемых над множеством S, таков:<br>   внутри( X, S)       % X  содержится в  S<br>   добавить( S, X, S1) % Добавить  X  к  S,  результат -  S1<br>   удалить( S, X, S1)  % Удалить  X  из  S,  результат -  S1<br><div align="center"><img border="1" src="_58.png"></div>   <b>Рис. 9.9.</b> Введение в двоичный справочник нового элемента на уровне листьев. Показанные деревья соответствуют следующей последовательности вставок: добавить( Д1, 6, Д2)<b>, </b>добавить( Д2, 6, Д3)<b>, </b>добавить( Д3, 6, Д4)<br>
		 <br>   доблист( nil, X, дер( nil, X, nil) ).<br>   доблист( дер( Лев, X, Прав), X, дер( Лев, X, Прав) ). <br>   доблист( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав)) :- <br>    больше( Кор, X), <br>   доблист( Лев, X, Лев1)). <br>   доблист( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1)) :- <br>    больше( X, Кор), <br>    доблист( Прав, X, Прав1). <br>   <b>Рис. 9.10.</b> Вставление в двоичный справочник нового элемента в качестве листа.<br>
		 <br>   Определим отношение <i>добавить</i>. Простейший способ: ввести новый элемент на самый нижний уровень дерева, так что он станет его листом. Место, на которое помещается новый элемент, выбрать таким образом, чтобы не нарушить упорядоченность дерева. На рис. 9.9 показано, какие изменения претерпевает дерево в процессе введения в него новых элементов. Назовем такой метод вставления элемента в множество<br>   доблист( Д, X, Д1)<br>   Правила добавления элемента на уровне листьев таковы:<br>   • Результат добавления элемента X к пустому дереву есть дерево дер( nil, X, nil).<br>   • Если X совпадает с корнем дерева Д, то Д1 = Д (в множестве не допускается дублирования элементов).<br>   • Если корень дерева Д больше, чем X, то X вносится в левое поддерево дерева Д; если корень меньше, чем X, то X вносится в правое поддерево.<br>   На рис. 9.10 показана соответствующая программа.<br>   Теперь рассмотрим операцию <i>удалить</i>. Лист дерева удалить легко, однако удалить какую-либо внутреннюю вершину — дело не простое. Удаление листа можно на самом деле определить как операцию, обратную операции добавления листа:<br>   удлист( Д1, X, Д2) :-<br>    доблист( Д2, X, Д1).<br><div align="center"><img border="1" src="_59.png"></div>   <b>Рис. 9.11.</b> Удаление X из двоичного справочника. Возникает проблема наложения "заплаты" на место удаленного элемента X.<br>   К сожалению, если X — это внутренняя вершина, то такой способ не работает, поскольку возникает проблема, иллюстрацией к которой служит рис. 9.11. Вершина X имеет два поддерева Лев и Прав. После удаления вершины X в дереве образуется "дыра", и поддеревья Лев и Прав теряют свою связь с остальной частью дерева. К вершине А оба эти поддерева присоединить невозможно, так как вершина А способна принять только одно из них.<br>   Если одно из поддеревьев <b>Лев</b> и <b>Прав</b> пусто, то существует простое решение: подсоединить к А непустое поддерево. Если же оба поддерева непусты, то можно использовать следующую идею (рис. 9.12): если самую левую вершину Y поддерева Прав переместить из ее текущего положения вверх и заполнить ею пробел, оставшийся после X, то упорядоченность дерева не нарушится. Разумеется, та же идея сработает и в симметричном случае, когда перемещается самая правая вершина поддерева Лев.<br><div align="center"><img border="1" src="_60.png"></div>   <b>Рис. 9. 2.</b> Заполнение пустого места после удаления X.<br>   На рис. 9.13 показана программа, реализующая операцию удаления элементов в соответствии с изложенными выше соображениями. Основную работу по перемещению самой левой вершины выполняет отношение<br>   удмин( Дер, Y, Дер1)<br>   Здесь Y — минимальная (т.е. самая левая) вершина дерева Дер, а Дер1 — то, во что превращается дерево Дер после удаления вершины Y.<br>   Существует другой, элегантный способ реализация операции <i>добавить</i> и <i>удалить</i>. Отношение <i>добавить</i> можно сделать недетерминированным в том смысле, что новый элемент вводится на произвольный уровень дерева, а не только на уровень листьев. Правила таковы:<br><blockquote>   Для того, чтобы добавить X в двоичный справочник Д, необходимо одно из двух:<br>   • добавить X на место корня дерева (так, что X станет новым корнем) или<br>   • если корень больше, чем X, то внести X в левое поддерево, иначе — в правое поддерево.<br></blockquote>
		 <br>   уд( дер( nil, X, Прав), X, Прав).<br>   уд( дер( Лев, X, nil), X, Лев).<br>   уд( дер( Лев, X, Прав), X, дер( Лев,Y, Прав1) ) :-<br>    удмин( Прав, Y, Прав1).<br>   уд( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав) ) :-<br>    больше( Кор, X),<br>    уд( Лев, X, Лев1).<br>   уд( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1) ) :-<br>    больше( X, Кор),<br>    уд( Прав, X, Прав1).<br>
		 <br>   удмин( дер( nil, Y, Прав), Y, Прав).<br>   удмин( дер( Лев, Кор, Прав), Y, дер( Лев1, Кор, Прав) ) :-<br>    удмин( Лев, Y, Лев1).<br>   <b>Рис. 9.13.</b> Удаление элемента из двоичного справочника.<br>
		 <br>   Трудным моментом здесь является введение X на место корня. Сформулируем эту операций в виде отношения<br>   добкор( Д, X, X1)<br>   где X — новый элемент, вставляемый вместо корня в Д, а Д1 — новый справочник с корнем X. На рис. 9.14 показано, как соотносятся X, Д и Д1. Остается вопрос: что из себя представляют поддеревья L1 и L2 (или, соответственно, R1 и R2) на рис. 9.14?<br><div align="center"><img border="1" src="_61.png"></div>   <b>Рис. 9.14.</b> Внесение X в двоичный справочник в качестве корня.<br>   Ответ мы получим, если учтем следующие ограничения на L1, L2:<br>   • L1 и L2 — двоичные справочники;<br>   • множество всех вершин, содержащихся как в L1, так и в L2, совпадает с множеством вершин справочника L;<br>   • все вершины из L1 меньше, чем X; все вершены из L2 больше, чем X.<br>   Отношение, которое способно наложить все эти ограничения на L1, L2, — это как раз и есть наше отношение добкор. Действительно, если бы мы вводили X в L на место корня, то поддеревьями результирующего дерева как раз и оказались бы L1 и L2. В терминах Пролога L1 и L2 должны быть такими, чтобы достигалась цель<br>   добкор( L, X, дер( L1, X, L2) ).<br>   Те же самые ограничения применимы к R1, R2:<br>   добкор( R, X, дер( R1, X, R2) ).<br>   На рис. 9.15 показана программа для "недетерминированного" добавления элемента в двоичный справочник.<br>
		 <br>   добавить( Д, X, Д1) :-               % Добавить X на место корня<br>    добкор( Д, X, Д1).<br>   добавить( дер( L, Y, R), X, дер( L1, Y, R) ) :-<br>    больше( Y, X),                      % Ввести X в левое поддерево<br>    добавить( L, X, L1).<br>   добавить( дер( L, Y, R), X, дер( L, Y, R1) ) :-<br>    больше( X, Y),                      % Ввести X в правое поддерево<br>    добавить( R, X, R1).<br>
		 <br>   добкор( nil, X, дер( nil, X, nil) ). % Ввести X в пустое дерево<br>   добкор( дер( L, Y, R), X, дер( L1, X, дер( L2, Y, R) )) :-<br>    больше( Y, X),<br>    добкор( L, X, дер( L1, X, L2) ).<br>   добкор( дep( L, Y, R), X, дep( дep( L, Y, R1), X, R2) ) :-<br>    больше( X, Y),<br>    добкор( R, X, дер( R1, X, R2) ).<br>   <b>Рис. 9.15.</b> Внесение элемента на произвольный уровень двоичного справочника.<br>
		 <br>   Эта процедура обладает тем замечательным свойством, что в нее не заложено никаких ограничений на уровень дерева, в который вносится новый элемент. В связи с этим операцию <i>добавить</i> можно использовать "в обратном направлении" для удаления элемента из справочника. Например, приведенная ниже последовательность целей строит справочник Д, содержащий элементы 3, 5, 1, 6, а затем удаляет из него элемент 5, после чего получается справочник ДД:<br>   добавить( nil, 3, Д1), добавить( Д1, 5, Д2),<br>   добавить( Д2, 1, Д3), добавить( Д3, 6, Д),<br>   добавить( ДД, 5, Д).<br></div>
<h3 align="center">
<a name="TOC_id3595979"></a>9.4. Отображение деревьев<br></h3>
<div>   Так же, как и любые объекты данных в Прологе, двоичное дерево T может быть непосредственно выведено на печать при помощи встроенной процедуры write. Однако цель<br>   write( T)<br>   хотя и отпечатает всю информацию, содержащуюся в дереве, но действительная структура дерева никак при этом не будет выражена графически. Довольно утомительная работа — пытаться представить себе структуру дерева, рассматривая прологовский терм, которым она представлена. Поэтому во многих случаях желательно иметь возможность отпечатать дерево в такой форме, которая графически соответствует его структуре.<br>   Существует относительно простой способ это сделать. Уловка состоит в том, чтобы изображать дерево растущим слева направо, а не сверху вниз, как обычно. Дерево нужно повернуть влево таким образом, чтобы корень стал его крайним слева элементом, а листья сдвинулись вправо (рис. 9.16).<br><div align="center"><img border="1" src="_62.png"></div>   <b>Рис. 9.16.</b> (а) Обычное изображение дерева. (b) То же дерево, отпечатанное процедурой отобр (дуги добавлены для ясности).<br>   Давайте определим процедуру<br>   отобр( T)<br>   так, чтобы она отображала дерево в форме, показанной на рис. 9.16. Принцип работы этой процедуры:<br><blockquote>   Для того, чтобы отобразить непустое дерево T, необходимо:<br>   (1) отобразить правое поддерево дерева T с отступом вправо на расстояние H;<br>   (2) отпечатать корень дерева T;<br>   (3) отобразить левое поддерево дерева T с отступом вправо на расстояние H.<br></blockquote>   Величина отступа H, которую можно выбирать по желанию, — это дополнительный параметр при отображении деревьев. Введем процедуру<br>   отобр2( T, H)<br>   печатающую дерево T с отступом на H пробелов от левого края листа. Связь между процедурами отобр и отобр2 такова:<br>   отобр( T) :- отобр2( T, 0).<br>   На рис. 9.17 показана программа целиком. В этой программе предусмотрен сдвиг на 2 позиции для каждого уровня дерева. Описанный принцип отображения можно легко приспособить для деревьев других типов.<br>
		 <br>   отобр( T) :-<br>    отобр2( T, 0).<br>
		 <br>   отобр2( nil, _ ).<br>   отобр2( дер( L, X, R), Отступ) :-<br>    Отступ2 is Отступ + 2,<br>    отобр2( R, Отступ2),<br>    tab( Отступ), write( X), nl,<br>    отобр( L, Отступ2).<br>   <b>Рис. 9.17.</b> Отображение двоичного дерева.<br>
		 <br><h5>Упражнение</h5>   <b>9.14.</b> Наша процедура изображает дерево, ориентируя его необычным образом: корень находится слева, а листья — справа. Напишите (более сложную) процедуру для отображения дерева, ориентированного обычным образом, т.е. с корнем наверху и листьями внизу. <br></div>
<h3 align="center">
<a name="TOC_id3596137"></a>9.5. Графы <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3596142"></a>9.5.1. Представление графов<br></h4>
<div>   Графы используются во многих приложениях, например для представления отношений, ситуаций или структур задач. Граф определяется как множество <i>вершин</i> вместе с множеством <i>ребер</i>, причем каждое ребро задается парой вершин. Если ребра направлены, то их также называют <i>дугами</i>. Дуги задаются <i>упорядоченными</i> парами. Такие графы называются <i>направленными</i>. Ребрам можно приписывать стоимости, имена или метки произвольного вида, в зависимости от конкретного приложения. На рис. 9.18 показаны примеры графов.<br>   В Прологе графы можно представлять различными способами. Один из них — каждое ребро записывать в виде отдельного предложения. Например, графы, показанные на рис. 9.18, можно представить в виде следующего множества предложений:<br>   связь( а, b).<br>   связь( b, с).<br>   ...<br>   дуга( s, t, 3).<br>   дуга( t, v, 1).<br>   дуга( u, t, 2).<br>   ...<br>   Другой способ — весь граф представлять как один объект. В этом случае графу соответствует пара множеств — множество вершин и множество ребер. Каждое множество можно задавать при помощи списка, каждое ребро — парой вершин. Для объединения двух множеств в пару будем применять функтор граф, а для записи ребра — функтор p. Тогда (ненаправленный) граф рис. 9.18 примет вид:<br>   G1 = граф( [a, b, c, d],<br>    [p( а, b), p( b, d), p( b, с), p( c, d)] )<br><div align="center"><img border="1" src="_63.png"></div>   <b>Рис. 9.18.</b> (а) Граф. (b) Направленный граф. Каждой дуге приписана ее стоимость.<br>   Для представления направленного графа (рис. 9.18), применив функторы диграф и д (для дуг), получим<br>   G2 = диграф( [s, t, u, v],<br>    [д( s, t, 3), д( t, v, 1), д( t, u, 5), д( u, t, 2),<br>     д( v, u, 2) ] )<br>   Если каждая вершина графа соединена ребром еще по крайней мере с одной вершиной, то в представлении графа можно опустить множество вершин, поскольку оно неявным образом содержится в списке ребер.<br>   Еще один способ представления графа — связать с каждой вершиной список смежных с ней вершин. В этом случае граф превращается в список пар, каждая из которых состоит из вершины- плюс ее список смежности. Наши графы (рис. 9.18), например, можно представить как<br>   G1 = [ a-&gt;[b1, b-&gt;[a, c, d], c-&gt;[b, d], d-&gt;[b, c] ]<br>   G2 = [s-&gt;[t/3], t-&gt;[u/5, v/l], u-&gt;[t/2], v-&gt;[u/2]]<br>   Здесь символы '-&gt;' и '/' — инфиксные операторы.<br>   Какой из способов представления окажется более удобным, зависит от конкретного приложения, а также от того, какие операции имеется в виду выполнять над графами. Вот типичные операции:<br>   • найти путь между двумя заданными вершинами;<br>   • найти подграф, обладающий некоторыми заданными свойствами.<br>   Примером последней операции может служить построение основного дерева графа. В последующих разделах, мы рассмотрим некоторые простые программы для поиска пути в графе и построения основного дерева. <br></div>
<h4 align="center">
<a name="TOC_id3596319"></a>9.5.2. Поиск пути в графе<br></h4>
<div>   Пусть G — граф, а А и Z — две его вершины. Определим отношение<br>   путь( А, Z, G, P)<br>   где P — ациклический путь между А и Z в графе G. Если G — граф, показанный в левой части рис. 9.18, то верно:<br>   путь( a, d, G, [a, b, d] )<br>   путь( а, d, G, [a, b, c, d] )<br>   Поскольку путь не должен содержать циклов, любая вершина может присутствовать в пути не более одного раза. Вот один из методов поиска пути:<br><blockquote>   Для того, чтобы найти ациклический путь P между А и Z в графе G, необходимо:<br>   Если А = Z , то положить P = [А], иначе найти ациклический путь P1 из произвольной вершины Y в Z, а затем найти путь из А в Y, не содержащий вершин из P1.<br></blockquote>   В этой формулировке неявно предполагается, что существует еще одно отношение, соответствующее поиску пути со следующий ограничением: путь не должен проходить через вершины из некоторого подмножества (в данном случае P1) множества всех вершин графа. В связи с этим мы определим ещё одну процедуру:<br>   путь1( А, P1, G, P)<br>   Аргументы в соответствии с рис. 9.19 имеют следующий смысл:<br>   • А — некоторая вершина,<br>   • G — граф,<br>   • P1 — путь в G,<br>   • P — ациклический путь в G, идущий из А в начальную вершину пути P1, а затем — вдоль пути P1 вплоть до его конца.<br><div align="center"><img border="1" src="_64.png"></div>   <b>Pис. 9.19.</b> Отношение путь1: Путь — это путь между А и Z, в своей заключительной части он перекрывается с Путь1.<br>   Между путь и путь1 имеется следующее соотношение:<br>   путь( А, Z, G, P) :- путь1( А, [Z], G, P).<br>   На рис. 9.19 показана идея рекурсивного определения отношения путь1. Существует "граничный" случай, когда начальная вершина пути P1 (Y на рис. 9.19) совпадает с начальной вершиной А пути P. Если же начальные вершины этих двух путей не совпадают, то должна существовать такая вершина X, что<br>   (1) Y — вершина, смежная с X,<br>   (2) X не содержится в P1 и<br>   (3) для P выполняется отношение путь1( А, [X | P1], G, P).<br>
		 <br>   путь( A, Z, Граф, Путь) :-<br>    путь1( А, [Z], Граф, Путь).<br>
		 <br>   путь1( А, [А | Путь1, _, [А | Путь1] ).<br>   путь1( А, [Y | Путь1], Граф, Путь) :-<br>    смеж( X, Y, Граф),<br>    принадлежит( X, Путь1), % Условие отсутствия цикла<br>    путь1( А, [ X, Y | Путь1], Граф, Путь).<br>   <b>Рис. 9.20.</b> Поиск в графе Граф ациклического пути Путь из А в Z.<br>
		 <br>   На рис. 9.20 программа показана полностью. Здесь принадлежит — отношение принадлежности элемента списку. Отношение<br>   смеж( X, Y, G)<br>   означает, что в графе G существует дуга, ведущая из X в Y. Определение этого отношения зависит от способа представления графа. Если G представлен как пара множеств (вершин и ребер)<br>   G = граф( Верш, Реб)<br>   то<br>   смеж( X, Y, граф( Верш, Реб) ) :-<br>    принадлежит( p( X, Y), Реб);<br>    принадлежит( p( Y, X), Реб).<br>   Классическая задача на графах — поиск Гамильтонова цикла, т.е. ациклического пути, проходящего через все вершины графа. Используя отношение путь, эту задачу можно решить так:<br>   гамильтон( Граф, Путь) :-<br>    путь( _, _, Граф, Путь),<br>    всевершины( Путь, Граф).<br>
		 <br>   всевершины( Путь, Граф) :-<br>    not (вершина( В, Граф),<br>    not принадлежит( В, Путь) ).<br>   Здесь вершина( В, Граф) означает: В — вершина графа Граф.<br>   Каждому пути можно приписать его стоимость. Стоимость пути равна сумме стоимостей входящих в него дуг. Если дугам не приписаны стоимости, то тогда, вместо стоимости, говорят о длине пути.<br>   Для того, чтобы наши отношения путь и путь1 могли работать со стоимостями, их нужно модифицировать, введя дополнительный аргумент для каждого пути:<br>   путь( А, Z, G, P, С)<br>   путь1( A, P1, C1, G, P, С)<br>   Здесь С — стоимость пути P, a C1 — стоимость пути P1. В отношении смеж также появится дополнительный аргумент, стоимость дуги. На рис. 9.21 показана программа поиска пути, которая строит путь и вычисляет его стоимость.<br>
		 <br>   путь( А, Z, Граф, Путь, Ст) :-<br>    путь1( A, [Z], 0, Граф, Путь, Ст).<br>
		 <br>   путь1( А, [А | Путь1], Ст1, Граф, [А | Путь1], Ст).<br>   путь1( А, [Y | Путь1], Ст1, Граф, Путь, Ст) :-<br>    смеж( X, Y, СтXY, Граф),<br>    not принадлежит( X, Путь1),<br>    Ст2 is Ст1 + СтXY,<br>    путь1( А, [ X, Y | Путь1], Ст2, Граф, Путь, Ст).<br>   <b>Рис. 9.21.</b> Поиск пути в графе: Путь — путь между А и Z в графе Граф стоимостью Ст.<br>
		 <br>   Эту процедуру можно использовать для нахождения пути минимальной стоимости. Мы можем построить путь минимальной стоимости между вершинами Верш1, Верш2 графа Граф, задав цели<br>   путь( Bepш1, Верш2, Граф, МинПуть, МинСт),<br>    not( путь( Верш1, Верш2, Граф, _, Ст), Ст&lt;МинСт )<br>   Аналогично можно среди всех путей между вершинами графа найти путь максимальной стоимости, задав цели<br>   путь( _, _, Граф, МаксПуть, МаксСт),<br>    not( путь( _, _, Граф, _, Ст), Ст &gt; МаксСт)<br>   Заметим, что приведенный способ поиска максимальных и минимальных путей крайне неэффективен, так как он предполагает просмотр всех возможных путей и потому не подходит для больших графов из-за своей высокой временной сложности. В искусственном интеллекте задача поиска пути возникает довольно часто. В главах 11 и 12 мы изучим более сложные методы нахождения оптимальных путей. <br></div>
<h4 align="center">
<a name="TOC_id3596724"></a>9.5.3. Построение остовного дерева<br></h4>
<div>   Граф называется <i>связным</i>, если между любыми двумя его вершинами существует путь. Пусть G = (V, E) — связный граф с множеством вершин V и множеством ребep E. <i>Остовное дерево</i> графа G — это связный граф T = ( V,  E'), где E' — подмножество E такое, что<br>   (1) T — связный граф, <br>   (2) в T нет циклов.<br>   Выполнение этих двух условий гарантирует то, что T — дерево. Для графа, изображенного в левой части рис. 9.18, существует три остовных дерева, соответствующих следующим трем спискам ребер:<br>   Дер1 = [а-b, b-c, c-d]<br>   Дер2 = [а-b, b-d, d-с]<br>   Дер3 = [а-b, b-d, b-c]<br>   Здесь каждый терм вида X-Y обозначает ребро, соединяющее вершины X и Y. В качестве корня можно взять любую из вершин, указанных в списке. Остовные деревья представляют интерес, например в задачах проектирования сетей связи, поскольку они позволяют, имея минимальное число линий, установить связь между любыми двумя узлами, соответствующими вершинам графа.<br>   Определим процедуру<br>   остдерево( G, T)<br>   где T — остовное дерево графа G. Будем предполагать, что G — связный граф. Можно представить себе алгоритмический процесс построения остовного дерева следующим образом. Начать с пустого множества ребер и постепенно добавлять новые ребра, постоянно следя за тем, чтобы не образовывались циклы. Продолжать этот процесс до тех пор, пока не обнаружится, что нельзя присоединить ни одного ребра, поскольку любое новое ребро порождает цикл. Полученное множество ребер будет остовным деревом. Отсутствие циклов можно обеспечить, если придерживаться следующего простого правила: ребро присоединяется к дереву только в том случае, когда одна из его вершин уже содержится в строящемся дереве, а другая пока еще не включена в него. Программа, реализующая эту идею, показана на рис. 9.22. Основное отношение, используемое в этой программе, — это<br>   расширить( Дер1, Дер, G)<br>   Здесь все три аргумента — множества ребер. G — связный граф; Дер1 и Дер — два подмножества G, являющиеся деревьями. Дер — остовное дерево графа G, полученное добавлением некоторого (может быть пустого) множества ребер из G к Дер1. Можно сказать, что "Дер1 расширено до Дер".<br>
		 <br>   % Построение остовного дерева графа<br>   %<br>   % Деревья и графы представлены списками<br>   % своих ребер, например:<br>   % Граф = [а-b, b-с, b-d, c-d]<br>   остдерево( Граф, Дер) :- % Дер - остовное дерево Граф'а<br>    принадлежит( Ребро, Граф),<br>    расширить( [Ребро], Дер, Граф).<br>
		 <br>   расширить( Дер1, Дер, Граф) :-<br>    добребро( Дер1, Дер2, Граф),<br>    расширить( Дер2, Дер, Граф).<br>   расширить( Дер, Дер, Граф) :-<br>    not добребро( Дер, _, Граф).<br>     % Добавление любого ребра приводит к циклу<br>
		 <br>   добребро( Дер, [А-В | Дер], Граф) :-<br>    смеж( А, В, Граф),      % А и В - смежные вершины<br>    вершина( А, Дер).       % А содержится в Дер<br>    not вершина( В, Дер).   % А-В не порождает цикла<br>
		 <br>   смеж( А, В, Граф) :-<br>    принадлежит ( А-В, Граф);<br>    принадлежит ( В-А, Граф).<br>
		 <br>   вершина( А, Граф) :-     % А содержится в графе, если<br>    смеж( А, _, Граф).      % А смежна какой-нибудь вершине<br>   <b>Pис. 9.22.</b> Построение остовного дерева: алгоритмический подход. Предполагается, что Граф — связный граф.<br>
		 <br>   Интересно, что можно написать программу построения остовного дерева совершенно другим, полностью декларативным способом, просто формулируя на Прологе некоторые математические определения. Допустим, что как графы, так и деревья задаются списками своих ребер, как в программе рис. 9.22. Нам понадобятся следующие определения:<br>   (1) T является остовным деревом графа G, если<br>    • T — это подмножество графа G и<br>    • T — дерево и<br>    • T "накрывает" G, т.е. каждая вершина из G содержится также в T.<br>   (2) Множество ребер T есть дерево, если<br>    • T — связный граф и<br>    • T не содержит циклов.<br>   Эти определения можно сформулировать на Прологе (с использованием нашей программы путь из предыдущего раздела) так, как показано на рис. 9.23. Следует, однако, заметить, что эта программа в таком ее виде не представляет практического интереса из-за своей неэффективности.<br>
		 <br>   % Построение остовного дерева<br>   % Графы и деревья представлены списками ребер.<br>   остдерево( Граф, Дер) :-<br>    подмнож( Граф, Дер),<br>    дерево( Дер),<br>    накрывает( Дер, Граф).<br>
		 <br>   дерево( Дер) :-<br>    связи( Дер),<br>    not имеетцикл( Дер).<br>
		 <br>   связи( Дер) :-<br>    not ( вершина( А, Дер), вершина( В, Дер),<br>    not путь( А, А, Дер, _ ) ).<br>
		 <br>   имеетцикл( Дер) :-<br>    смеж( А, В, Дер),<br>    путь( А, В, Дер, [А, X, Y | _ ). % Длина пути &gt; 1<br>
		 <br>   накрывает( Дер, Граф) :-<br>    not ( вершина( А, Граф), not вершина( А, Дер) ).<br>
		 <br>   подмнож( [], []).<br>   подмнож( [ X | L], S) :-<br>    подмнож( L, L1),<br>    ( S = L1; S = [ X | L1] ).<br>   <b>Рис. 9.23.</b> Построение остовного дерева: "декларативный подход".<br>
		 <br>   Отношения вершина и смеж см. на рис. 9. 22.<br><h5>Упражнение</h5>   <b>9.15.</b> Рассмотрите остовные деревья в случае, когда каждому ребру графа приписана его стоимость. Пусть <i>стоимость</i> остовного дерева определена как сумма стоимостей составляющих его ребер. Напишите программу построения для заданного графа его остовного дерева минимальной стоимости.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3597136"></a>Резюме<br></h3>
<div>   В данной главе мы изучали реализацию на Прологе некоторых часто используемых структур данных и соответствующих операций над ними. В том числе<br>   • Списки:<br>     варианты представления списков<br>     сортировка списков:<br>       сортировка методом "пузырька"<br>       сортировка со вставками<br>       быстрая сортировка<br>       эффективность этих процедур<br>   • Представление множеств двоичными деревьями и двоичными справочниками:<br>      поиск элемента в дереве<br>      добавление элемента<br>      удаление элемента<br>      добавление в качестве листа или корня<br>      сбалансированность деревьев и его связь с эффективностью этих операций<br>      отображение деревьев<br>   • Графы:<br>      представление графов<br>      поиск пути в графе<br>      построение остовного дерева<br><h5>Литература</h5>   В этой главе мы занимались такими важными темами, как сортировка и работа со структурами данных для представления множеств. Общее описание структур данных, а также алгоритмов, запрограммированных в данной главе, можно найти, например, в Aho, Hopcroft and Ullman (1974, 1983) или Baase (1978). В литературе рассматривается также поведение этих алгоритмов, особенно их временная сложность. Хороший и краткий обзор соответствующих алгоритмов и результатов их математического анализа можно найти в Gonnet (1984).<br>   Прологовская программа для внесения нового элемента на произвольный уровень дерева (раздел 9.3) была впервые показана автору М. Ван Эмденом (при личном общении).<br>
		 <br>   Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). <i>The Design and Analysis of Computer Algorithms.</i> Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]<br>   Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). <i>Data Structures and Algorithms.</i> Addison-Wesley.<br>   Baase S. (1978). <i>Computer Algorithms.</i> Addison-Wesley.<br>   Gonnet G. H. (1984). <i>Handbook of Algorithms and Data Structures.</i> Addison-Wesley.<br></div>
</div>
<h2 align="center">
<a name="TOC_id3597248"></a>Глава 10<br>Усовершенствованные методы представления множеств деревьями<br></h2>
<div>
<div>   В данной главе мы рассмотрим усовершенствованные методы представления множеств при помощи деревьев. Основная идея состоит в том, чтобы поддерживать сбалансированности или приближенную сбалансированность дерева, с тем чтобы избежать вырождения его в список. Механизмы балансировки деревьев гарантируют, даже в худшем случае, относительно быстрый доступ к элементам данных, хранящихся в дереве, при логарифмическом порядке времени доступа. В этой главе изложено два таких механизма: двоично-троичные (кратко, 2-3) деревья и AVL-деревья. (Для изучения остальных глав понимание данной главы не обязательно.)<br></div>
<h3 align="center">
<a name="TOC_id3597270"></a>10.1. Двоично-троичные справочники<br></h3>
<div>   Двоичное дерево называют хорошо сбалансированным, если оба его поддерева имеют примерно одинаковую глубину (или размер) и сами сбалансированы. Глубина сбалансированного дерева приближенно равна log <i>n</i>, где <i>n</i> — число вершин дерева. Время, необходимое для вычислений, производимых отношениями внутри, добавить и удалить над двоичными справочниками, пропорционально глубине дерева. Таким образом, в случае двоичных справочников это время имеет порядок log <i>n</i>. Логарифмический рост сложности алгоритма, проверяющего принадлежность элемента множеству, — это определенное достижение по сравнению со списковым представлением, поскольку в последнем случае мы имеем линейный рост сложности с ростом размера множества. Однако плохая сбалансированность дерева ведет к деградации производительности алгоритмов, работающие со справочником. В крайнем случае, двоичный справочник вырождается в список, как показано на рис. 10.1. Форма справочника зависит от той последовательности, а которой в всего записываются элементы данных. В лучшей случае мы получаем хорошую балансировку и производительность порядка log <i>n</i>, а в худшем — производительность будет порядка <i>n</i>. Анализ показывает, что в среднем сложность алгоритмов внутри, добавить и удалить сохраняет порядок log <i>n</i> в допущении, что все возможные входные последовательности равновероятны. Таким образом, средняя производительность, к счастью, оказывается ближе к лучшему случаю, чек к худшему. Существует, однако, несколько довольно простых механизмов, которые поддерживают хорошую сбалансированность дерева, вне зависимости от входной последовательности, формирующей дерево. Эти механизмы гарантируют производительность алгоритмов внутри, добавить и удалить порядка log <i>n</i> даже <i>в худшем случае</i>. Один из этих механизмов - двоично-троичные деревья (кратко, 2-3 деревья), а другой — AVL-деревья.<br><div align="center"><img border="1" src="_65.png"></div>   <b>Рис. 10.1.</b> Полностью разбалансированный двоичный справочник. Производительность его та же, что и у списка.<br>   2-3 дерево определяется следующим образом: оно или пусто, или состоит из единственной вершины, или удовлетворяет следующим условиям:<br>   • каждая внутренняя вершина имеет две или три дочерних вершины, и<br>   • все листья дерева находятся на одном и том же уровне.<br>   Двоично-троичным (2-3) справочником называется 2-3 дерево, все элементы данных которого хранятся в листьях и упорядочены слева направо. На рис. 10.2 показан пример. Внутренние вершины содержат метки, равные минимальным элементам тех или иных своих поддеревьев, в соответствии со следующими правилами:<br>   • если внутренняя вершина имеет два поддерева, то она содержит минимальный элемент второго из них;<br>   • если внутренняя вершина имеет три поддерева, то она содержит минимальные элементы второго и третьего поддеревьев.<br><div align="center"><img border="1" src="_66.png"></div>   <b>Рис. 10.2.</b> 2-3 справочник. Отмеченный путь показывает процесс поиска элемента 10.<br>   При поиске элемента X в 2-3 справочнике мы начинаем с корня и двигаемся в направлении самого нижнего уровня, руководствуясь при этом метками внутренних вершин дерева. Пусть корень содержит метки M1 и M2, тогда<br>   • если X &lt; M1, то поиск продолжается в левом поддереве, иначе<br>   • если X &lt; M2, то поиск продолжается в среднем поддереве, иначе —<br>   • в правом поддереве.<br>   Если в корне находится только одна метка М, то переходим к левому поддереву при X &lt; M и к правому поддереву — в противоположном случае. Продолжаем применять сформулированные выше правила, пока не окажемся на самом нижнем уровне дерева, где и выяснится, найден ли элемент X, или же поиск потерпел неудачу.<br>   Так как все листья 2-3 дерева находятся на одном и том же уровне, 2-3 дерево идеально сбалансировано с точки зрения глубины составляющих его поддеревьев. Все пути от корня до листа, которые мы проходим при поиске, имеют одну и ту же длину порядка log<i> n</i>, где <i>n</i> — число элементов, хранящихся в дереве.<br>   При добавлении нового элемента данных 2-3 дерево может расти не только в глубину, но и в ширину. Каждая внутренняя вершина, имеющая два поддерева, может приобрести новое поддерево, что приводит к росту вширь. Если же, с другой стороны, у вершины уже есть три поддерева, и она должна принять еще одно, то она расщепляется на две вершины, каждая из которых берет на себя по два из имеющихся четырех поддеревьев. Образовавшаяся при этом новая вершина передается вверх по дереву для присоединения к одной из выше расположенных вершин. Если же эта ситуация возникает на самом высоком уровне, то дерево вынуждено "вырасти" на один уровень вверх. Рис. 10.3 иллюстрирует описанный принцип.<br><div align="center"><img border="1" src="_67.png"></div>   <b>Рис. 10.3.</b> Вставление нового элемента в 2-3 справочник. Дерево растет сначала вширь, а затем уже вглубь.<br>   Включение нового элемента в 2-3 справочник мы запрограммируем как отношение<br>   доб23( Дер, X, НовДер)<br>   где дерево НовДер получено введением элемента X в дерево Дер. Основную работу мы поручим двум дополнительным отношениям, которые мы назовем встав. Первое из них имеет три аргумента:<br>   встав( Дер, X, НовДер).<br>   Здесь НовДер — результат вставления элемента X в Дер. Деревья Дер и НовДер имеют <i>одну и ту же глубину</i>. Разумеется, не всегда возможно сохранить ту же глубину дерева. Поэтому существует еще одно отношение с пятью аргументами специально для этого случая:<br>   встав( Дер, X, НДа, Mб, НДб).<br>   Имеется в виду, что при вставления X в Дер дерево Дер разбивается на два дерева НДа и НДб, имеющих ту же глубину, что и Дер. Мб — это минимальный элемент из НДб. Пример показан на рис. 10.4.<br><div align="center"><img border="1" src="_68.png"></div>   <b>Рис. 10.4.</b> Объекты, показанные на рисунке, удовлетворяют отношению встав( Дер, 6, НДа, Мб, НДб).<br>   2-3 деревья мы будем представлять в программе следующим образом:<br>   • nil представляет пустое дерево;<br>   • л( X) представляет дерево, состоящее из одной вершины — листа с элементом X;<br>   • в2( Д1, М, Д2) представляет дерево с двумя поддеревьями Д1 и Д2; M — минимальный элемент из Д2;<br>   • в3( Д1, M2, Д2, М3, Д3) представляет дерево с тремя поддеревьями Д1, Д2 и Д3; M2 — минимальный элемент из Д2; М3 — минимальный элемент из Д3; Д1, Д2 и Д3 — 2-3 деревья.<br>   Между доб23 и встав существует следующая связь: если после вставления нового элемента дерево не "вырастает", то<br>   доб23( Дер, X, НовДер) :-<br>    встав( Дер, X, НовДер).<br>   Однако если после вставления элемента глубина дерева увеличивается, то встав порождает два поддерева Д1 и Д2, а затем составляет из них дерево большей глубины:<br>   доб23( Дер, X, в2( Д1, М, Д2) ) :-<br>    встав( Дер, X, Д1, М, Д2).<br>   Отношение встав устроено более сложным образом, поскольку ему приходится иметь дело со многими случаями, а именно вставление в пустое дерево, в дерево, состоящее из одного листа, и в деревья типов в2 и в3. Возникают также дополнительные подслучаи, так как новый элемент можно вставить в первое, либо во второе, либо в третье поддерево. В связи с этим мы определим встав как набор правил таким образом, чтобы каждое предложение процедуры встав имело дело с одним из этих случаев. На рис. 10.5 показаны некоторые из возможных случаев. На Пролог они транслируются следующим образом:<br>   <i>Случай а</i><br>    встав( в2( Д1, M, Д2), X, в2( НД1, M, Д2) ) :-<br>     больше( M, X), % M больше, чем X<br>     встав( Д1, X, НД1).<br>   <i>Случай b</i><br>    встав( в2( Д1, M, Д2), X, в3( НД1а, Мб, НД1б, M, Д2) ) :-<br>     больше( M, X),<br>     встав( Д1, X, НД1а, Мб, НД1б).<br>   <i>Случай с</i><br>    встав( в3( Д1, M2, Д2, М3, Д3), X,<br>     в2( НД1а, Мб, НД1б), M2, в2(Д2, М3, Д3) ) :-<br>     больше( M2, X),<br>     встав( Д1, X, НД1а, Мб, НД1б).<br><div align="center"><img border="1" src="_69.png"></div>   <b>Рис. 10.5.</b> Некоторые из случаев работы отношения встав<b>. </b>(a) встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) ); (b) встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) ); (c) встав( в3( Д1, M2, Д2, М3, Д3), X, в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) ). <br>
		 <br>   % Вставление элемента в 2-3 справочник<br>   доб23( Дер, X, Дер1) :-      % Вставить X в Дер, получить Дер1<br>    встав( Дер, X, Дер1).       % Дерево растет вширь<br>   доб23( Дер, X, в2( Д1, M2, Д2) ) :-<br>    встав( Дер, X, Д1, M2, Д2). % Дерево растет вглубь<br>   доб23( nil, X, л( X) ).<br>
		 <br>   встав( л( А), X, л( А), X, л( X) ) :-<br>    больше( X, А).<br>   встав( л( А), X, л( X), А, л( А) ) :-<br>    больше( А, X).<br>   встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) ) :-<br>    больше( М, X),<br>    встав( Д1, X, НД1).<br>   встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) ) :-<br>    больше( М, X),<br>    встав( Д1, X, НД1а, Мб, НД1б).<br>   встав( в2( Д1, М, Д2), X, в2( Д1, М, НД2) ) :-<br>    больше( X, М),<br>    встав( Д2, X, НД2).<br>   встав( в2( Д1, М, Д2), X, в3( Д1, М, НД2а, Мб, НД2б) ) :-<br>    больше( X, М),<br>    встав( Д2, X, НД2а, Мб, НД2б).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в3( НД1, M2, Д2, М3, Д3) :-<br>    больше( M2, X),<br>    встав( Д1, X, НД1).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) ) :-<br>    больше( M2, X),<br>    встав( Д1, X, НД1а, Мб, НД1б).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в3( Д1, M2, НД2, М3, Д3) ) :-<br>    больше( X, M2), больше( М3, X),<br>    встав( Д2, X, НД2).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в2( Д1, M2, НД2а), Мб, в2( НД2б, М3, Д3) ) :-<br>    больше( X, M2), больше( М3, X),<br>    встав( Д2, X, НД2а, Мб, НД2б).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в3( Д1, M2, Д2, М3, НД3) ) :-<br>    больше( X, М3),<br>    встав( Д3, X, НД3).<br>   встав( в3( Д1, M2, Д2, М3, Д3), X,<br>    в2( Д1, M2, Д2), М3, в2( НД3а, Мб, НД3б) ) :-<br>    больше( X, М3),<br>    встав( Д3, X, НД3а, Мб, НД3б).<br>   <b>Рис. 10.6.</b> Вставление элемента в 2-3 справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу.<br>
		 <br>   Программа для вставления нового элемента в 2-3 справочник показана полностью на рис. 10.6. На рис. 10.7 показана программа вывода на печать 2-3 деревьев.<br>   Наша программа иногда выполняет лишние возвраты. Так, если встав с тремя аргументами терпит неудачу, то вызывается процедура встав с пятью аргументами, которая часть работы делает повторно. Можно устранить источник неэффективности, если, например, переопределить встав как<br>   встав2( Дер, X, Деревья)<br>   где Деревья — список, состоящий либо из одного, либо из трех аргументов:<br>    Деревья = [ НовДер]<b>, </b>если встав( Дер, X, НовДер)<br>   Деревья = [ НДа, Мб, НДб], <br>    если встав( Дер, X, НДа, Мб, НДб)<br>   Теперь отношение доб23 можно переопределить так:<br>   доб23( Д, X, Д1) :-<br>    встав( Д, X, Деревья),<br>    соединить( Деревья, Д1).<br>   Отношение соединить формирует одно дерево Д1 из деревьев, находящихся в списке Деревья.<br>
		 <br>   % Отображение 2-3 справочников<br>   отобр(Д) :- <br>    отобр( Д, 0).<br>   отобр( nil, _ ).<br>   отобр( л(А), H) :-<br>    tab( H), write( A), nl.<br>   отобр( в2( Д1, М, Д2), H) :-<br>    H1 is H + 5,<br>    отобр( Д2, H1),<br>    tab( H), write( --), nl,<br>    tab( H), write( M), nl,<br>    tab( H), write( --), nl,<br>    отобр( Д1, H1).<br>   отобр( в3( Д1, M2, Д2, М3, Д3), H) :-<br>    H1 is H + 5<br>    отобр( Д3, H1),<br>    tab( H), write( --), nl,<br>    tab( H), write( M3), nl,<br>    отобр( Д2, H1),<br>    tab( H), write( M2), nl,<br>    tab( H), write( --), nl,<br>    отобр( Д1, H1).<br>   (a)<br>         15<br>       --<br>       15<br>       --<br>         13<br>     --<br>     13<br>     --<br>         12<br>       --<br>       12<br>         10<br>       10<br>       --<br>          8<br>   --<br>    8<br>   --<br>          7<br>       --<br>        7<br>       --<br>     --<br>      5<br>     --<br>          4<br>       --<br>        4<br>          3<br>        3<br>       --<br>          1<br></div>
<h3 align="center">
<a name="TOC_id3598294"></a>10.2. AVL-дерево: приближенно сбалансированное дерево<br></h3>
<div>   AVL-дерево — это дерево, обладающее следующими свойствами:<br>   (1) Левое и правое поддеревья отличаются по глубине не более чем на 1.<br>   (2) Оба поддерева являются AVL-деревьями.<br>   Деревья, удовлетворяющие этому определению, могут быть слегка разбалансированными. Однако можно показать, что даже в худшем случае глубина AVL-дерева примерно пропорциональна log <i>n</i>, где <i>n</i> — число вершин дерева. Таким образом гарантируется логарифмический порядок производительности операций внутри, добавить и удалить.<br>   Операции над AVL-деревом работают по существу так же, как и над двоичным справочником. В них только сделаны добавления, связанные с поддержанием приближенной сбалансированности дерева. Если после вставления или удаления дерево перестает быть приближенно сбалансированным, то специальные механизмы возвращают ему требуемую степень сбалансированности. Для того, чтобы эффективно реализовать этот механизм, нам придется сохранять некоторую дополнительную информацию относительно степени сбалансированности дерева. На самом деле, нам нужно знать только разность между глубинами поддеревьев, которая может принимать значения -1, 0 или +1. Тем не менее для простоты мы предпочтем сохранять сами величины глубин поддеревьев, а не разности между ними.<br>   Мы определим отношение вставления элемента как<br>   доб_avl( Дер, X, НовДер)<br>   где оба дерева Дер и НовДер — это AVL-деревья, причем НовДер получено из Дер вставлением элемента X. AVL-деревья будем представлять как термы вида<br>   д( Лев, А, Прав)/Глуб<br>   где А — корень, Лев и Прав — поддеревья, а Глуб — глубина дерева. Пустое дерево изображается как nil/0. Теперь рассмотрим вставление элемента X в непустой AVL-справочник<br>   Дер = д( L, A, R)/H<br><div align="center"><img border="1" src="_70.png"></div>   <b>Рис. 10.8.</b> Задача вставления элемента в AVL-справочник (a) AVL-дерево перед вставлением X, X &gt; А; (b) AVL-дерево после вставления X в R; (с) составные части, из которых следует построить новое дерево.<br>   Начнем со случая, когда X больше А. X необходимо вставить в R, поэтому имеем следующее отношение:<br>   доб_аv1( R, X, д( R1, В, R2)/Hb)<br>   На рис. 10.8 показаны составные части, из которых строится дерево НовДер:<br>   L, А, R1, В, R2<br>   Какова глубина деревьев L, R, R1 и R2?  L и R могут отличаться по глубине не более, чем на 1. На рис. 10.8 видно, какую глубину могут иметь R1 и R2. Поскольку в R был добавлен только один элемент X, только одно из поддеревьев R1, R2 может иметь глубину h+1.<br><div align="center"><img border="1" src="_71.png"></div>   <b>Рис. 10.9.</b> Три правила построения нового AVL-дepевa.<br>   В случае, когда X меньше, чем А, имеем аналогичную ситуацию, причем левое и правое поддеревья меняются местами. Таким образом, в любом случае мы должны построить дерево НовДер, используя три дерева (назовем их Дер1, Дер2 и Дер3) и два отдельных элемента А и В. Теперь рассмотрим вопрос: как соединить между собой эти пять составных частей, чтобы дерево НовДер было AVL-справочником? Ясно, что они должны располагаться внутри НовДер в следующем порядке (слева направо):<br>   Дер1, А, Дер2, В, Дер3<br>   Рассмотрим три случая:<br>   (1) Среднее дерево Дер2 глубже остальных двух деревьев.<br>   (2) Дер1 имеет глубину не меньше, чем Дер2 и Дер3.<br>   (3) Дер3 имеет глубину не меньше, чем Дер2 и Дер1.<br>   На рис. 10.9 видно, как можно построить дерево НовДер в каждом из этих трех случаев. Например, в случае 1 среднее дерево Дер2 следует разбить на два части, а затем включить их в состав НовДер. Три правила, показанные на pис.10.9, нетрудно запасать на Прологе в виде отношения<br>   соединить( Дер, А, Дер2, В, Дер3, НовДер)<br>   Последний аргумент НовДер — это AVL-дерево, построенное из пяти составных частей, пяти первых аргументов. Правило 1, например, принимает вид:<br>   соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,<br>     % Пять частей<br>    д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, Д3/Н3)/Нс)/Нb) :-<br>     % Результат<br>    H2 &gt; H1, H2 &gt; Н3, % Среднее дерево глубже остальных<br>    На is Н1 + 1,     % Глубина левого поддерева<br>    Нс is Н3 + 1,     % Глубина правого поддерева<br>    Hb is На + 1,     % Глубина всего дерева<br>   Программа доб_аvl, вычисляющая также глубину дерева и его поддеревьев, показана полностью на рис. 10.10.<br><h5>Упражнение</h5>   <b>10.3.</b> Определите отношение<br>   avl( Дер)<br>   для проверки того, является ли Дер AVL-деревом, т.е. верно ли, что любые два его поддерева, подсоединенные к одной и той же вершине, отличаются по глубине не более чем на 1. Двоичные деревья представляйте в виде термов д( Лев, Кор, Прав) или nil<b>.</b><br>
		 <br>   % Вставление элемента в AVL-справочник<br>   доб_аvl( nil/0, X, д( nil/0, X, nil/0)/1).<br>     % Добавить X к пустому дереву<br>   доб_аvl( д( L, Y, R)/Ну, X, НовДер) :-<br>     % Добавить X к непустому дереву<br>    больше( Y, X),<br>    доб_аvl( L, X, д( L1, Z, L2)/ _ ),<br>     % Добавить к левому поддереву<br>    соединить( L1, Z, L2, Y, R, НовДер).<br>     % Сформировать новое дерево<br>   доб_avl( д( L, Y, R)/Ну, X, НовДер) :-<br>    больше( X, Y),<br>    доб_avl( R, X, д( R1, Z, R2)/ _ ),<br>     % Добавить к правому поддереву<br>    соединить( L1, Y, Rl, Z, R2, НовДер).<br>
		 <br>   соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,<br>    д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, L3/Н3)/Нс)/Нb) :-<br>    Н2 &gt; H1, H2 &gt; Н3,     % Среднее дерево глубже остальных<br>    На is H1 + 1,<br>    Hс is Н3 + 1,<br>    Нb is На + 1.<br>   соединить( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3,<br>    д( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3)/Нс)/На) :-<br>    H1 &gt;= H2, H1 &gt;= Н3,   % "Глубокое" левое дерево<br>    max1( H2, Н3, Нс),<br>    max1( H1, Нс, На).<br>   соединить( Д1/Н1, А, Д2/Н2, С, Д3/Н3,<br>    д( д( Д1/Н1, А, Д2/Н2)/На, С, Д3/Н3)/Нс) :-<br>    Н3 &gt;= H2, Н3 &gt;= H1,   % "Глубокое" правое дерево<br>    max1( H1, H2, На),<br>    max1( На, Н3, Нс).<br>
		 <br>   max1( U, V, М) :-<br>    U &gt; V, !, М is U + 1; % М равно 1 плюс max( U, V)<br>    М is V + 1.<br>   <b>Рис. 10.10.</b> Вставление элемента в AVL-справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу. По поводу процедуры соединить см. рис. 10.9.<br></div>
<h3 align="center">
<a name="TOC_id3598804"></a>Резюме<br></h3>
<div>   • 2-3 деревья и AVL-деревья, представленные в настоящей главе, — это примеры <i>сбалансированных</i> деревьев.<br>   • Сбалансированные или приближенно сбалансированные деревья гарантируют эффективное выполнение трех основных операций над деревьями: поиск, добавление и удаление элемента. Время выполнения этих операций пропорционально log <i>n</i>, где <i>n</i> — число вершин дерева.<br><h5>Литература</h5>   2-3 деревья детально описаны, например, в Aho, Hopcroft and Ullman (1974, 1983). В книге этих авторов, вышедшей в 1983 г., дается также реализация соответствующих алгоритмов на языке Паскаль. H.Вирт (см. Wirth (1976)) приводит программу на Паскале для работы с AVL-деревьями. 2-3 деревья являются частным случаем более общего понятия В-деревьев. В-деревья, а также несколько других вариантов структур данных, имеющих отношение к 2-3 деревьям в AVL-деревьям, рассматриваются в книге Gonnet (1984). В этой книге, кроме того, даны результаты анализа поведения этих структур.<br>   Программа вставления элемента в AVL-дерево, использующая только величину "перекоса" дерева (т.е. значение разности глубин поддеревьев, равной -1, 0 или 1, вместо самой глубины) опубликована ван Эмденом (1981).<br>
		 <br>   Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). <i>The Design and Analysis of Computer Algorithms.</i> Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]<br>   Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). <i>Data Structures and Algorithms.</i> Addison-Wesley.<br>   Gonnet G. H. (1984). <i>Handbook of Algorithms + Data Structures.</i> Addison-Wesley.<br>   van Emden M. (1981). <i>Logic Programming Newsletter 2.</i><br>   Wirth N. (1976). <i>Algorithms + Data Structures = Programs.</i> Prentice-Hall. [Имеется перевод: Вирт H. Алгоритмы + структуры данных = программы. — M.: Мир, 1985.] <br></div>
</div>
<h2 align="center">
<a name="TOC_id3598888"></a>Глава 11.<br>Основные стратегии решения задач<br></h2>
<div>
<div>   В данной главе мы сосредоточим свое внимание на одной общей схеме для представления задач, называемой <i>пространством состояний</i>. Пространство состояний — это граф, вершины которого соответствуют ситуациям, встречающимся в задаче ("проблемные ситуации"), а решение задачи сводится к поиску пути в этом графе. Мы изучим на примерах, как формулируются задачи в терминах пространства состояний, а также обсудим общие методы решения задач, представленных в рамках этого формализма. Процесс решения задачи включает в себя поиск в графе, при этом, как правило, возникает проблема, как обрабатывать альтернативные пути поиска. В этой главе будут представлены две основные стратегии перебора альтернатив, а именно поиск в глубину и поиск в ширину.<br></div>
<h3 align="center">
<a name="TOC_id3598916"></a>11.1. Предварительные понятия и примеры<br></h3>
<div>   Рассмотрим пример, представленный на рис. 11.1. Задача состоит в выработке плана переупорядочивания кубиков, поставленных друг на друга, как показано на рисунке. На каждом шагу разрешается переставлять только один кубик. Кубик можно взять только тогда, когда его верхняя поверхность свободна. Кубик можно поставить либо на стол, либо на другой кубик. Для того, чтобы построить требуемый план, мы должны отыскать последовательность ходов, реализующую заданную трансформацию.<br>   Эту задачу можно представлять себе как задачу выбора среди множества возможных альтернатив. В исходной ситуации альтернатива всего одна: поставить кубик С на стол. После того как кубик С поставлен на стол, мы имеем три альтернативы:<br>   • поставить А на стол или<br>   • поставить А на С, или<br>   • поставить С на А.<br><div align="center"><img border="1" src="_72.png"></div>   <b>Рис. 11.1.</b> Задача перестановки кубиков.<br>   Ясно, что альтернативу "поставить С на стол" не имело смысла рассматривать всерьез, так как этот ход никак не влияет на ситуацию.<br>   Как показывает рассмотренный пример, с задачами такого рода связано два типа понятий:<br>   (1) Проблемные ситуации.<br>   (2) Разрешенные ходы или действия, преобразующие одни проблемные ситуации в другие.<br>   Проблемные ситуации вместе с возможными ходами образуют направленный граф, называемый <i>пространством состояний</i>. Пространство состояний для только что рассмотренного примера дано на рис. 11.2. Вершины графа соответствуют проблемным ситуациям, дуги — разрешенным переходам из одних состояний в другие. Задача отыскания плана решения задачи эквивалентна задаче построения пути между заданной начальной ситуацией ("стартовой" вершиной) и некоторой указанной заранее конечной ситуацией, называемой также <i>целевой вершиной</i>.<br>   На рис. 11.3 показан еще один пример задачи: головоломка "игра в восемь" в ее представление в виде задачи поиска пути. В головоломке используется восемь перемещаемых фишек, пронумерованных цифрами от 1 до 8. Фишки располагаются в девяти ячейках, образующих матрицу 3 на 3. Одна из ячеек всегда пуста, и любая смежная с ней фишка может быть передвинута в эту пустую ячейку. Можно сказать и по-другому, что пустой ячейке разрешается перемещаться, меняясь местами с любой из смежных с ней фишек. Конечная ситуация — это некоторая заранее заданная конфигурация фишек, как показано на рис. 11.3.<br><div align="center"><img border="1" src="_73.png"></div>   <b>Рис. 11.2.</b> Графическое представление задачи манипулирования кубиками. Выделенный путь является решением задачи рис. 11.1.<br>   Нетрудно построить аналогичное представление в виде графа и для других популярных головоломок. Наиболее очевидные примеры — это задача о "ханойской башне" и задача о перевозке через реку волка, козы и капусты. Во второй из этих задач предполагается, что вместе с человекам в лодке помещается только один объект и что человеку приходится охранять козу от волка и капусту от козы. С описанной парадигмой согласуются также многие задачи, имеющие практическое значение. Среди них — задача о коммивояжере, которая может служить моделью для многих практических оптимизационных задач. В задаче дается карта с <i>n</i> городами в указываются расстояния, которые надо преодолеть по дорогам при переезде из города в город. Необходимо найти маршрут, начинающийся в некотором городе, проходящий через все города и заканчивающиеся в том же городе. Ни один город, за исключением начального, не разрешается посещать дважды.<br><div align="center"><img border="1" src="_74.png"></div>   <b>Рис. 11.3.</b> "Игра в восемь" и ее представление в форме графа.<br>   Давайте подытожим те понятия, которые мы ввели, рассматривая примеры. Пространство состояний некоторой задачи определяет "правила игры": вершины пространства состояния соответствуют ситуациям, а дуги — разрешенным ходам или действиям, или шагам решения задачи. Конкретная задача определяется<br>   • пространством состояний<br>   • стартовой вершиной<br>   • целевым условием (т.е. условием, к достижению которого следует стремиться); "целевые вершины" — это вершины, удовлетворяющие этим условиям.<br>   Каждому разрешенному ходу или действию можно приписать его стоимость. Например, в задаче манипуляции кубиками стоимости, приписанные тем или иным перемещениям кубиков, будут указывать нам на то, что некоторые кубики перемещать труднее, чем другие. В задаче о коммивояжере ходы соответствуют переездам из города в город. Ясно, что в данном случае стоимость хода — это расстояние между соответствующими городами.<br>   В тех случаях, когда каждый ход имеет стоимость, мы заинтересованы в отыскании решения минимальной стоимости. Стоимость решения — это сумма стоимостей дуг, из которых состоит "решающий путь" — путь из стартовой вершины в целевую. Даже если стоимости не заданы, все равно может возникнуть оптимизационная задача: нас может интересовать кратчайшее решение.<br>   Прежде тем будут рассмотрены некоторые программы, реализующие классический алгоритм поиска в пространстве состоянии, давайте сначала обсудим. как пространство состояний может быть представлено в прологовской программе.<br>   Мы будем представлять пространство состояний при помощи отношения<br>   после( X, Y)<br>   которое истинно тогда, когда в пространстве состояний существует разрешенный ход из вершины X в вершину Y. Будем говорить, что Y — это <i>преемник</i> вершины X. Если с ходами связаны их стоимости, мы добавим третий аргумент, стоимость хода:<br>   после( X, Y, Ст)<br>   Эти отношения можно задавать в программе явным образом при помощи набора соответствующих фактов. Однако такой принцип оказывается непрактичным и нереальным для тех типичных случаев, когда пространство состояний устроено достаточно сложно. Поэтому отношение следования после обычно определяется неявно, при помощи правил вычисления вершин-преемников некоторой заданной вершины. Другим вопросом, представляющим интерес с самой общей точки зрения, является вопрос о способе представления состояний, т.е. самих вершин. Это представление должно быть компактным, но в то же время оно должно обеспечивать эффективное выполнение необходимых операций, в частности операции вычисления вершин-преемников, а возможно и стоимостей соответствующих ходов.<br>   Рассмотрим в качестве примера задачу манипулирования кубиками, проиллюстрированную на рис. 11.1. Мы будем рассматривать более общий случай, когда имеется произвольное число кубиков, из которых составлены столбики, — один или несколько. Число столбиков мы ограничим некоторым максимальным числом, чтобы задача была интереснее. Такое ограничение, кроме того, является вполне реальным, поскольку рабочее пространство, которым располагает робот, манипулирующий кубиками, ограничено.<br>   Проблемную ситуацию можно представить как список столбиков. Каждый столбик в свою очередь представляется списком кубиков, из которых он составлен. Кубики упорядочены в списке таким образом, что самый верхний кубик находится в голове списка. "Пустые" столбики изображаются как пустые списки. Таким образом, исходную ситуацию рис. 11.1 можно записать как терм<br>   [ [с, а, b], [], [] ]<br>   Целевая ситуация — это любая конфигурация кубиков, содержащая, столбик, составленный из всех имеющихся кубиков в указанном порядке. Таких ситуаций три:<br>   [ [a, b, c], [], [] ]<br>   [ [], [а, b, с], [] ]<br>   [ [], [], [a, b, c] ]<br>   Отношение следования можно запрограммировать, исходя из следующего правила: ситуация Сит2 есть преемник ситуации Сит1, если в Сит1 имеется два столбика Столб1 и Столб2, такие, что верхний кубик из Столб1 можно поставить сверху на Столб2 и получить тем самым Сит2. Поскольку все ситуации - это списки столбиков, правило транслируется на Пролог так:<br>   после( Столбы, [Столб1, [Верх1 | Столб2], Остальные]) :-<br>     % Переставить Верх1 на Столб2<br>    удалить( [Верх1 | Столб1], Столб1, Столб1),<br>     % Найти первый столбик<br>    удалить( Столб2, Столбы1, Остальные).<br>     % Найти второй столбик<br>
		 <br>   удалить( X, [X | L], L).<br>   удалить( X, [Y | L], [Y | L1] ) :-<br>    удалить( L, X, L1).<br>   В нашем примере целевое условие имеет вид:<br>   цель( Ситуация) :-<br>    принадлежит [а,b,с], Ситуация)<br>   Алгоритм поиска мы запрограммируем как отношение<br>   решить( Старт, Решение)<br>   где Старт — стартовая вершина пространства состояний, а Решение — путь, ведущий из вершины Старт в любую целевую вершину. Для нашего конкретного примера обращение к пролог-системе имеет вид:<br>   ?- решить( [ [с, а, b], [], [] ], Решение).<br>   В результате успешного поиска переменная Решение конкретизируется и превращается в список конфигураций кубиков. Этот список представляет собой план преобразования исходного состояния в состояние, в котором все три кубика поставлены друг на друга в указанном порядке [а, b, с].<br></div>
<h3 align="center">
<a name="TOC_id3599292"></a>11.2. Стратегия поиска в глубину<br></h3>
<div>   Существует много различных подходов к проблеме поиска решающего пути для задач, сформулированных в терминах пространства состояний. Основные две стратегии поиска — это поиск <i>в глубину</i> и <i>поиск в ширину</i>. В настоящем разделе мы реализуем первую из них.<br>   Мы начнем разработку алгоритма и его вариантов со следующей простой идеи:<br><blockquote>   Для того, чтобы найти решающий путь Реш из заданной вершины В в некоторую целевую вершину, необходимо:<br>   • если В — это целевая вершина, то положить Реш = [В], или<br>   • если для исходной вершины В существует вершина-преемник В1, такая, что можно провести путь Реш1 из В1 в целевую вершину, то положить Реш = [В | Peш1].<br></blockquote>
<div align="center"><img border="1" src="_75.png"></div>   <b>Рис. 11.4.</b> Пример простого пространства состояний: <i>а</i> — стартовая вершина,<i> f</i> и<i> j</i> — целевые вершины. Порядок, в которой происходит проход по вершинам пространства состояний при поиске в глубину: <i>а</i>, <i>b</i>, <i>d</i>, <i>h</i>, <i>e</i>,<i> i</i>, <i>j</i>. Найдено решение [a, b, e, j]. После возврата обнаружено другое решение: [а, с, f].<br>   На Пролог это правило транслируется так:<br>   решить( В, [В] ) :-<br>    цель( В).<br>   решить( В, [В | Реш1] ) :-<br>    после( В, В1 ),<br>    решить( В1, Реш1).<br>   Эта программа и есть реализация поиска в глубину. Мы говорим "в глубину", имея в виду тот порядок, в котором рассматриваются альтернативы в пространстве состояний. Всегда, когда алгоритму поиска в глубину надлежит выбрать из нескольких вершин ту, в которую следует перейти для продолжения поиска, он предпочитает самую "глубокую" из них. Самая глубокая вершина — это вершина, расположенная дальше других от стартовой вершины. На рис. 11.4 мы видим на примере, в каком порядке алгоритм проходит по вершинам. Этот порядок в точности соответствует результату трассировки процесса вычислений в пролог-системе при ответе на вопрос<br>   ?- решить( а, Реш).<br>   Поиск в глубину наиболее адекватен рекурсивному стилю программирования, принятому в Прологе. Причина этого состоит в том, что, обрабатывая цели, пролог-система сама просматривает альтернативы именно в глубину.<br>   Поиск в глубину прост, его легко программировать и он в некоторых случаях хорошо работает. Программа для решения задачи о восьми ферзях (см. гл. 4) фактически была примером поиска в глубину. Для того, чтобы можно было применить к этой задаче описанную выше процедуру решить, необходимо сформулировать задачу в терминах пространства состояний. Это можно сделать так:<br>   • вершины пространства состояний — позиции, в которых поставлено 0 или более ферзей на нескольких последовательно расположенных горизонтальных линиях доски;<br>   • вершина-преемник данной вершины может быть получена из нее после того, как в соответствующей позиции на следующую горизонтальную линию доски будет поставлен еще один ферзь, причем таким образом, чтобы ни один из уже поставленных ферзей не оказался под боем;<br>   • стартовая вершина — пустая доска (представляется пустым списком);<br>   • целевая вершина — любая позиция с восемью ферзями (правило получения вершины-преемника гарантирует, что ферзи не бьют друг друга).<br>   Позицию на доске будем представлять как список Y-координат поставленных ферзей. Получаем программу:<br>   после( Ферзи, [Ферзь | Ферзи] ) :-<br>    принадлежит( Ферзь, [1, 2, 3, 4, 5, 6, 7, 8] ),<br>     % Поместить ферзя на любую вертикальную линию<br>    небьет( Ферзь, Ферзи).<br>
		 <br>   цель( [ _, _, _, _, _, _, _, _ ] )<br>    % Позиция с восемью ферзями<br>   Отношение небьет означает, что Ферзь не может поразить ни одного ферзя из списка Ферзи. Эту процедуру можно легко запрограммировать так же, как это сделано в гл. 4. Ответ на вопрос<br>   ?- решить( [], Решение)<br>   будет выглядеть как список позиций с постепенно увеличивающимся количеством поставленных ферзей. Список завершается "безопасной" конфигурацией из восьми ферзей. Механизм возвратов позволит получить и другие решения задачи.<br>   Поиск в глубину часто работает хорошо, как в рассмотренном примере, однако наша простая процедура решить может попасть в затруднительное положение, причем многими способами. Случится ли это или нет — зависит от структуры пространства состояний. Для того, чтобы затруднить работу процедуры решить в примере рис. 11.4, достаточно внести в задачу совсем небольшое изменение: добавить дугу, ведущую из <i>h </i>в <i>d</i>, чтобы получился цикл (рис. 11.5). В этом случае поиск будет выглядеть так: начиная с вершины <i>а</i>, спускаемся вплоть до <i>h</i>, придерживаясь самой левой ветви графа. На этот раз, в отличие от рис. 11.4, у вершины <i>h </i>будет преемник <i>d</i>. Поэтому произойдет <i>не возврат</i> из <i>h</i>, а <i>переход</i> к <i>d</i>. Затем мы найдем преемника вершины <i>d</i>, т.е. вершину <i>h</i>, и т.д., в результате программа зациклится между <i>h</i> и <i>d</i>.<br><div align="center"><img border="1" src="_76.png"></div>   <b>Рис. 11.5.</b> Начинаясь в <i>а</i>, поиск в глубину заканчивается бесконечным циклом между <i>d</i> и <i>h</i>: <i>a</i>, <i>b</i>, <i>d</i>, <i>h</i>, <i>d</i>, <i>h</i>, <i>d</i> ….<br>   Очевидное усовершенствование нашей программы поиска в глубину — добавление к ней механизма обнаружения циклов. Ни одну из вершин, уже содержащихся в пути, построенном из стартовой вершины в текущую вершину, не следует вторично рассматривать в качестве возможной альтернативы продолжения поиска. Это правило можно сформулировать в виде отношения<br>   вглубину( Путь, Верш, Решение)<br>   Как видно из рис. 11.6, Верш — это состояние, из которого необходимо найти путь до цели; Путь — путь (список вершин) между стартовой вершиной и Верш; Решение — Путь, продолженный до целевой вершины.<br><div align="center"><img border="1" src="_77.png"></div>   <b>Рис. 11.6.</b> Отношение вглубину( Путь, В, Решение).<br>   Для облегчения программирования вершины в списках, представляющих пути, будут расставляться в обратном порядке. Аргумент Путь нужен для того,<br>   (1) чтобы не рассматривать тех преемников вершины Верш, которые уже встречались раньше (обнаружение циклов);<br>   (2) чтобы облегчить построение решающего пути Решение. Соответствующая программа поиска в глубину показана на рис. 11.7.<br>
		 <br>   решить( Верш, Решение) :-<br>    вглубину( [], Верш, Решение).<br>
		 <br>   вглубину( Путь, Верш, [Верш | Путь] ) :-<br>    цель( Верш).<br>   вглубину( Путь, Верш, Реш) :-<br>    после( Верш, Верш1),<br>    not принадлежит( Верш1, Путь), % Цикл?<br>    вглубину( [Верш | Путь], Верш1, Реш).<br>   <b>Рис. 11.7.</b> Программа поиска в глубину без зацикливания.<br>
		 <br>   Теперь наметим один вариант этой программы. Аргументы Путь и Верш процедуры вглубину можно объединить в один список [Верш | Путь]. Тогда, вместо вершины-кандидата Верш, претендующей на то, что она находится на пути, ведущем к цели, мы будем иметь <i>путь</i>-кандидат П = [Верш | Путь], который претендует на то, что его можно продолжить вплоть до целевой вершины. Программирование соответствующего предиката<br>   вглубину( П, Решение)<br>   оставим читателю в качестве упражнения.<br>   Наша процедура поиска в глубину, снабженная механизмом обнаружения циклов, будет успешно находить решающие пути в пространствах состояний, подобных показанному на рис. 11.5. Существуют, однако, такие пространства состоянии, в которых наша процедура не дойдет до цели. Дело в том, что многие пространства состояний бесконечны. В таком пространстве алгоритм поиска в глубину может "потерять" цель, двигаясь вдоль бесконечной ветви графа. Программа будет бесконечно долго обследовать эту бесконечную область пространства, так и не приблизившись к цели. Пространство состояний задачи о восьми ферзях, определенное так, как это сделано в настоящем разделе, на первый взгляд содержит ловушку именно такого рода. Но оказывается, что оно все-таки конечно, поскольку Y-координаты выбираются из ограниченного множества, и поэтому на доску можно поставить "безопасным образом" не более восьми ферзей.<br>
		 <br>   вглубину2( Верш, [Верш], _ ) :-<br>    цель( Верш).<br>   вглубину2( Верш, [Верш | Реш], МаксГлуб) :-<br>    МаксГлуб &gt; 0,<br>    после( Верш, Верш1),<br>    Maкс1 is МаксГлуб - 1,<br>    вглубину2( Верш1, Реш, Maкс1).<br>   <b>Рис. 11.8.</b> Программа поиска в глубину с ограничением по глубине.<br>
		 <br>   Для того, чтобы предотвратить бесцельное блуждание по бесконечным ветвям, мы можем добавить в базовую процедуру поиска в глубину еще одно усовершенствование, а именно, ввести ограничение на глубину поиска. Процедура поиска в глубину будет тогда иметь следующие аргументы:<br>   вглубину2( Верш, Решение, МаксГлуб)<br>   Не разрешается вести поиск на глубине большей, чем МаксГлуб. Программная реализация этого ограничения сводится к уменьшению на единицу величины предела глубины при каждом рекурсивном обращений к вглубину2 и к проверке, что этот предел не стал отрицательным. В результате получаем программу, показанную на рис. 11.8.<br><h5>Упражнения</h5>   <b>11.1.</b> Напишите процедуру поиска в глубину (с обнаружением циклов)<br>   вглубину1( ПутьКандидат, Решение)<br>   отыскивающую решающий путь Решение как продолжение пути ПутьКандидат. Оба пути представляйте списками вершин, расположенных в обратном порядке так, что целевая вершина окажется в голове списка Решение.<br>   <b>11.2.</b> Напишите процедуру поиска в глубину, сочетающую в себе обнаружение циклов с ограничением глубины, используя рис. 11.7 и 11.8.<br>   <b>11.3.</b> Проведите эксперимент по применению программы поиска в глубину к задаче планирования в "мире кубиков" (рис. 11.1).<br>   <b>11.4.</b> Напишите процедуру<br>   отобр( Ситуация)<br>   для отображения состояния задачи "перестановки кубиков". Пусть Ситуация — это список столбиков, а столбик, в свою очередь, — список кубиков. Цель<br>   отобр( [ [a], [e, d], [с, b] ] )<br>   должна отпечатать соответствующую ситуацию, например так:<br>         e      с<br>   a     d      b<br>   ==============<br></div>
<h3 align="center">
<a name="TOC_id3600005"></a>11.3. Поиск в ширину<br></h3>
<div>
<div>   В противоположность поиску в глубину стратегия поиска в ширину предусматривает переход в первую очередь к вершинам, ближайший к стартовой вершине. В результате процесс поиска имеет тенденцию развиваться более в ширину, чем в глубину, что иллюстрирует рис. 11.9.<br><div align="center"><img border="1" src="_78.png"></div>   <b>Рис. 11.9.</b> Простое пространство состояний: а — стартовая вершина, f и j — целевые вершины. Применение стратегии поиска в ширину дает следующий порядок прохода по вершинам: а, b, c, d, e, f. Более короткое решение [a, c, f] найдено раньше, чем более длинное [а, b, e, j]<br>   Поиск в ширину программируется не так легко, как поиск в глубину. Причина состоят в том, что нам приходится сохранять все множество альтернативных вершин-кандидатов, а не только одну вершину, как при поиске в глубину. Более того, если мы желаем получить при помощи процесса поиска решающий путь, то одного множества вершин недостаточно. Поэтому мы будем хранить не множество вершин-кандидатов, а множество <i>путей</i>-кандидатов. Таким образом, цель<br>   вширину( Пути, Решения)<br>   истинна только тогда, когда существует путь из множества кандидатов Пути, который может быть продолжен вплоть до целевой вершины. Этот продолженный путь и есть Решение.<br></div>
<h4 align="center">
<a name="TOC_id3600068"></a>11.3.1. Списковое представление множества кандидатов<br></h4>
<div>   В нашей первой реализации этой идеи мы будем использовать следующее представление для множества путей-кандидатов. Само множество будет списком путей, а каждый путь - списком вершин, перечисленных в обратном порядке, т.е. головой списка будет самая последняя из порожденных вершин, а последним элементом списка будет стартовая вершина. Поиск начинается с одноэлементного множества кандидатов<br>   [ [СтартВерш] ]<br>
		 <br>   решить( Старт, Решение) :-<br>    вширину( [ [Старт] ], Решение).<br>
		 <br>   вширину( [ [Верш | Путь] | _ ], [Верш | Путь] ) :-<br>    цель( Верш).<br>   вширину( [ [В | Путь] | Пути], Решение ) :-<br>    bagof( [B1, В | Путь ],<br>    ( после( В, В1), not принадлежит( В1, [В | Путь])),<br>      НовПути),<br>       % НовПути - ациклические продолжения пути [В | Путь]<br>    конк( Пути, НовПути, Пути1), !,<br>    вширину( Путь1, Решение);<br>    вширину( Пути, Решение).<br>     % Случай, когда у В нет преемника<br>   <b>Рис. 11.10.</b> Реализации поиска в ширину.<br>   Общие принципы поиска в ширину таковы:<br>   Для того, чтобы выполнить поиск в ширину при заданном множестве путей-кандидатов, нужно:<br>   • если голова первого пути — это целевая вершина, то взять этот путь в качестве решения, иначе<br>   • удалить первый путь из множества кандидатов и породить множество всех возможных продолжений этого пути на один шаг; множество продолжений добавить в конец множества кандидатов, а затем выполнить поиск в ширину с полученным новым множеством.<br>
		 <br>   решить( Старт, Решение) :-<br>    вширь( [ [Старт] | Z ]-Z, Решение).<br>
		 <br>   вширь( [ [Верш | Путь] | _ ]-_, [Верш | Путь] ) :-<br>    цель( Верш).<br>   вширь( [ [В | Путь] | Пути]-Z, Решение ) :-<br>    bagof( [B1, В | Путь ],<br>    ( после( В, В1),<br>      not принадлежит( В1, [В | Путь]) ),<br>      Нов ),<br>    конк( Нов, ZZ, Z), !,<br>    вширь( Пути-ZZ, Решение);<br>    Пути \== Z, % Множество кандидатов не пусто<br>    вширь( Пути-Z, Решение).<br>   <b>Рис. 11.11.</b> Программа поиска в ширину более эффективная, чем программа рис. 11.10. Усовершенствование основано на разностном представлении списка путей-кандидатов.<br>
		 <br>   В случае примера рис.11.9 этот процесс будет развиваться следующим образом:<br>   (1) Начинаем с начального множества кандидатов:<br>   [ [а] ]<br>   (2) Порождаем продолжения пути [а]:<br>   [ [b, а], [с, а] ]<br>   (Обратите внимание, что пути записаны в обратном порядке.)<br>   (3) Удаляем первый путь из множества кандидатов и порождаем его продолжения:<br>   [ [d, b, a], [e, b, а] ]<br>   Добавляем список продолжений в конец списка кандидатов:<br>   [ [с, а], [d, b, a], [e, b, а] ]<br>   (4) Удаляем [с, а], а затем добавляем все его продолжения в конец множества кандидатов. Получаем:<br>   [ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]<br>   Далее, после того, как пути [d, b, a] и [e, b, а] будут продолжены, измененный список кандидатов примет вид<br>   [[f, c, a], [g, c, a], [h, d, b, a], [i, e, b, a], [j, e, b, a]]<br>   В этот момент обнаруживается путь [f, c, a], содержащий целевую вершину f. Этот путь выдается в качестве решения.<br>   Программа, порождающая этот процесс, показана на рис. 11.10. В этой программе все продолжения пути на один шаг генерируются встроенной процедурой bagof. Кроме того, делается проверка, предотвращающая порождение циклических путей. Обратите внимание на то, что в случае, когда путь продолжить невозможно, и цель bagof терпит неудачу, обеспечивается альтернативный запуск процедуры вширину. Процедуры принадлежит и конк реализуют отношения принадлежности списку и конкатенации списков соответственно.<br>   Недостатком этой программы является неэффективность операции конк. Положение можно исправить, применив разностное представление списков (см. гл. 8). Тогда множество путей-кандидатов будет представлено парой списков Пути и Z, записанной в виде<br>   Пути-Z<br>   При введении этого представления в программу рис. 11.10 ее можно постепенно преобразовать в программу, показанную на рис. 11.11. Оставим это преобразование читателю в качестве упражнения.<br></div>
<h4 align="center">
<a name="TOC_id3600371"></a>11.3.2. Древовидное представление множества кандидатов<br></h4>
<div>   Рассмотрим теперь еще одно изменение нашей программы поиска в ширину. До сих пор мы представляли множества путей-кандидатов как списки путей. Это расточительный способ, поскольку начальные участки путей являются общими для нескольких из них. Таким образом, эти общие части путей приходится хранить во многих экземплярах. Избежать избыточности помогло бы более компактное представление множества кандидатов. Таким более компактным представлением является дерево, в котором общие участки путей хранятся в его верхней части без дублирования. Будем использовать в программе следующее представление дерева. Имеется два случая:<br>   <i>Случай 1:</i> Дерево состоит только из одной вершины В; В этом случае оно имеет вид терма л( В); Функтор л указывает на то, что В — это лист дерева.<br>   <i>Случай 2:</i> Дерево состоит из корневой вершины В и множества поддеревьев Д1, Д2, …. Такое дерево представляется термом<br>   д( В, Пд)<br>   где Пд — список поддеревьев:<br>   Пд = [ Д1, Д2, ...]<br>   В качестве примера рассмотрим ситуацию, которая возникает после того, как порождены три уровня дерева рис. 11.9. Множество путей-кандидатов в случае спискового представления имеет вид:<br>   [ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]<br>   В виде дерева это множество выглядит так:<br>   д( а, [д( b, [л( d), л( e)] ), д( с, [л( f), л( g)] )] )<br>   На первый взгляд древовидное представление кажется еще более расточительным, чем списковое, однако это всего лишь поверхностное впечатление, связанное с компактностью прологовской нотации для списков.<br>   В случае спискового представления множества кандидатов эффект распространения процесса в ширину достигался за счет перемещения продолженных путей в конец списка. В нашем случае мы уже не можем использовать этот прием, поэтому программа несколько усложняется. Ключевую роль в нашей программе будет играть отношение<br>   расширить( Путь, Дер, Дер1, ЕстьРеш, Решение)<br>   На рис. 11.12 показано, как связаны между собой аргументы отношения расширить. При каждом обращении к расширить переменные Путь и Дер будут уже конкретизированы. Дер — поддерево всего дерева поиска, одновременно оно служит для представления множества путей-кандидатов внутри этого поддерева. Путь — это путь, ведущий из стартовой вершины в корень поддерева Дер. Самая общая идея алгоритма — получить поддерево Дер1 как результат расширения Дер на один уровень. Но в случае, когда в процессе расширения поддерева Дер встретится целевая вершина, процедура расширить должна сформировать соответствующий решающий путь.<br><div align="center"><img border="1" src="_79.png"></div>   <b>Рис. 11.12.</b> Отношение paсширить( Путь, Дер, Дер1, ЕстьРеш, Решение):  s — стартовая вершина, g — целевая вершина. Решение — это Путь, продолженный вплоть до g. Дер1 — результат расширения дерева Дер на один уровень вниз.<br>   Итак, процедура расширить будет порождать два типа результатов. На конкретный вид результата будет указывать значение переменной ЕстьРеш:<br>   (1) ЕстьРеш = да<br>   Решение = решающий путь, т.е. Путь, продолженный до целевой вершины.<br>   Дер1 = неконкретизировано.<br>   Разумеется, такой тип результата получится только в том случае, когда Дер будет содержать целевую вершину. Добавим также, что эта целевая вершина обязана быть листом поддерева Дер.<br>   (2) ЕстьРеш = нет<br>   Дер1 = результат расширения поддерева Дер на один уровень вниз от своего "подножья". Дер1 не содержит ни одной "тупиковой" ветви из Дер, т.е. такой ветви, что она либо не может быть продолжена из-за отсутствия преемников, либо любое ее продолжение приводит к циклу.<br>   Решение = неконкретизировано.<br>   Если в дереве Дер нет ни одной целевой вершины и, кроме того, оно не может быть расширено, то процедура расширить терпит неудачу.<br>   Процедура верхнего уровня для поиска в ширину<br>   вширину( Дер, Решение)<br>   отыскивает Решение либо среди множества кандидатов Дер, либо в его расширении. На рис. 11.3 показано, как выглядит программа целиком. В этой программе имеется вспомогательная процедура расширитьвсе. Она расширяет все деревья из некоторого <i>списка</i>, и затем, выбросив все "тупиковые" деревья", собирает все полученные расширенные деревья в один новый список. Используя механизм возвратов, она также порождает все решения, обнаруженные в деревьях из списка. Имеется одна дополнительная деталь: по крайней мере одно из деревьев должно "вырасти". Если это не так, то процедуре расширитьвсе не удается получить ни одного расширенного дерева - все деревья из списка оказываются "тупиковыми".<br>
		 <br>   % ПОИСК В ШИРИНУ<br>   % Множество кандидатов представлено деревом<br>   решить( Старт, Решение) :-<br>    вширину( л( Старт), Решение).<br>
		 <br>   вширину( Дер, Решение) :-<br>    расширить( [], Дер, Дер1, ЕстьРеш, Решение),<br>    ( ЕстьРеш = да;<br>      ЕстьРеш = нет, вширину( Дер1, Решение) ).<br>
		 <br>   расширить( П, Л( В), _, да, [В | П] ) :-<br>    цель( В).<br>   расширить( П, Л( В), д( В, Пд), нет, _ ) :-<br>    bagof( л( B1),<br>    ( после( В, B1), not принадлежит( В1, П)), Пд).<br>   расширить( П, д( В, Пд), д( В, Пд1), ЕстьРеш, Реш) :-<br>    расширитьвсе( [В | П], Пд, [ ], Пд1, ЕстьРеш, Реш).<br>
		 <br>   расширитьвсе( _, [ ], [Д | ДД], [Д | ДД], нет, _ ).<br>     % По крайней мере одно дерево должно вырасти<br>   расширитьвсе( П, [Д | ДД], ДД1, Пд1, ЕстьРеш, Реш) :-<br>    расширить ( П, Д, Д1, ЕстьРеш1, Реш),<br>    ( ЕстьРеш 1= да, ЕстьРеш = да;<br>      ЕстьРеш1 = нет, !,<br>      расширитьвсе( П, ДД, [Д1 | ДД1], Пд1, ЕстьРеш, Реш));<br>    расширитьвсе( П, ДД, ДД1, Пд1, ЕстьРеш, Реш ).<br>   <b>Рис. 11.13.</b> Реализация поиска в ширину с использованием древовидного представления множества путей-кандидатов.<br>
		 <br>   Мы разработали эту более сложную реализацию поиска в ширину не только для того, чтобы получать программу более экономичную по сравнению с предыдущей версией, но также и потому, что такое решение задачи может послужить хорошим стартом для перехода к усложненным программам поиска, управляемым эвристиками, таким как программа поиска с предпочтением из гл. 12.<br><h5>Упражнения</h5>   <b>11.5.</b> Перепишите программу поиска в ширину рис. 11.10, используя разностное представление для списка путей-кандидатов и покажите, что в результате получится программа, приведенная на рис. 11.11. Зачем в программу рис. 11.11 включена цель<br>   Пути \== Z<br>   Проверьте, что случится при поиске в пространстве состояний рис. 11.9, если эту цель опустить. Различие в выполнении программы, возникнет только при попытке найти новые решения в ситуации, когда не осталось больше ни одного решения.<br>   <b>11.6.</b> Как программы настоящего раздела можно использовать для поиска, начинающегося от <i>стартового множества</i> вершин, вместо одной стартовой вершины?<br>   <b>11.7.</b> Как программы этой главы можно использовать для поиска в обратном направлении, т.е. от целевой вершины к стартовой вершине (или к одной из стартовых вершин, если их несколько). Указание: переопределите отношение после. В каких ситуациях обратный поиск будет иметь преимущества перед прямым поиском?<br>   <b>11.8.</b> Иногда выгодно сделать поиск <i>двунаправленным</i>, т.е. продвигаться одновременно с двух сторон от стартовой и целевой вершин. Поиск заканчивается, когда оба пути "встречаются". Определите пространство поиска (отношение после) и целевое отношение для заданного графа таким образом, чтобы наши процедуры поиска в действительности выполняли двунаправленный поиск.<br>   <b>11.9.</b> Проведите эксперименты с различными методами поиска применительно к задаче планирования в "мире кубиков".<br></div>
</div>
<h3 align="center">
<a name="TOC_id3444275"></a>11.4.  Замечания относительно поиска в графах, оптимальности к сложности<br></h3>
<div>   Сейчас уместно сделать ряд замечаний относительно программ поиска, разработанных к настоящему моменту: во-первых, о поиске в графах, во-вторых, об оптимальности полученных решений и, в-третьих, о сложности поиска.<br>   Приведенные примеры могли создать ложное впечатление, что наши программы поиска в ширину способны работать только в пространствах состояний, являющихся деревьями, а не графами общего вида. На самом деле, тот факт, что в одной из версий множество путей-кандидатов представлялось деревом, совсем не означает, что и само пространство состояний должно было быть деревом. Когда поиск проводится в графе, граф фактически разворачивается в дерево, причем некоторые пути, возможно, дублируются в разных частях этого дерева (см. рис. 11.14).<br>   Наши программы поиска в ширину порождают решающие пути один за другим в порядке увеличения их длин — самые короткие решения идут первыми. Это является важным обстоятельством, если нам необходима оптимальность (в отношении длины решения). Стратегия поиска в ширину гарантирует получение кратчайшего решения первым. Разумеется, это неверно для поиска в глубину.<br><div align="center"><img border="1" src="_80.png"></div>   <b>Рис. 11.14.</b> (а) Пространство состояний; а — стартовая вершина. (b) Дерево всех возможных ациклических путей, ведущих из а, порожденное программой поиска в ширину.<br>   Наши программы, однако, не учитывают стоимости, приписанные дугам в пространстве состояний. Если критерием оптимальности является минимум стоимости решающего пути (а не его длина), то в этом случае поиска в ширину недостаточно. Поиск с предпочтением из гл. 12 будет направлен на оптимизацию стоимости.<br>   Еще одна типичная проблема, связанная с задачей поиска, — это проблема <i>комбинаторной сложности</i>. Для нетривиальных предметных областей число альтернатив столь велико, что проблема сложности часто принимает критический характер. Легко понять, почему это происходит: если каждая вершина имеет b преемников, то число путей длины l, ведущих из стартовой вершины, равно b<sup>l</sup> (в предположении, что циклов нет). Таким образом, вместе с увеличением длин путей наблюдается <i>экспоненциальный</i> рост объема множества путей-кандидатов, что приводит к ситуации, называемой <i>комбинаторным взрывом</i>. Стратегии поиска в глубину и ширину недостаточно "умны" для борьбы с такой степенью комбинаторной сложности: отсутствие селективности приводит к тому, что все пути рассматриваются как одинаково перспективные.<br>   По-видимому, более изощренные процедуры поиска должны использовать какую-либо информацию, отражающую специфику данной задачи, с тем чтобы на каждой стадии поиска принимать решения о наиболее перспективных путях поиска. В результате процесс будет продвигаться к целевой вершине, обходя бесполезные пути. Информация, относящаяся к конкретной решаемой задаче и используемая для управления поиском, называется <i>эвристикой</i>. Про алгоритмы, использующие эвристики, говорят, что они <i>руководствуются эвристиками</i>: они выполняют <i>эвристический поиск</i>. Один из таких методов изложен в следующей главе.<br></div>
<h3 align="center">
<a name="TOC_id3444376"></a>Резюме<br></h3>
<div>   • <i>Пространство состояний</i> есть формализм для представления задач.<br>   • Пространство состояний — это направленный граф, вершины которого соответствуют проблемным ситуациям, а дуги — возможным ходам. Конкретная задача определяется <i>стартовой вершиной</i> и <i>целевым условием</i>. Решению задачи соответствует путь в графе. Таким образом, решение задачи сводится к поиску пути в графе.<br>   • Оптимизационные задачи моделируются приписыванием каждой дуге пространства состояний некоторой стоимости.<br>   • Имеются две основных стратегии поиска в пространстве состояний — <i>поиск в глубину</i> и <i>поиск в ширину</i>.<br>   • Поиск в глубину программируется наиболее легко, однако подвержен зацикливаниям. Существуют два простых метода предотвращения зацикливания: ограничить глубину поиска и не допускать дублирования вершин.<br>   • Реализация поиска в ширину более сложна, поскольку требуется сохранять множество кандидатов. Это множество может быть с легкостью представлено списком списков, но более экономное представление — в виде дерева.<br>   • Поиск в ширину всегда первым обнаруживает самое короткое решение, что не верно в отношении стратегии поиска в глубину.<br>   • В случае обширных пространств состояний существует опасность <i>комбинаторного взрыва</i>. Обе стратегии плохо приспособлены для борьбы с этой трудностью. В таких случаях необходимо руководствоваться эвристиками.<br>   • В этой главе были введены следующие понятия:<br>     пространство состояний<br>     стартовая вершина, целевое условие,<br>     решающий путь<br>     стратегия поиска<br>     поиск в глубину, поиск в ширину<br>     эвристический поиск.<br><h5>Литература</h5>   Поиск в глубину и поиск в ширину — базовые стратегии поиска, они описаны в любом учебнике по искусственному интеллекту, см., например, Nilsson (1971, 1980) или Winston (1984). P. Ковальский в своей книге Kowalski (1980) показывает, как можно использовать аппарат математической логики для реализации этих принципов.<br>
		 <br>   Kowalski R. (1980). <i>Logic for Problem Solving.</i> North-Holland.<br>   Nilsson N. J. (1971). <i>Problem Solving Methods in Artificial Intelligence.</i> McGraw-Hill.<br>   Nilsson N. J. (1980). <i>Principles of Artificial Intelligence.</i> Tioga; also Springer-Verlag, 1981.<br>   Winston P. H. (1984). <i>Artificial Intelligence (second edition).</i> Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]<br></div>
</div>
<h2 align="center">
<a name="TOC_id3444506"></a>Глава 12<br>Поиск с предпочтением: эвристический поиск<br></h2>
<div>
<div>   Поиск в графах при решении задач, как правило, невозможен без решения проблемы комбинаторной сложности, возникающей из-за быстрого роста числа альтернатив. Эффективным средством борьбы с этим служит эвристический поиск.<br>   Один из путей использования эвристической информации о задаче — это получение численных <i>эвристических оценок</i> для вершин пространства состояний. Оценка вершины указывает нам, насколько данная вершина перспективна с точки зрения достижения цели. Идея состоит в том, чтобы всегда продолжать поиск, начиная с наиболее перспективной вершины, выбранной из всего множества кандидатов. Именно на этом принципе основана программа поиска с предпочтением, описанная в данной главе. <br></div>
<h3 align="center">
<a name="TOC_id3444536"></a>12.1. Поиск с предпочтением<br></h3>
<div>   Программу поиска с предпочтением можно получить как результат усовершенствования программы поиска в ширину (рис. 11.13). Подобно поиску в ширину, поиск с предпочтением начинается со стартовой вершины и использует множество путей-кандидатов. В то время, как поиск в ширину всегда выбирает для продолжения самый короткий путь (т.е. переходит в вершины наименьшей глубины), поиск с предпочтением вносит в этот принцип следующее усовершенствование: для каждого кандидата вычисляется оценка и для продолжения выбирается кандидат с наилучшей оценкой.<br><div align="center"><img border="1" src="_81.png"></div>   <b>Рис. 12.1.</b> Построение эвристической оценки <i>f</i>(<i>n</i>) стоимости самого дешевого пути из <i>s</i> в <i>t</i>, проходящего через <i>n</i>: <i>f</i>(<i>n</i>) = <i>g</i>(<i>n</i>) <i>+ h</i>(<i>n</i>).<br>   Мы будем в дальнейшем предполагать, что для дуг пространства состояний определена функция стоимости <i>с</i>(<i>n</i>, <i>n'</i>) — стоимость перехода из вершины <i>n</i>  к вершине-преемнику <i>n'</i>.<br>   Пусть <i>f</i> — это эвристическая оценочная функция, при помощи которой мы получаем для каждой вершины <i>n</i> оценку <i>f</i>(<i>n</i>) трудности" этой вершины. Тогда наиболее перспективной вершиной-кандидатом следует считать вершину, для которой <i>f</i> принимает минимальное значение. Мы будем использовать здесь функцию <i>f</i> специального вида, приводящую к хорошо известному А*-алгоритму. Функция <i>f</i>(<i>n</i>) будет построена таким образом, чтобы давать оценку стоимости оптимального решающего пути из стартовой вершины <i>s</i> к одной из целевых вершин при условии, что этот путь проходит через вершину <i>n</i>. Давайте предположим, что такой путь существует и что <i>t</i> — это целевая вершина, для которой этот путь минимален. Тогда оценку <i>f</i>(<i>n</i>) можно представить в виде суммы из двух слагаемых (рис. 12.1):<br>   <i> f</i>(<i>n</i>) = <i>g</i>(<i>n</i>) + <i>h</i>(<i>n</i>)<br>   Здесь <i>g</i>(<i>n</i>) — оценка оптимального пути из <i>s</i> в <i>n</i>; <i>h</i>(<i>n</i>) — оценка оптимального пути из <i>n</i> в <i>t</i>.<br>   Когда в процессе поиска мы попадаем в вершину <i>n</i>, мы оказываемся в следующей ситуация: путь из <i>s</i> в <i>n</i> уже найден, и его стоимость может быть вычислена как сумма стоимостей составляющих его дуг. Этот путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из <i>s</i> в <i>n</i>), однако стоимость этого пути можно использовать в качестве оценки <i>g</i>(<i>n</i>) минимальной стоимости пути из <i>s</i> в <i>n</i>. Что же касается второго слагаемого <i>h</i>(<i>n</i>), то о нем трудно что-либо сказать, поскольку к этому моменту область пространства состояний, лежащая между <i>n</i> и <i>t</i>, еще не "изучена" программой поиска. Поэтому, как правило, о значении <i>h</i>(<i>n</i>) можно только строить догадки на основании эвристических соображений, т.е. на основании тех знаний о конкретной задаче, которыми обладает алгоритм. Поскольку значение <i>h</i> зависит от предметной области, универсального метода для его вычисления не существует. Конкретные примеры того, как строят эти "эвристические догадки", мы приведем позже. Сейчас же будем считать, что тем или иным способом функция <i>h</i> задана, и сосредоточим свое внимание на деталях нашей программы поиска с предпочтением.<br>   Можно представлять себе поиск с предпочтением следующим образом. Процесс поиска состоит из некоторого числа конкурирующих между собой подпроцессов, каждый из которых занимается своей альтернативой, т.е. просматривает свое поддерево. У поддеревьев есть свои поддеревья, их просматривают подпроцессы подпроцессов и т.д. В каждый данный момент среди всех конкурирующих процессов активен только один — тот, который занимается наиболее перспективной к настоящему моменту альтернативой, т.е. альтернативой с наименьшим значением <i>f</i>. Остальные процессы спокойно ждут того момента, когда <i>f</i>-оценки изменятся и в результате какая-нибудь другая альтернатива станет наиболее перспективной. Тогда производится переключение активности на эту альтернативу. Механизм активации-дезактивации процессов функционирует следующим образом: процесс, работающий над текущей альтернативой высшего приоритета, получает некоторый "бюджет" и остается активным до тех пор, пока его бюджет не исчерпается. Находясь в активном состоянии, процесс продолжает углублять свое поддерево. Встретив целевую вершину, он выдает соответствующее решение. Величина бюджета, предоставляемого процессу на данный конкретный запуск, определяется эвристической оценкой конкурирующей альтернативы, ближайшей к данной.<br><div align="center"><img border="1" src="_82.png"></div>   <b>Рис. 12.2.</b> Поиск кратчайшего маршрута из <i>s</i> в <i>t</i>. (а) Карта со связями между городами; связи помечены своими длинами; в квадратиках указаны расстояния по прямой до цели <i>t</i>. (b) Порядок, в котором при поиске с предпочтением происходит обход городов. Эвристические оценки основаны на расстояниях по прямой. Пунктирной линией показано переключение активности между альтернативными путями. Эта линия задает тот порядок, в котором вершины принимаются для <i>продолжения</i> пути, а не тот порядок, в котором они порождаются.<br>   На рис. 12.2 показан пример поведения конкурирующих процессов. Дана карта, задача состоит в том, чтобы найти кратчайший маршрут из стартового города <i>s</i> в целевой город <i>t</i>. В качестве оценки стоимости остатка маршрута из города <i>X</i> до цели мы будем использовать расстояние по прямой <i>расст( X, t)</i> от <i>X</i> до <i>t</i>. Таким образом,<br>   <i> f( X) = g( X) + h( X) = g( X) + расст( X, t)</i><br>   Мы можем считать, что в данном примере процесс поиска с предпочтением состоит из двух процессов. Каждый процесс прокладывает свой путь — один из двух альтернативных путей: Процесс 1 проходит через <i>а</i>. Процесс 2 — через <i>e</i>. Вначале Процесс 1 более активен, поскольку значения <i>f</i> вдоль выбранного им пути меньше, чем вдоль второго пути. Когда Процесс 1 достигает города <i>с</i>, а Процесс 2 все еще находится в <i>e</i>, ситуация меняется:<br>   <i> f( с) = g( c) + h( c) = 6 + 4 = 10</i><br>   <i> f( e) = g( e) + h( e) = 2 + 7 = 9</i><br>   Поскольку <i>f( e) &lt; f( c)</i>, Процесс 2 переходит к <i>f</i>, a Процесс 1 ждет. Однако<br>   <i> f( f) = 7 + 4 = 11</i><br>   <i> f( c) = 10</i><br>   <i> f( c) &lt; f( f)</i><br>   Поэтому Процесс 2 останавливается, а Процессу 1 дается разрешение продолжать движение, но только до <i>d</i>, так как <i>f( d) = 12 &gt; 11</i>. Происходит активация Процесса 2, после чего он, уже не прерываясь, доходит до цели <i>t</i>.<br>   Мы реализуем этот механизм программно при помощи усовершенствования программы поиска в ширину (рис. 11.13). Множество путей-кандидатов представим деревом. Дерево будет изображаться в программе в виде терма, имеющего одну из двух форм:<br>   (1) л( В, F/G) — дерево, состоящее из одной вершины (листа); В — вершина пространства состояний, G — <i><i>g</i>( B)</i> (стоимость уже найденного пути из стартовой вершины в В); F - <i>f</i>( В) = G + <i>h</i>( В).<br>   (2) д( В, F/G, Пд) — дерево с непустыми поддеревьями; В — корень дерева, Пд — список поддеревьев; G — <i><i>g</i>( B)</i>; F —  <i>уточненное</i> значение <i><i>f</i>( В)</i>, т.е. значение <i>f</i> для наиболее перспективного преемника вершины В; список Пд упорядочен в порядке возрастания <i>f</i>-оценок поддеревьев.<br>   Уточнение значения <i>f</i> необходимо для того, чтобы дать программе возможность распознавать наиболее перспективное поддерево (т.е. поддерево, содержащее наиболее перспективную концевую вершину) на любом уровне дерева поиска. Эта модификация <i>f</i>-оценок на самом деле приводит к обобщению, расширяющему область определения функции <i>f</i>. Теперь функция <i>f</i> определена не только на вершинах, но и на деревьях. Для одновершинных деревьев (листов) <i>n</i> остается первоначальное определение<br>   <i> f( n) = g( n) + h( n)</i><br>   Для дерева <i>T</i> с корнем <i>n</i>, имеющем преемников <i>m</i><sub>1</sub>, <i>m</i><sub>2</sub>, …, получаем<br>    <img border="0" src="img_0.png"><br>   Программа поиска с предпочтением, составленная в соответствии с приведенными выше общими соображениями, показана на рис 12.3. Ниже даются некоторые дополнительные пояснения.<br>   Так же, как и в случае поиска в ширину (рис. 11.13), ключевую роль играет процедура расширить, имеющая на этот раз шесть аргументов:<br>   расширить( Путь, Дер, Предел, Дер1, ЕстьРеш, Решение)<br>   Эта процедура расширяет текущее (под)дерево, пока  <i>f</i>-оценка остается равной либо меньшей, чем Предел.<br>
		 <br>   % Поиск с предпочтением<br>   эврпоиск( Старт, Решение) :-<br>    макс_f( Fмакс).         % Fмакс &gt; любой  f-оценки<br>
		 <br>   расширить( [], л( Старт, 0/0), Fмакс, _, да, Решение).<br>   расширить( П, л( В, _ ), _, _, да, [В | П] ) :-<br>    цель( В).<br>   расширить( П, л( В, F/G), Предел, Дер1, ЕстьРеш, Реш) :-<br>    F &lt;= Предел,<br>    ( bagof( B1/C, ( после( В, В1, С), not принадлежит( В1, П)),<br>      Преемники), !,<br>    преемспис( G, Преемники, ДД),<br>    опт_f( ДД, F1),<br>    расширить( П, д( В, F1/G, ДД), Предел, Дер1,<br>     ЕстьРеш, Реш);<br>    ЕстьРеш = никогда).     % Нет преемников - тупик<br>   расширить( П, д( В, F/G, [Д | ДД]), Предел, Дер1,<br>    ЕстьРеш, Реш) :-<br>    F &lt;= Предел,<br>    опт_f( ДД, OF), мин( Предел, OF, Предел1),<br>    расширить( [В | П], Д, Предел1, Д1, ЕстьРеш1, Реш),<br>    продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,<br>    ЕстьРеш1, ЕстьРеш, Реш).<br>   расширить( _, д( _, _, []), _, _, никогда, _ ) :- !.<br>     % Тупиковое дерево - нет решений<br>   расширить( _, Дер, Предел, Дер, нет, _ ) :-<br>    f( Дер, F), F &gt; Предел. % Рост остановлен<br>
		 <br>   продолжить( _, _, _, _, да, да, Реш).<br>   продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,<br>    ЕстьРеш1, ЕстьРеш, Реш) :-<br>    ( ЕстьРеш1 = нет, встав( Д1, ДД, НДД);<br>      ЕстьРеш1 = никогда, НДД = ДД),<br>    опт_f( НДД, F1),<br>    расширить( П, д( В, F1/G, НДД), Предел, Дер1,<br>     ЕстьРеш, Реш).<br>
		 <br>   преемспис( _, [], []).<br>   преемспис( G0, [В/С | ВВ], ДД) :-<br>    G is G0 + С,<br>    h( В, H),               % Эвристика h(B)<br>    F is G + H,<br>    преемспис( G0, ВВ, ДД1),<br>    встав( л( В, F/G), ДД1, ДД).<br>
		 <br>   % Вставление дерева Д в список деревьев ДД с сохранением<br>   % упорядоченности по f-оценкам<br>   встав( Д, ДД, [Д | ДД] ) :-<br>    f( Д, F), опт_f( ДД, F1),<br>    F =&lt; F1, !.<br>   встав( Д, [Д1 | ДД], [Д1 | ДД1] ) ) :-<br>    встав( Д, ДД, ДД1).<br>
		 <br>   % Получение f-оценки<br>   f( л( _, F/_ ), F).      % f-оценка листа<br>   f( д( _, F/_, _ ) F).    % f-оценка дерева<br>
		 <br>   опт_f( [Д | _ ], F) :-   % Наилучшая f-оценка для<br>    f( Д, F).               % списка деревьев<br>   опт_f( [], Fмакс) :-     % Нет деревьев:<br>    мaкс_f( Fмакс).         % плохая f-оценка<br>
		 <br>   мин( X, Y, X) :-<br>    X =&lt; Y, !.<br>   мин( X, Y, Y).<br>   <b>Рис. 12.3.</b> Программа поиска с предпочтением.<br>
		 <br>   Аргументы процедуры расширить имеют следующий смысл:<br><br><table border="1" align="center">
<tr>
<td>Путь</td>
<td>Путь между стартовой вершиной и корнем дерева Дер.</td>
</tr>
<tr>
<td>Дер</td>
<td>Текущее (под)дерево поиска.</td>
</tr>
<tr>
<td>Предел</td>
<td>Предельное значение <i>f</i>-оценки, при котором допускается расширение.</td>
</tr>
<tr>
<td>Дер1</td>
<td>Дерево Дер, расширенное в пределах ограничения Предел; <i>f</i>-оценка дерева Дер1 больше, чем Предел (если только при расширении не была обнаружена целевая вершина).</td>
</tr>
<tr>
<td>ЕстьРеш</td>
<td>Индикатор, принимающий значения "да", "нет" и "никогда".</td>
</tr>
<tr>
<td>Решение</td>
<td>Решающий путь, ведущий из стартовой вершины через дерево Дер1 к целевой вершине и имеющий стоимость, не превосходящую ограничение Предел (если такая целевая вершина была обнаружена).</td>
</tr>
</table>
<br>   Переменные Путь, Дер, и Предел — это "входные" параметры процедуры расширить в том смысле, что при каждом обращении к расширить они всегда конкретизированы. Процедура расширить порождает результаты трех видов. Какой вид результата получен, можно определить по значению индикатора ЕстьРеш следующим образом:<br>   (1) ЕстьРеш = да<br>   Решение = решающий путь, найденный при расширении дерева Дер с учетом ограничения Предел.<br>   Дер1 = неконкретизировано.<br>   (2) ЕстьРеш = нет<br>   Дер1 = дерево Дер, расширенное до тех пор, пока его <i>f</i>-оценка не превзойдет Предел (см. рис. 12.4).<br>   Решение = неконкретизировано.<br>   (3) ЕстьРеш = никогда<br>   Дер1 и Решение = неконкретизированы.<br>   В последнем случае Дер является "тупиковой" альтернативой, и соответствующий процесс никогда не будет реактивирован для продолжения просмотра этого дерева. Случай этот возникает тогда, когда <i>f</i>-оценка дерева Дер не превосходит ограничения Предел, однако дерево не может "расти" потому, что ни один его лист не имеет преемников, или же любой преемник порождает цикл.<br>   Некоторые предложения процедуры расширить требуют пояснений. Предложение, относящееся к наиболее сложному случаю, когда Дер имеет поддеревья, т.е.<br>   Дер = д( В, F/G, [Д | ДД ] )<br>   означает следующее. Во-первых, расширению подвергается наиболее перспективное дерево Д. В качестве ограничения этому дереву выдается не Предел, а некоторое, возможно, меньшее значение Предел1, зависящее от <i>f</i>-оценок других конкурирующих поддеревьев ДД. Тем самым гарантируется, что "растущее" дерево — это всегда наиболее перспективное дерево, а переключение активности между поддеревьями происходит в соответствии с их  <i>f</i>-оценками. После того, как самый перспективный кандидат расширен, вспомогательная процедура продолжить решает, что делать дальше, а это зависит от типа результата, полученного после расширения. Если найдено решение, то оно и выдается, в противном случае процесс расширения деревьев продолжается.<br><div align="center"><img border="1" src="_83.png"></div>   <b>Рис. 12.4.</b> Отношение расширить: расширение дерева Дер до тех пор, пока <i>f</i>-оценка не превзойдет Предел, приводит к дереву Дер1.<br>   Предложение, относящееся к случаю<br>   Дер = л( В, F/G)<br>   порождает всех преемников вершины В вместе со стоимостями дуг, ведущих в них из В. Процедура преемспис формирует список поддеревьев, соответствующих вершинам-преемникам, а также вычисляет их <i>g-</i> и <i>f-</i>оценки, как показано на рис. 12.5. Затем полученное таким образом дерево подвергается расширению с учетом ограничения Предел. Если преемников нет, то переменной ЕстьРеш придается значение "никогда" и в результате лист В покидается навсегда.<br>   Другие отношения:<br><br><table border="1" align="center">
<tr>
<td>после( В, В1, С)</td>
<td>В1 — преемник вершины В; С — стоимость дуги, ведущей из В в В1.</td>
</tr>
<tr>
<td>h( В, H)</td>
<td>H — эвристическая оценка стоимости оптимального пути из вершины В в целевую вершину.</td>
</tr>
<tr>
<td>макс_f( Fмакс)</td>
<td>Fмакс — некоторое значение, задаваемое пользователем, про которое известно, что оно больше любой возможной <i>f</i>-оценки.</td>
</tr>
</table>
<br><div align="center"><img border="1" src="_84.png"></div>   <b>Рис. 12.5.</b> Связь между <i>g-</i>оценкой вершины <i>В</i> и <i>f-</i> и <i>g-</i>оценками ее "детей" в пространстве состояний.<br>   В следующих разделах мы покажем на примерах, как можно применить нашу программу поиска с предпочтением к конкретным задачам. А сейчас сделаем несколько заключительных замечаний общего характера относительно этой программы. Мы реализовали один из вариантов эвристического алгоритма, известного в литературе как А*-алгоритм (ссылки на литературу см. в конце главы). А*-алгоритм привлек внимание многих исследователей. Здесь мы приведем один важный результат, полученный в результате математического анализа А*-алгоритма:<br><blockquote>   Алгоритм поиска пути называют <i>допустимым</i>, если он всегда отыскивает оптимальное решение (т.е. путь минимальной стоимости) при условии, что такой путь существует. Наша реализация алгоритма поиска, пользуясь механизмом возвратов, выдает все существующие решения, поэтому, в нашем случае, условием допустимости следует считать оптимальность <i>первого</i> из найденных решений. Обозначим через <i>h*(n)</i> стоимость оптимального пути из произвольной вершины <i>n</i> в целевую вершину. Верна следующая теорема о допустимости А*-алгоритма: А*-алгоритм, использующий эвристическую функцию <i>h</i>, является допустимым, если<br>   <i> h</i>(<i>n</i>) &#8804; <i>h</i>*(<i>n</i>)<br>   для всех вершин <i>n</i> пространства состояний.<br></blockquote>   Этот результат имеет огромное практическое значение. Даже если нам не известно точное значение <i>h</i>*, нам достаточно найти какую-либо нижнюю грань <i>h</i>* и использовать ее в качестве <i>h</i> в А*-алгоритме — оптимальность решения будет гарантирована.<br>   Существует тривиальная нижняя грань, а именно:<br>   <i>h</i>(<i>n</i>) = 0,   для всех вершин <i>n</i> пространства состояний.<br>   И при таком значении <i>h</i> допустимость гарантирована. Однако такая оценка не имеет никакой эвристической силы и ничем не помогает поиску. А*-алгоритм при <i>h</i>=0 ведет себя аналогично поиску в ширину. Он, действительно, превращается в поиск в ширину, если, кроме того, положить <i>с</i>(<i>n</i>, <i>n'</i>)=1 для всех дуг (<i>n</i>, <i>n'</i>) пространства состояний. Отсутствие эвристической силы оценки приводит к большой комбинаторной сложности алгоритма. Поэтому хотелось бы иметь такую оценку <i>h</i>, которая была бы нижней гранью <i>h</i>* (чтобы обеспечить допустимость) и, кроме того, была бы как можно ближе к <i>h</i>* (чтобы обеспечить эффективность). В идеальном случае, если бы нам была известна сама точная оценка <i>h</i>*, мы бы ее и использовали: А*-алгоритм, пользующийся <i>h</i>*, находит оптимальное решение сразу, без единого возврата.<br><h5>Упражнение</h5>   <b>12.1.</b> Определите отношения после, цель и h для задачи поиска маршрута рис. 12.2. Посмотрите, как наш алгоритм поиска с предпочтением будет вести себя при решении этой задачи. <br></div>
<h3 align="center">
<a name="TOC_id3446118"></a>12.2. Поиск c предпочтением применительно к головоломке "игра в восемь"<br></h3>
<div>   Если мы хотим применить программу поиска с предпочтением, показанную на  рис. 12.3, к какой-нибудь задаче, мы должны добавить к нашей программе отношения, отражающие специфику этой конкретной задачи. Эти отношения определяют саму задачу ("правила игры"), а также вносят в алгоритм эвристическую информацию о методе ее решения. Эвристическая информация задается в форме эвристической функции.<br>
		 <br>   /* Процедуры, отражающие специфику головоломки<br>   "игра в восемь".<br>   Текущая ситуация представлена списком положений фишек;<br>   первый элемент списка соответствует пустой клетке.<br>   Пример:<br>    &#9484;&#9472;&#9472;&#9472;&#9488;<br>   3&#9474;123&#9474; Эта позиция представляется так:<br>   2&#9474;8 4&#9474; [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2]<br>   1&#9474;765&#9474;<br>    &#9492;&#9472;&#9472;&#9472;&#9496;<br>     123<br>   "Пусто" можно перемещать в любую соседнюю клетку,<br>   т.е. "Пусто" меняется местами со своим соседом.<br>   */<br>
		 <br>   после( [Пусто | Спис], [Фшк | Спис1], 1) :-<br>     % Стоимости всех дуг равны 1<br>    перест( Пусто, Фшк, Спис, Спис1).<br>     % Переставив Пусто и Фшк, получаем СПИС1<br>
		 <br>   перест( П, Ф, [Ф | С], [П | С] ) :-<br>    расст( П, Ф, 1).<br>   перест( П, Ф, [Ф1 | С], [Ф1 | C1] ) :-<br>    перест( П, Ф, С, C1).<br>
		 <br>   расст( X/Y, X1/Y1, P) :-<br>     % Манхеттеновское расстояние между клетками<br>    расст1( X, X1, Рx),<br>    расст1( Y, Y1, Рy),<br>    P is Рх + Py.<br>   расст1( А, В, P) :-<br>    P is А-В, P &gt;= 0, ! ;<br>    P is B-A.<br>
		 <br>   % Эвристическая оценка h равна сумме расстояний фишек<br>   % от их "целевых" клеток плюс "степень упорядоченности",<br>   % умноженная на 3<br>   h( [ Пусто | Спис], H) :-<br>    цель( [Пусто1 | Цспис] ),<br>    сумрасст( Спис, ЦСпис, P),<br>    упоряд( Спис, Уп),<br>    H is P + 3*Уп.<br>
		 <br>   сумрасст( [], [], 0).<br>   сумрасст( [Ф | С], [Ф1 | C1], P) :-<br>    расст( Ф, Ф1, P1),<br>    сумрасст( С, Cl, P2),<br>    P is P1 + Р2.<br>
		 <br>   упоряд( [Первый | С], Уп) :-<br>    упоряд( [Первый | С], Первый, Уп).<br>   упоряд( [Ф1, Ф2 | С], Первый, Уп) :-<br>    очки( Ф1, Ф2, Уп1),<br>    упоряд( [Ф2 | С], Первый, Уп2),<br>    Уп is Уп1 + Уп2.<br>   упоряд( [Последний], Первый, Уп) :-<br>    очки( Последний, Первый, Уп).<br>
		 <br>   очки( 2/2, _, 1) :- !. % Фишка в центре - 1 очко<br>   очки( 1/3, 2/3, 0) :- !.<br>     % Правильная последовательность - 0 очков<br>   очки( 2/3, 3/3, 0) :- !.<br>   очки( 3/3, 3/2, 0) :- !.<br>   очки( 3/2, 3/1, 0) :- !.<br>   очки( 3/1, 2/1, 0) :- !.<br>   очки( 2/1, 1/1, 0) :- !.<br>   очки( 1/1, 1/2, 0) :- !.<br>   очки( 1/2, 1/3, 0) :- !.<br>   очки( _, _, 2).        % Неправильная последовательность<br>
		 <br>   цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).<br>
		 <br>   % Стартовые позиции для трех головоломок<br>   старт1( [2/2, 1/3, 3/2, 2/3, 3/3, 3/1, 2/1, 1/1, 1/2] ).<br>     % Требуется для решения 4 шага<br>   старт2( [2/1, 1/2, 1/3, 3/3, 3/2, 3/1, 2/2, 1/1, 2/3] ).<br>     % 5 шагов<br>   старт3( [2/2, 2/3, 1/3, 3/1, 1/2, 2/1, 3/3, 1/1, 3/2] ).<br>     % 18 шагов<br>
		 <br>   % Отображение решающего пути в виде списка позиций на доске<br>   показреш( []).<br>   показреш( [ Поз | Спис] :-<br>    показреш( Спис),<br>    nl, write( '---'),<br>    показпоз( Поз).<br>
		 <br>   % Отображение позиции на доске<br>   показпоз( [S0, S1, S2, S3, S4, S5, S6, S7, S8] ) :-<br>    принадлежит Y, [3, 2, 1] ),     % Порядок Y-координат<br>    nl, принадлежит X, [1, 2, 3] ), % Порядок X-координат<br>    принадлежит( Фшк-X/Y,<br>    [' '-S0, 1-S1, 2-S2, 3-S3, 4-S4, 5-S5, 6-S6, 7-S7, 8-S8]),<br>    write( Фшк),<br>    fail. %Возврат с переходом к следующей клетке<br>   показпоз(_).<br>   <b>Рис. 12.6.</b> Процедуры для головоломки "игра в восемь", предназначенные для использования программой поиска с предпочтением рис. 12.3.<br>
		 <br>   Существуют три отношения, отражающих специфику конкретной задачи:<br>   после( Верш, Верш1, Ст)<br>   Это отношение истинно, когда в пространстве состояний существует дуга стоимостью Ст между вершинами Верш и Верш1.<br>   цель( Верш)<br>   Это отношение истинно, если Верш — целевая вершина.<br>   h( Верш, H)<br>   Здесь H — эвристическая оценка стоимости самого дешевого пути из вершины Верш в целевую вершину.<br>   В данном и следующих разделах мы определим эти отношения для двух примеров предметных областей: для головоломки "игра в восемь" (описанной в разделе 11.1) и планирования прохождения задач в многопроцессорной системе.<br>   Отношения для "игры в восемь" показаны на рис. 12.6. Вершина пространства состояний — это некоторая конфигурация из фишек на игровой доске. В программе она задается списком текущих положений фишек. Каждое положение определяется парой координат X/Y. Элементы списка располагаются в следующем порядке:<br>   (1) текущее положение пустой клетки,<br>   (2) текущее положение фишки 1,<br>   (3) текущее положение фишки 2,<br>   …<br>   Целевая ситуация (см. рис. 11.3) определяется при помощи предложения<br>   цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).<br>   Имеется вспомогательное отношение<br>   расст( K1, K2, P)<br>   P — это "манхеттеновское расстояние" между клетками K1 и K2, равное сумме двух расстояний между K1 и K2: расстояния по горизонтали и расстояния по вертикали.<br><div align="center"><img border="1" src="_85.png"></div>   <b>Рис. 12.7.</b> Три стартовых позиции для "игры в восемь": (а) решение требует 4 шага; (b) решение требует 5 шагов; (с) решение требует 18 шагов.<br>   Наша задача — минимизировать <i>длину</i> решения, поэтому мы положим стоимости всех дуг пространства состояний равными 1. В программе рис. 12. 6. даны также определения трех начальных позиций (см. рис. 12.7).<br>   Эвристическая функция <i>h</i>, запрограммирована как отношение<br>   h( Поз, H)<br>   Поз — позиция на доске; H вычисляется как комбинация из двух оценок:<br>   (1) сумрасст — "суммарное расстояние" восьми фишек, находящихся в позиции Поз, от их положений в целевой позиции. Например, для начальной позиции, показанной на рис. 12.7(а), сумрасст = 4.<br>   (2) упоряд — степень упорядоченности фишек в текущей позиции по отношению к тому порядку, в котором они должны находиться в целевой позиции. Величина упоряд вычисляется как сумма очков, приписываемых фишкам, согласно следующим правилам:<br>    • фишка в центральной позиции — 1 очко;<br>    • фишка не в центральной позиции, и непосредственно за ней следует (по часовой стрелке) та фишка, какая и должна за ней следовать в целевой позиции — 0 очков.<br>    • то же самое, но за фишкой следует "не та" фишка — 2 очка.<br>   Например, для начальной позиции рис.12.7(а),<br>   упоряд = 6.<br>   Эвристическая оценка H вычисляется как сумма<br>   H = сумрасст + 3 * упоряд<br>   Эта эвристическая функция хорошо работает в том смысле, что она весьма эффективно направляет поиск к цели. Например, при решении головоломок   рис. 12.7(а) и (b) первое решение обнаруживается без единого отклонения от кратчайшего решающего пути. Другими словами, кратчайшие решения обнаруживаются сразу, без возвратов. Даже трудная головоломка  рис. 12.7 (с) решается почти без возвратов. Но данная эвристическая функция страдает тем недостатком, что она не является допустимой: нет гарантии, что более короткие пути обнаруживаются раньше более длинных. Дело в том, что для функции <i>h</i> условие <i>h </i>&#8804;<i> h</i>* выполнено не для всех вершин пространства состояний. Например, для начальной позиции рис. 12.7 (а)<br>   <i>h</i> = 4 + 3 * 6 = 22,    <i>h</i>* = 4<br>   С другой стороны, оценка "суммарное расстояние" допустима: для всех позиций<br>   сумрасст &#8804;<i> h</i>*<br>   Доказать это неравенство можно при помощи следующего рассуждения: если мы ослабим условия задачи и разрешим фишкам взбираться друг на друга, то каждая фишка сможет добраться до своего целевого положения по траектории, длина которой в точности равна манхеттеновскому расстоянию между ее начальным и целевым положениями. Таким образом, длина оптимального решения упрощенной задачи будет в точности равна сумрасст. Однако в исходном варианте задачи фишки взаимодействуют друг с другом и мешают друг другу, так что им уже трудно идти по своим кратчайшим траекториям. В результате длина оптимального решения окажется больше либо равной сумрасст.<br><h5>Упражнение</h5>   <b>12.2.</b> Введите в программу поиска с предпочтением, приведенную на рис. 12.3, подсчет числа вершин, порожденных в процессе поиска. Один из простых способов это сделать — хранить текущее число вершин в виде факта, устанавливаемого при помощи assert. Всегда, когда порождаются новые вершины, уточнять это значение при помощи retract и assert. Проведите эксперименты с различными эвристическими функциями задачи "игра в восемь" с целью оценить их эвристическую силу. Используйте для этого вычисленное количество порожденных вершин. <br></div>
<h3 align="center">
<a name="TOC_id3446816"></a>12.3. Применение поиска с предпочтением к планированию выполнения задач<br></h3>
<div>   Рассмотрим следующую задачу планирования. Дана совокупность <i>задач t</i><sub>1</sub>, <i>t</i><sub>2</sub>, …, имеющих времена выполнения соответственно <i>T1</i>, <i>Т2</i>, …. Все эти задачи нужно решить на  <i>m</i>   идентичных процессорах. Каждая задача может быть решена на любом процессоре, но в каждый данный момент каждый процессор решает только одну из задач. Между задачами существует отношение предшествования, определяющее, какие задачи (если таковые есть) должны быть завершены, прежде чем данная задача может быть запущена. Необходимо распределить задачи между процессорами без нарушения отношения предшествования, причем таким образом, чтобы вся совокупность задач была решена за минимальное время. Время, когда последняя задача в соответствии с выработанным планом завершает свое решение, называется <i>временем окончания</i> плана. Мы хотим минимизировать время окончания по всем возможным планам.<br>   На рис. 12.8 показан пример задачи планирования, а также приведено два корректных плана, один из которых оптимален. Из примера видно, что оптимальный план обладает одним интересным свойством, а именно в нем может предусматриваться "время простоя" процессоров. В оптимальном плане рис. 12.8 процессор 1, выполнив задачу <i>t</i>, ждет в течение двух квантов времени, несмотря на то, что он мог бы начать выполнение задачи <i>t</i>.<br><div align="center"><img border="1" src="_86.png"></div>   <b>Рис. 12.8.</b> Планирование прохождения задач в многопроцессорной системе для 7 задач и 3 процессоров. Вверху показано предшествование задач и величины продолжительности их решения. Например, задача <i>t</i><sub>5</sub> требует 20 квантов времени, причем ее выполнение может начаться только после того, как будет завершено решение трех других задач <i>t</i><sub>1</sub>, <i>t</i><sub>2</sub> и <i>t<sub>3</sub></i>. Показано два корректных плана: оптимальный план с временем окончания 24 и субоптимальный — с временем окончания 33. В данной задаче любой оптимальный план должен содержать время простоя. Coffman/ Denning, <i>Operating Systems Theory</i>, © 1973, p.86. Приведено с разрешения Prentice-Hall, Englewood Cliffs, New Jersey.<br>   Один из способов построить план можно грубо сформулировать так. Начинаем с пустого плана (с незаполненными временными промежутками для каждого процессора) и постепенно включаем в него задачи одну за другой, пока все задачи не будут исчерпаны. Как правило, на каждом шагу мы будем иметь несколько различных возможностей, поскольку окажется, что одновременно несколько задач-кандидатов ждут своего выполнения. Таким образом, для составления плана потребуется перебор. Мы можем сформулировать задачу планирования в терминах пространства состояний следующим образом:<br>   • состояния — это частично составленные планы;<br>   • преемник частичного плана получается включением в план еще одной задачи; другая возможность — оставить процессор, только что закончивший свою задачу, в состоянии простоя;<br>   • стартовая вершина — пустой план;<br>   • любой план, содержащий все задачи, — целевое состояние;<br>   • стоимость решения (подлежащая минимизации) — время окончания целевого плана;<br>   • стоимость перехода от одного частичного плана к другому равна <i>К</i><sub>2</sub>–<i>К</i><sub>1</sub> где <i>К</i><sub>1</sub>, <i>К</i><sub>2</sub> — времена окончания этих планов.<br>   Этот грубый сценарий требует некоторых уточнений. Во-первых, мы решим заполнять план в порядке возрастания времен, так что задачи будут включаться в него слева направо. Кроме того, при добавлении каждой задачи следует проверять, выполнены ли ограничения, связанные с отношениями предшествования. Далее, не имеет смысла оставлять процессор бездействующим на неопределенное время, если имеются задачи, ждущие своего запуска. Поэтому мы разрешим процессору простаивать только до того момента, когда какой-нибудь другой процессор завершит выполнение своей задачи. В этот момент мы еще раз вернемся к свободному процессору с тем, чтобы рассмотреть возможность приписывания ему какой-нибудь задачи.<br>   Теперь нам необходимо принять решение относительно представления проблемных ситуаций, т.е. частичных планов. Нам понадобится следующая информация:<br>   (1) список ждущих задач вместе с их временами выполнения;<br>   (2) текущая загрузка процессоров задачами.<br>   Добавим также для удобства программирования<br>   (3) время окончания (частичного) плана, т.е. самое последнее время окончания задачи среди всех задач, приписанных процессорам.<br>   Список ждущих задач вместе с временами их выполнения будем представлять в программе при помощи списка вида<br>   [ Задача1/Т1, Задача2/Т2, ... ]<br>   Текущую загрузку процессоров будем представлять как список решаемых задач, т.е. список пар вида<br>   [ Задача/ВремяОкончания ]<br>   В списке <i>m</i> таких пар, по одной на каждый процессор. Новая задача будет добавляться к плану в момент, когда закончится первая задача из этого списка. В связи с этим мы должны постоянно поддерживать упорядоченность списка загрузки по возрастанию времен окончания. Эти три компоненты частичного плана (ждущие задачи, текущая загрузка и время окончания плана) будут объединены в одно выражение вида<br>   Ждущие * Активные * ВремяОкончания<br>   Кроме этой информации у нас есть ограничения, налагаемые отношениями предшествования, которые в программе будут выражены в форме отношения<br>   предш( ЗадачаX, ЗадачаY)<br>   Рассмотрим теперь эвристическую оценку. Мы будем использовать довольно примитивную эвристическую функцию, которая не сможет обеспечить высокую эффективность управления алгоритмом поиска. Эта функция допустима, так что получение оптимального плана будет гарантировано. Однако следует заметить, что для решения более серьезных задач планирования потребуется более мощная эвристика.<br>   Нашей эвристической функцией будет оптимистическая оценка времени окончания частичного плана с учетом всех ждущих задач. Оптимистическая оценка будет вычисляться в предположении, что два из ограничений, налагаемых на действительно корректный план, ослаблены:<br>   (1) не учитываются отношения предшествования;<br>   (2) делается (не реальное) допущение, что возможно распределенное выполнение задачи одновременно на нескольких процессорах, причем сумма времен выполнения задачи на процессорах равна исходному времени выполнения этой задачи на одном процессоре.<br>   Пусть времена выполнения ждущих задач равны <i>Т</i><sub>1</sub>, <i>Т</i><sub>2</sub>, …, а времена окончания задач, выполняемых на процессорах — <i>К</i><sub>1</sub>, <i>К</i><sub>2</sub>, …. Тогда оптимистическая оценка времени <i>ОбщКон</i> окончания всех активных к настоящему моменту, а также всех ждущих задач имеет вид:<br>    <img border="0" src="img_1.png"><br>   где <i>m</i> — число процессоров. Пусть время окончания текущего частичного плана равно<br>    <img border="0" src="img_2.png"><br>   Тогда эвристическая оценка <i>H</i> (дополнительное время для включения в частичный план ждущих задач) определяется следующим выражением:<br>   if <i>ОбщКон&gt;Кон</i> then <i>H = ОбщКон-Кон</i> else <i>H=</i>0<br>   Программа, содержащая определения отношений, связанных с пространством состояний нашей задачи планирования, приведена полностью на рис. 12.9. Эта программа включает в себя также спецификацию конкретной задачи планирования, показанной на рис. 12.3. Одно из оптимальных решений, полученных в процессе поиска с предпочтением в определенном таким образом пространстве состояний, показано на рис. 12.8.<br>
		 <br>   /* Отношения для задачи планирования.<br>   Вершины пространства состояний - частичные планы,<br>   записываемые как<br>    [ Задача1/Т1, Задача2/Т2, ...]*<br>    [ Задача1/К1, Задача2/К2, ...]* ВремяОкончания<br>   В первом списке указываются ждущие задачи и продолжительности их выполнения; во втором - текущие решаемые задачи и их времена окончания, упорядоченные так, чтобы выполнялись неравенства K1&#8804;K2, K2&#8804;K3, ... .<br>   Время окончания плана - самое последнее по времени время окончания задачи.<br>   */<br>   после( Задачи1*[ _ /К | Акт1]*Кон1,<br>    Задачи2*Акт2*Кон2, Ст):-<br>    удалить( Задача/T, Задачи1, Задачи2),<br>     % Взять ждущую задачу<br>    not( принадлежит( Здч1/_, Задачи2),<br>    раньше( ЗДЧ, Задача) ),<br>     % Проверить предшествование<br>    not( принадлежит( Здч1/К1, Акт1), К1&lt;К2,<br>    раньше( К1, Задача) ),    % Активные задачи<br>    Время is К + T,<br>     % Время окончания работающей задачи<br>    встав( ЗадачаВремя, Акт1, Акт2, Кон1, Кон2),<br>    Ст is Кон2 - Кон1.<br>   после( Задачи*[ _ /К | Акт1]*Кон, Задачи2*Акт2*Кон, 0):-<br>    вставпростой( К, Акт1, Акт2).<br>     % Оставить процессор бездействующим<br>
		 <br>   раньше( Задача1, Задача2) :-<br>     % В соответствии с предшествованием<br>    предш( Задача1, Задача2).<br>     % Задача1 раньше, чем Задача2<br>   раньше( Здч1, Здч2) :-<br>    предш( Здч, Здч2),<br>    раньше( Здч1, Здч).<br>
		 <br>   встав( Здч/А, [Здч1/В | Спис], [Здч/А, Здч1/В | Спис], К, К):-<br>     % Список задач упорядочен<br>    А =&lt; В, !.<br>   встав( Здч/А, [Здч1/В | Спнс], [Здч1/В | Спис1], К1, К2) :-<br>    встав( Здч/А, Спис, Спис1, Kl, К2).<br>   встав( Здч/А, [ ], [Здч/А], _, А).<br>
		 <br>   вставпростой( А, [Здч/В | Спис], [простой/В, Здч/В | Спис]):-<br>              % Оставить процессор бездействующим<br>    А &lt; В, !. % До ближайшего времени окончания<br>
		 <br>   вставпростой( А, [Здч/В | Спис], [Здч/В | Спис1]) :-<br>    вставпростой( А, Спис, Спис1 ).<br>
		 <br>   удалить( А, [А | Спис], Спис ).<br>     % Удалить элемент из списка<br>   удалить( А, [В | Спис], [В | Спис1] ):-<br>    удалить( А, Спис, Спис1 ).<br>
		 <br>   цель( [] *_*_ ). % Целевое состояние: нет ждущих задач<br>
		 <br>   % Эвристическая оценка частичного плана основана на<br>   % оптимистической оценке последнего времени окончания<br>   % этого частичного плана,<br>   % дополненного всеми остальными ждущими задачами.<br>   h( Задачи * Процессоры * Кон, H) :-<br>    сумвремя( Задачи, СумВремя),<br>     % Суммарная продолжительность<br>     % ждущих задач<br>    всепроц( Процессоры, КонВремя, N),<br>     % КонВремя - сумма времен окончания<br>     % для процессоров, N - их количество<br>    ОбщКон is ( СумВремя + КонВремя)/N,<br>    ( ОбщКон &gt; Кон, !, H is ОбщКон - Кон; H = 0).<br>
		 <br>   сумвремя( [], 0).<br>   сумвремя( [ _ /T | Задачи], Вр) :-<br>    сумвремя( Задачи, Вр1),<br>    Вр is Bp1 + T.<br>
		 <br>   всепроц( [], 0, 0).<br>   всепроц( [ _ /T | СписПроц], КонВр, N) :-<br>    всепроц( СписПроц, КонВр1, N1),<br>    N is N1 + 1,<br>    КонВр is КонВр1 + T.<br>
		 <br>   % Граф предшествования задач<br>    предш( t1, t4). предш( t1, t5). предш( t2, t4).<br>    предш( t2, t5). предш( t3, t5). предш( t3, t6).<br>    предш( t3, t7).<br>
		 <br>   % Стартовая вершина<br>   старт( [t1/4, t2/2, t3/2, t4/20, t5/20, t6/11, t7/11] *<br>    [простой/0, простой/0, простой/0] * 0 ).<br>   <b>Рис. 12.9.</b> Отношения для задачи планирования. Даны также определения отношений для конкретной задачи планирования с рис. 12.8: граф предшествования и исходный (пустой) план в качестве стартовой вершины.<br>
		 <br><h5>Проект</h5>   Вообще говоря, задачи планирования характеризуются значительной комбинаторной сложностью. Наша простая эвристическая функция не обеспечивает высокой эффективности управления поиском. Предложите другие эвристические функции и проведите с ними эксперименты.<br></div>
<h3 align="center">
<a name="TOC_id3447546"></a>Резюме<br></h3>
<div>   • Для оценки степени удаленности некоторой вершины пространства состояний от ближайшей целевой вершины можно использовать эвристическую информацию. В этой главе были рассмотрены численные эвристические оценки.<br>   • Эвристический принцип поиска с предпочтением направляет процесс поиска таким образом, что для продолжения поиска всегда выбирается вершина, наиболее перспективная с точки зрения эвристической оценки.<br>   • В этой главе был запрограммирован алгоритм поиска, основанный на указанном принципе и известный в литературе как А*-алгоритм.<br>   • Для того, чтобы решить конкретную задачу при помощи А*-алгоритма, необходимо определить пространство состояний и эвристическую функцию. Для сложных задач наиболее трудным моментом является подбор хорошей эвристической функции.<br>   • <i>Теорема о допустимости</i> помогает установить, всегда ли А*-алгоритм, использующий некоторую конкретную эвристическую функцию, находит оптимальное решение.<br><h5>Литература</h5>   Программа поиска с предпочтением, представленная в настоящей главе, — это один из многих вариантов похожих друг на друга программ, из которых А*-алгоритм наиболее популярен. Общее описание А*-алгоритма можно найти в книгах Nillson (1971, 1980) или Winston (1984). Теорема о допустимости впервые доказана авторами статьи Hart, Nilsson, and Raphael (1968). Превосходное и строгое изложение многих разновидностей алгоритмов поиска с предпочтением и связанных с ними математических результатов дано в книге Pearl (1984). В статье Doran and Michie (1966) впервые изложен поиск с предпочтением, управляемый оценкой расстояния до цели.<br>   Головоломка "игра в восемь" использовалась многими исследователями в области искусственного интеллекта в качестве тестовой задачи при изучении эвристических принципов (см., например, Doran and Michie (1966), Michie and Ross (1970) и Gaschnig (1979)).<br>   Задача планирования, рассмотренная в настоящей главе, также как и многие ее разновидности, возникает во многих прикладных областях в ситуации, когда необходимо спланировать обслуживание запросов на ресурсы. Один из примеров — операционные системы вычислительных машин. Задача планирования со ссылкой на это конкретное приложение изложена в книге Coffman and Denning (1973).<br>   Найти хорошую эвристику — дело важное и трудное, поэтому изучение эвристик — одна из центральных тем в искусственном интеллекте. Существуют, однако, некоторые границы, за которые невозможно выйти, двигаясь в направлении улучшения качества эвристик. Казалось бы, все, что необходимо для эффективного решения комбинаторной задачи — это найти мощную эвристику. Однако есть задачи (в том числе многие задачи планирования), для которых не существует универсальной эвристики, обеспечивающей во всех случаях как эффективность, так и допустимость. Многие теоретические результаты, имеющие отношение к этому ограничению, собраны в работе Garey and Johnson (1979).<br>
		 <br>   Coffman E.G. and Denning P.J. (1973). <i>Operating Systems Theory.</i> Prentice-Hall.<br>   Doran J. and Michie D. (1966). Experiments with the graph traverser program. <i>Proc. Royal Socieiy of London</i> <b>294(A)</b>: 235-259.<br>   Garey M. R. and Johnson D. S. (1979). <i>Computers and Intractability</i>. W. H. Freeman. [Имеется перевод: Гэри M., Джонсон Д. С- Вычислительные машины и труднорешаемые задачи. — M.: Мир, 1982.]<br>   Gaschnig J. (1979). Performance measurement and analysis of certain search algorithms. Carnegie-Mellon University: Computer Science Department-Technical Report CMU-CS-79-124 (Ph. D. Thesis).<br>   Hart P.E., Nilsson N.J. and Raphael B. (1968). A formal basis for the heuristic determination of minimum cost paths. <i>IEEE Transactions on Systems Sciences and Cybernetics</i> <b>SSC-4(2)</b>:100-107<br>   Michie D. and Ross R. (1970). Experiments with the adaptive graph traverser. <i>Machine Intelligence</i> <b>5</b>: 301–308.<br>   Nilsson N.J. (1971). <i>Problem — Solving Methods in Artificial Intelligence</i>. McGraw-Hill. [Имеется перевод: Нильсон H. Искусственный интеллект. Методы поиска решений. — M: Мир, 1973.]<br>   Nilsson N. J. (1980). <i>Principles of Artificial Intelligence</i>. Tioga; also Springer-Verlag.<br>   Pearl J. (1984). <i>Heuristics: Intelligent Search Strategies for Computer Problem Solving</i>. Addison-Wesley.<br>   Winston P. H. (1984). <i>Artificial Intelligence</i> (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — M.: Мир, 1980.]<br></div>
</div>
<h2 align="center">
<a name="TOC_id3447709"></a>Глава 13<br>Сведение задач к подзадачам. И/ИЛИ-Графы<br></h2>
<div>
<div>   Представление в виде И/ИЛИ-графов наиболее хорошо приспособлено для задач, которые естественным образом разбиваются на взаимно независимые подзадачи. Примерами таких задач могут служить поиск маршрута, символическое интегрирование, а также игровые задачи, доказательство теорем и т.п. В этой главе мы разработаем программы для поиска в И/ИЛИ-графах, в том числе программу поиска с предпочтением, управляемого эвристиками.<br></div>
<h3 align="center">
<a name="TOC_id3447728"></a>13.1. Представление задач в виде И/ИЛИ-графов<br></h3>
<div>   В главах 11 и 12, говоря о решении задач, мы сконцентрировали свое внимание на пространстве состояний как средстве представления этих задач. В соответствии с таким подходом решение задач сводилось к поиску пути в графе пространства состояний. Однако для некоторых категорий задач представление в форме И/ИЛИ-графа является более естественным. Такое представление основано на разбиении задач на подзадачи. Разбиение на подзадачи дает преимущества в том случае, когда подзадачи взаимно независимы, а, следовательно, и решать их можно независимо друг от друга.<br>   Проиллюстрируем это на примере. Рассмотрим задачу отыскания на карте дорог маршрута между двумя заданными городами, как показано на рис. 13.1. Не будем пока учитывать длину путей. Разумеется, эту задачу можно сформулировать как поиск пути в пространстве состояний. Соответствующее пространство состояний выглядело бы в точности, как карта рис. 13.1: вершины соответствуют городам, дуги — непосредственным связям между городами. Тем не менее давайте построим другое представление, основанное на естественном разбиении этой задачи на подзадачи.<br><div align="center"><img border="1" src="_88.png"></div>   <b>Рис. 13.1.</b> Поиск маршрута из <i>а</i> в <i>z</i> на карте дорог. Через реку можно переправиться в городах <i>f</i> и <i>g</i>. И/ИЛИ-представление этой задачи показано на рис. 13.2.<br>   На карте рис. 13.1 мы видим также реку. Допустим, что переправиться через нее можно только по двум мостам: один расположен в городе <i>f</i>, другой — в городе <i>g</i>. Очевидно, что искомый маршрут обязательно должен проходить через один из мостов, а значит, он должен пройти либо через <i>f</i>, либо через <i>g</i>. Таким образом, мы имеем две главных альтернативы:<br>   Для того, чтобы найти путь из <i>а</i> в <i>z</i>, необходимо найти <i>одно из двух</i>:<br>   (1) путь из <i>а</i> в <i>z</i>, проходящий через <i>f</i>, или<br>   (2) путь из <i>а</i> в <i>z</i>, проходящий через  <i>g</i>.<br><div align="center"><img border="1" src="_89.png"></div>   <b>Рис. 13.2.</b> И/ИЛИ-представление задачи поиска маршрута рис. 13.1. Вершины соответствуют задачам или подзадачам, полукруглые дуги означают, что все (точнее, обе) подзадачи должны быть решены.<br>   Теперь каждую из этих двух альтернативных задач можно, в свою очередь, разбить следующим образом:<br>   (1) Для того, чтобы найти путь из <i>a</i> в <i>z</i> через <i>f</i>, необходимо:<br>      1.1 найти путь из <i>а</i> и <i>f  и</i><br>      1.2 найти путь из <i>f</i> в <i>z</i>.<br>   (2) Для того, чтобы найти путь из <i>a</i> в <i>z</i> через <i>g</i>, необходимо:<br>      2.1 найти путь из <i>а</i> в <i>g  и</i><br>      2.2 найти путь из <i>g</i> в <i>z</i>.<br><div align="center"><img border="1" src="_90.png"></div>   <b>Рис. 13.3.</b> (а) Решить P — это значит решить  P<sub>1</sub> или Р<sub>2</sub> или … (б) Решить Q — это значит решить все: Q<sub>1</sub> и Q<sub>2</sub> и ….<br>   Итак, мы имеем две главных альтернативы для решения исходной задачи: (1) путь через <i>f</i> или (2) путь через <i>g</i>. Далее, каждую из этих альтернатив можно <i>разбить на подзадачи</i> (1.1 и 1.2 или 2.1 и 2.2 соответственно). Здесь важно то обстоятельство, что каждую из подзадач в обоих альтернативах можно решать независимо от другой. Полученное разбиение исходной задачи можно изобразить в форме <i>И/ИЛИ-графа</i> (рис. 13.2). Обратите внимание на полукруглые дуги, которые указывают на отношение И между соответствующими подзадачами. Граф, показанный на рис. 13.2 — это всего лишь верхняя часть всего И/ИЛИ-дерева. Дальнейшее разбиение подзадач можно было бы строить на основе введения дополнительных промежуточных городов.<br>   Какие вершины  И/ИЛИ-графа  являются целевыми? Целевые вершины — это тривиальные, или "примитивные" задачи. В нашем примере такой подзадачей можно было бы считать подзадачу "найти путь из <i>а</i> в <i>с</i>", поскольку между городами <i>а</i> и <i>с</i> на карте имеется непосредственная связь.<br>   Рассматривая наш пример, мы ввели ряд важных понятий. И/ИЛИ-граф — это направленный граф, вершины которого соответствуют задачам, а дуги — отношениям между задачами. Между дугами также существуют свои отношения. Это отношения И и ИЛИ, в зависимости от того, должны ли мы решить только одну из задач-преемников или же несколько из них (см. рис. 13.3). В принципе из вершины могут выходить дуги, находящиеся в отношении И вместе с дугами, находящимися в отношении ИЛИ. Тем не менее, мы будем предполагать, что каждая вершина имеет либо только И-преемников, либо только ИЛИ-преемников; дело в том, что в такую форму можно преобразовать любой И/ИЛИ граф, вводя в него при необходимости вспомогательные ИЛИ-вершины. Вершину, из которой выходят только И-дуги, называют И-вершиной; вершину, из которой выходят только ИЛИ-дуги, — ИЛИ-вершиной.<br>   Когда задача представлялась в форме пространства состояний, ее решением был путь в этом пространстве. Что является решением в случае И/ИЛИ-представления? Решение должно, конечно, включать в себя все подзадачи И-вершины. Следовательно, это уже не путь, а дерево. Такое решающее дерево T определяется следующим образом:<br>   • исходная задача P — это корень дерева T;<br>   • если P является ИЛИ-вершиной, то в T содержится только один из ее преемников (из И/ИЛИ-графа) вместе со своим собственным решающим деревом;<br>   • если P — это И-вершина, то все ее преемники (из И/ИЛИ-графа) вместе со своими решающими деревьями содержатся в T.<br><div align="center"><img border="1" src="_91.png"></div>   <b>Рис. 13.4.</b> (а) Пример И/ИЛИ-графа: <i>d</i>, <i>g</i> и <i>h</i> — целевые вершины; <i>a</i> — исходная задача. (b) и (с) Два решающих дерева, стоимости которых равны 9 и 8 соответственно. Здесь стоимость решающего дерева определена как сумма стоимостей всех входящих в него дуг.<br>   Иллюстрацией к этому определению может служить рис. 13.4. Используя стоимости, мы можем формулировать критерии оптимальности решения. Например, можно определить стоимость решающего графа как сумму стоимостей всех входящих в него дуг. Тогда, поскольку обычно мы заинтересованы в минимизации стоимости, мы отдадим предпочтение решающему графу, изображенному на рис. 13.4(с).<br>   Однако мы не обязательно должны измерять степень оптимальности решения, базируясь на стоимостях дуг. Иногда более естественным окажется приписывать стоимость не дугам, а вершинам, или же и тем, и другим одновременно.<br>   Подведем итоги:<br>   • И/ИЛИ-представление основано на философии сведения задач к подзадачам.<br>   • Вершины И/ИЛИ-графа соответствуют задачам; связи между вершинами — отношениям между задачами.<br>   • Вершина, из которой выходят ИЛИ-связи, называется ИЛИ-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить одну из ее задач-преемников.<br>   • Вершина, из которой выходят И-связи, называется И-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить все ее задачи-преемники.<br>   • При заданном И/ИЛИ-графе конкретная задача специфицируется заданием<br>     стартовой вершины и<br>     целевого условия для распознавания<br>     целевых вершин.<br>   • <i>Целевые вершины</i> (или "терминальные вершины") соответствуют тривиальным (или "примитивным") задачам.<br>   • Решение представляется в виде <i>решающего графа</i> — подграфа всего И/ИЛИ-графа.<br>   • Представление задач в форме пространства состояний можно рассматривать как специальный частный случай И/ИЛИ-представления, когда все вершины И/ИЛИ-графа являются ИЛИ-вершинами.<br>   • И/ИЛИ-представление имеет преимущество в том случае, когда вершинами, находящимися в отношении И, представлены подзадачи, которые можно решать независимо друг от друга. Критерий независимости можно несколько ослабить, а именно потребовать, чтобы существовал такой порядок решения И-задач, при котором решение более "ранних" подзадач не разрушалось бы при решении более "поздних" под задач.<br>   • Дугам или вершинам, или и тем, и другим можно приписать стоимости с целью получить возможность сформулировать критерий оптимальности решения.<br></div>
<h3 align="center">
<a name="TOC_id3448157"></a>13.2. Примеры И/ИЛИ-представления задач <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3448163"></a>13.2.1. И/ИЛИ-представление задачи поиска маршрута<br></h4>
<div>   Для задачи отыскания кратчайшего маршрута (рис. 13.1) И/ИЛИ-граф вместе с функцией стоимости можно определить следующим образом:<br>   • ИЛИ-вершины представляются в форме X-Z, что означает: найти кратчайший путь из X в Z.<br>   • И-вершины имеют вид <br>     X-Z через Y<br>   что означает: найти кратчайший путь из X в Z, проходящий через Y.<br>   • Вершина X-Z является целевой вершиной (примитивной задачей), если на карте существует непосредственная связь между X и Z.<br>   • Стоимость каждой целевой вершины X-Z равна расстоянию, которое необходимо  преодолеть по дороге, соединяющей X с Z.<br>   • Стоимость всех остальных (нетерминальных) вершин равна 0.<br>   Стоимость решающего графа равна сумме стоимостей всех его вершин (в нашем случае это просто сумма стоимостей всех терминальных вершин). В задаче рис. 13.1 стартовая вершина — это <i>а-z</i>. На рис. 13.5 показан решающий граф, имеющий стоимость 9. Это дерево соответствует пути [a, b, d, f, i, z], который можно построить, если пройти по всем листьям решающего дерева слева направо.<br><div align="center"><img border="1" src="_92.png"></div>   <b>Рис. 13.5.</b> Решающее дерево минимальной стоимости для задачи поиска маршрута рис. 13.1, сформулированной в терминах И/ИЛИ-графа. <br></div>
<h4 align="center">
<a name="TOC_id3448225"></a>13.2.2. Задача о ханойской башне<br></h4>
<div>   Задача о ханойской башне (рис. 13.6) — это еще один классический пример эффективного применения метода разбиения задачи на подзадачи и построения И / ИЛИ-графа. Для простоты мы рассмотрим упрощенную версию этой задачи, когда в ней участвует только три диска:<br>   Имеется три колышка 1, 2 и 3 и три диска <i>а</i>, <i>b</i> и <i>с</i> (<i>а</i> — наименьший из них, а <i>с</i> — наибольший). Первоначально все диски находятся на колышке 1. Задача состоит в том, чтобы переложить все диски на колышек 3. На каждом шагу можно перекладывать только один диск, причем никогда нельзя помещать больший диск на меньший.<br>   Эту задачу можно рассматривать как задачу достижения следующих трех целей:<br>   (1) Диск <i>а</i> — на колышек 3.<br>   (2) Диск <i>b</i> — на колышек 3.<br>   (3) Диск <i>с</i> — на колышек 3.<br>   Беда в том, что эти цели не независимы. Например, можно сразу переложить диск <i>а</i> на колышек 3, и первая цель будет достигнута. Но тогда две другие цели станут недостижимыми (если только мы не отменим первое наше действие). К счастью, существует такой удобный порядок достижения этих целей, из которого можно легко вывести искомое решение.<br><div align="center"><img border="1" src="_93.png"></div>   <b>Рис. 13.6.</b> Задача о ханойской башне<br>   Порядок этот можно установить при помощи следующего рассуждения: самая трудная цель — это цель 3 (диск <i>с</i> — на колышек 3), потому что на диск <i>c</i> наложено больше всего ограничений. В подобных ситуациях часто срабатывает хорошая идея: пытаться достичь первой самую трудную цель. Этот принцип основан на следующей логике: поскольку другие цели достигнуть легче (на них меньше ограничений), можно надеяться на то, что их достижение возможно без отмены действий на достижение самой трудной цели.<br>   Применительно к нашей задаче это означает, что необходимо придерживаться следующей стратегии:<br>   Первой достигнуть цель "диск <i>с</i> — на колышек 3", а затем — все остальные.<br>   Но первая цель не может быть достигнута сразу, так как в начальной ситуации диск <i>с</i> двигать нельзя. Следовательно, сначала мы должны подготовить этот ход, и наша стратегия принимает такой вид<br>   (1) Обеспечить возможность перемещения диска <i>с</i> с 1 на 3.<br>   (2) Переложить <i>с</i> с 1 на 3.<br>   (3) Достигнуть остальные цели (<i>а</i> на 3 и <i>b</i> на 3).<br>   Переложить <i>c</i> с 1 на 3 возможно только в том случае, если диск <i>а</i> и <i>b</i> оба надеты на колышек 2. Таким образом наша исходная задача перемещения <i>а</i>, <i>b</i> и <i>с</i> с 1 на 3 сводится к следующим трем подзадачам:<br>   Для того, чтобы переложить <i>a</i>, <i>b</i> и <i>с</i> с 1 на 3, необходимо<br>   (1) переложить <i>а</i> и <i>b</i> с 1 на 2, <i>и</i><br>   (2) переложить <i>с</i> с 1 на 3, <i>и</i><br>   (3) переложить <i>а</i> и <i>b</i> с 2 на 3.<br>   Задача 2 тривиальна (она решается за один шаг). Остальные две подзадачи можно решать независимо от задачи 2, так как диски <i>а</i> и <i>b</i> можно двигать, не обращая внимание на положение диска <i>с</i>. Для решения задач 1 и 3 можно применить тот же самый принцип разбиения (на этот раз диск <i>b</i> будет самым "трудным"). В соответствии с этим принципом задача 1 сводится к трем тривиальным подзадачам:<br>   Для того, чтобы переложить <i>а</i> и <i>b</i> с 1 на 2, необходимо:<br>   (1) переложить <i>а</i> с 1 на 3, <i>и</i><br>   (2) переложить <i>b</i> с 1 на 2, <i>и</i><br>   (3) переложить <i>а</i> с 3 на 2.<br></div>
<h4 align="center">
<a name="TOC_id3448510"></a>13.2.3. Формулировка игровых задач в терминах И/ИЛИ-графов<br></h4>
<div>   Такие игры, как шахматы или шашки, естественно рассматривать как задачи, представленные И/ИЛИ-графами. Игры такого рода называются играми двух лиц с полной информацией. Будем считать, что существует только два возможных исхода игры: ВЫИГРЫШ и ПРОИГРЫШ. (Об играх с тремя возможными исходами — ВЫИГРЫШ, ПРОИГРЫШ и НИЧЬЯ, можно также говорить, что они имеют только два исхода: ВЫИГРЫШ и НЕВЫИГРЫШ). Так как участники игры ходят по очереди, мы имеем два вида позиций, в зависимости от того, чей ход. Давайте условимся называть участников игры "игрок" и "противник", тогда мы будем иметь следующие два вида позиций: позиция с ходом игрока ("позиция игрока") и позиция с ходом противника ("позиция противника"). Допустим также, что начальная позиция <i>P</i> — это позиция игрока. Каждый вариант хода игрока в этой позиции приводит к одной из позиций противника  <i>Q</i><sub>1</sub>, <i>Q</i><sub>2</sub>, <i>Q</i><sub>3</sub>, … (см. рис. 13.7). Далее каждый вариант хода противника в позиции <i>Q</i><sub>1</sub> приводит к одной из позиций игрока <i>R</i><sub>11</sub>, <i>R</i><sub>12</sub>, …. В  И/ИЛИ-дереве, показанном на рис. 13.7, вершины соответствуют позициям, а дуги — возможным ходам. Уровни позиций игрока чередуются в дереве с уровнями позиций противника. Для того, чтобы выиграть в позиции <i>P</i>, нужно найти ход, переводящий <i>P</i> в выигранную позицию <i>Q<sub>i</sub></i>. (при некотором <i>i</i>). Таким образом, игрок выигрывает в позиции <i>P</i>, если он выигрывает в <i>Q<sub>1</sub></i>, <i>или  Q<sub>2</sub></i>, <i>или  Q<sub>3</sub></i>, <i>или</i> …. Следовательно, <i>P</i> — это ИЛИ-вершина. Для любого <i>i</i> позиция  <i>Q<sub>i</sub></i> — это позиция противника, поэтому если в этой позиции выигрывает игрок, то он выигрывает и после каждого варианта хода противника. Другими словами, игрок выигрывает в <i>Q<sub>i</sub></i>, если он выигрывает во всех позициях <i>R<sub>i1</sub> и R<sub>i2</sub> и</i> ….  Таким образом, все позиции противника — это И-вершины. Целевые вершины — это позиции, выигранные согласно правилам игры, например позиции, в которых король противника получает мат. Позициям проигранным соответствуют задачи, не имеющие решения. Для того, чтобы решить игровую задачу, мы должны построить решающее дерево, гарантирующее победу игрока независимо от ответов противника. Такое дерево задает полную стратегию достижения выигрыша: для каждого возможного продолжения, выбранного противником, в дереве стратегии есть ответный ход, приводящий к победе.<br><div align="center"><img border="1" src="_94.png"></div>   <b>Рис. 13.7.</b> Формулировка игровой задачи для игры двух лиц в форме И/ИЛИ-дерева; участники игры: "игрок" и "противник".<br></div>
</div>
<h3 align="center">
<a name="TOC_id3448684"></a>13.3. Базовые процедуры поиска в И/ИЛИ-графах<br></h3>
<div>   В этом разделе нас будет интересовать <i>какое-нибудь</i> решение задачи независимо от его стоимости, поэтому проигнорируем пока стоимости связей или вершин И/ИЛИ-графа. Простейший способ организовать поиск в И/ИЛИ-графах средствами Пролога — это использовать переборный механизм, заложенный в самой пролог-системе. Оказывается, что это очень просто сделать, потому что процедурный смысл Пролога это и есть не что иное, как поиск в И/ИЛИ-графе. Например, И/ИЛИ-граф рис. 13.4 (без учета стоимостей дуг) можно описать при помощи следующих предложений:<br>   а :- b.    % а - ИЛИ-вершина с двумя преемниками<br>   а :- с.    % b и  с<br>   b :- d, e. % b - И-вершина с двумя преемниками d и e<br>   с :- h.<br>   с :- f, g.<br>   f :- h, i.<br>   d. g. h.   % d, g и h - целевые вершины<br>   Для того, чтобы узнать, имеет ли эта задача решение, нужно просто спросить:<br>   ?- а.<br>   Получив этот вопрос, пролог-система произведет поиск в глубину в дереве рис. 13.4 и после того, как пройдет через все вершины подграфа, соответствующего решающему дереву рис. 13.4(b), ответит "да".<br>   Преимущество такого метода программирования И/ИЛИ-поиска состоит в его простоте. Но есть и недостатки:<br>   • Мы получаем ответ "да" или "нет", но не получаем решающее дерево. Можно было бы восстановить решающее дерево при помощи трассировки программы, но такой способ неудобен, да его и недостаточно, если мы хотим иметь возможность явно обратиться к решающему дереву как к объекту программы.<br>   • В эту программу трудно вносить добавления, связанные с обработкой стоимостей.<br>   • Если наш И/ИЛИ-граф — это граф общего вида, содержащий циклы, то пролог-система, следуя стратегии в глубину, может войти в бесконечный рекурсивный цикл.<br>   Попробуем постепенно исправить эти недостатки. Сначала определим нашу собственную процедуру поиска в глубину для И/ИЛИ-графов.<br>   Прежде всего мы должны изменить представление И/ИЛИ-графов. С этой целью введём бинарное отношение, изображаемое инфиксным оператором '---&gt;'. Например, вершина <i>а</i> с двумя ИЛИ-преемниками будет представлена предложением<br>   а ---&gt; или : [b, с].<br>   Оба символа '---&gt;' и ':' — инфиксные операторы, которые можно определить как<br>   :- op( 600, xfx, ---&gt;).<br>   :- op( 500, xfx, :).<br>   Весь И/ИЛИ-граф рис. 13.4 теперь можно задать при помощи множества предложений<br>   а ---&gt; или : [b, с].<br>   b ---&gt; и : [d, e].<br>   с ---&gt; и : [f, g].<br>   e ---&gt; или : [h].<br>   f ---&gt; или : [h, i].<br>   цель( d). цель( g). цель( h).<br>   Процедуру поиска в глубину в И/ИЛИ-графах можно построить, базируясь на следующих принципах:<br>   Для того, чтобы решить задачу вершины В, необходимо придерживаться приведенных ниже правил:<br>   (1) Если  В — целевая вершина, то задача решается тривиальным образом.<br>   (2) Если вершина В имеет ИЛИ-преемников, то нужно решить одну из соответствующих задач-преемников (пробовать решать их одну за другой, пока не будет найдена задача, имеющая решение).<br>   (3) Если вершина В имеет И-преемников, то нужно решить все соответствующие задачи (пробовать решать их одну за другой, пока они не будут решены все).<br>   Если применение этих правил не приводит к решению, считать, что задача не может быть решена.<br>   Соответствующая программа выглядит так:<br>   решить( Верш) :-<br>    цель( Верш).<br>   решить( Верш) :-<br>    Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина<br>    принадлежит( Верш1, Вершины),<br>     % Выбор преемника  Верш1  вершины  Верш<br>    решить( Bepш1).<br>   решить( Верш) :-<br>    Верш ---&gt; и : Вершины,   % Верш - И-вершина<br>    решитьвсе( Вершины).<br>     % Решить все задачи-преемники<br>
		 <br>   решитьвсе( []).<br>   решитьвсе( [Верш | Вершины]) :-<br>    решить( Верш),<br>    решитьвсе( Вершины).<br>   Здесь принадлежит — обычное отношение принадлежности к списку.<br>   Эта программа все еще имеет недостатки:<br>   • она не порождает решающее дерево, и<br>   • она может зацикливаться, если И/ИЛИ-граф имеет соответствующую структуру (циклы).<br>   Программу нетрудно изменить с тем, чтобы она порождала решающее дерево. Необходимо так подправить отношение решить, чтобы оно имело два аргумента:<br>   решить( Верш, РешДер).<br>   Решающее дерево представим следующим образом. Мы имеем три случая:<br>   (1) Если Верш — целевая вершина, то соответствующее решающее дерево и есть сама эта вершина.<br>   (2) Если Верш — ИЛИ-вершина, то решающее дерево имеет вид<br>   Верш ---&gt; Поддерево<br>   где Поддерево — это решающее дерево для одного из преемников вершины Верш.<br>   (3) Если Верш — И-вершина, то решающее дерево имеет вид<br>   Верш ---&gt; и : Поддеревья<br>   где Поддеревья — список решающих деревьев для всех преемников вершины Верш.<br>
		 <br>   % Поиск в глубину для И/ИЛИ-графов<br>   % Процедура решить( Верш, РешДер) находит решающее дерево для<br>   % некоторой вершины в И / ИЛИ-графе<br>   решить( Верш, Верш) :-    % Решающее дерево для целевой<br>    цель( Верш).             % вершины - это сама вершина<br>   решить( Верш, Верш ---&gt; Дер) :-<br>    Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина<br>    принадлежит( Верш1, Вершины),<br>     % Выбор преемника  Верш1  вершины  Верш<br>    решить( Bepш1, Дер).<br>   решить( Верш, Верш ---&gt; и : Деревья) :-<br>    Верш ---&gt; и : Вершины,   % Верш - И-вершина<br>    решитьвсе( Вершины, Деревья).<br>     % Решить все задачи-преемники<br>
		 <br>   решитьвсе( [], []).<br>   решитьвсе( [Верш | Вершины], [Дер | Деревья]) :-<br>    решить( Верш, Дер),<br>    решитьвсе( Вершины, Деревья).<br>
		 <br>   отобр( Дер) :-            % Отобразить решающее дерево<br>    отобр( Дер, 0), !.       % с отступом 0<br>   отобр( Верш ---&gt; Дер, H) :-<br>     % Отобразить решающее дерево с отступом H<br>    write( Верш), write( '---&gt;'),<br>    H1 is H + 7,<br>    отобр( Дер, H1), !.<br>   отобр( и : [Д], H) :-<br>     % Отобразить И-список решающих деревьев<br>    отобр( Д, H).<br>   отобр( и : [Д | ДД], H) :-<br>     % Отобразить И-список решающих деревьев<br>    отобр( Д, H),<br>    tab( H),<br>    отобр( и : ДД, H), !.<br>   отобр( Верш, H) :-<br>    write( Верш), nl.<br>   <b>Рис. 13.8.</b> Поиск в глубину для И/ИЛИ-графов. Эта программа может зацикливаться. Процедура решить находит решающее дерево, а процедура отобр показывает его пользователю. В процедуре отобр предполагается, что на вывод вершины тратится только один символ.<br>
		 <br>   Например, при поиске в И/ИЛИ-графе рис. 13.4 первое найденное решение задачи, соответствующей самой верхней вершине <i>а</i>, будет иметь следующее представление:<br>   а ---&gt; b ---&gt; и : [d, c ---&gt; h]<br>   Три формы представления решающего дерева соответствуют трем предложениям отношения решить. Поэтому все, что нам нужно сделать для изменения нашей исходной программы решить, — это подправить каждое из этих трех предложений, просто добавив в каждое из них решающее дерево в качестве второго аргумента. Измененная программа показана на рис. 13.8. В нее также введена дополнительная процедура отобр для отображения решающих деревьев в текстовой форме. Например, решающее дерево рис. 13.4 будет отпечатано процедурой отобр в следующем виде:<br>   а ---&gt; b ---&gt; d<br>                 e ---&gt; h<br>   Программа рис. 13.8 все еще сохраняет склонность к вхождению в бесконечные циклы. Один из простых способов избежать бесконечных циклов — это следить за текущей глубиной поиска и не давать программе заходить за пределы некоторого ограничения по глубине. Это можно сделать, введя в отношение решить еще один аргумент:<br>   решить( Верш, РешДер, МаксГлуб)<br>   Как и раньше, вершиной Верш представлена решаемая задача, а РешДер — это решение этой задачи, имеющее глубину, не превосходящую МаксГлуб. МаксГлуб — это допустимая глубина поиска в графе. Если МаксГлуб = 0, то двигаться дальше запрещено, если же МаксГлуб &gt; 0, то поиск распространяется на преемников вершины Верш, причем для них устанавливается меньший предел по глубине, равный МаксГлуб-1. Это дополнение легко ввести в программу рис. 13.8. Например, второе предложение процедуры решить примет вид:<br>   решить( Верш, Верш ---&gt; Дер, МаксГлуб) :-<br>    МаксГлуб &gt; 0,<br>    Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина<br>    принадлежит ( Верш1, Вершины),<br>     % Выбор преемника  Верш1  вершины  Верш<br>    Глуб1 is МаксГлуб - 1,   % Новый предел по глубине<br>    решить( Bepш1, Дер, Глуб1).<br>     % Решить задачу-преемник с меньшим ограничением<br>   Нашу процедуру поиска в глубину с ограничением можно также использовать для имитации поиска в ширину. Идея состоит в следующем: многократно повторять поиск в глубину каждый раз все с большим значением ограничения до тех пор, пока решение не будет найдено, То есть попробовать решить задачу с ограничением по глубине, равным 0, затем — с ограничением 1, затем — 2 и т.д. Получаем следующую программу:<br>   имитация_в_ширину( Верш, РешДер) :-<br>    проба_в_глубину( Верш, РешДер, 0).<br>     % Проба поиска с возрастающим ограничением, начиная с 0<br>
		 <br>   проба_в_глубину( Верш, РешДер, Глуб) :-<br>    решить( Верш, РешДер, Глуб);<br>    Глуб1 is Глуб + 1, % Новый предел по глубине<br>    проба_в_глубину( Верш, РешДер, Глуб1).<br>     % Попытка с новым ограничением<br>   Недостатком имитации поиска в ширину является то, что при каждом увеличении предела по глубине программа повторно просматривает верхнюю область пространства поиска.<br><h5>Упражнения</h5>   <b>13.1.</b> Закончите составление программы поиска в глубину (с ограничением) для И/ИЛИ-графов, намеченную в настоящем разделе.<br>   <b>13.2.</b> Определите на Прологе И/ИЛИ-пространство для задачи "ханойская башня" и примените к нему процедуры поиска настоящего раздела.<br>   <b>13.3.</b> Рассмотрите какую-нибудь простую детерминированную игру двух лиц с полной информацией и дайте определение ее И/ИЛИ-представления. Используйте программу поиска в И/ИЛИ-графах для построения выигрывающих стратегий в форме И/ИЛИ-деревьев.<br></div>
<h3 align="center">
<a name="TOC_id3449407"></a>13.4. Поиск с предпочтением в И/ИЛИ-графах <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3449413"></a>13.4.1. Эвристические оценки и алгоритм поиска<br></h4>
<div>   Базовые процедуры поиска предыдущего раздела производят систематический и полный просмотр И/ИЛИ-дерева, не руководствуясь при этом какими-либо эвристиками. Для сложных задач подобные процедуры весьма не эффективны из-за большой комбинаторной сложности пространства поиска. В связи с этим возникает необходимость в эвристическом управлении поиском, направленном на уменьшение комбинаторной сложности за счет исключения бесполезных альтернатив. Управление эвристиками, излагаемое в настоящем разделе, будет основано на численных эвристических оценках "трудности" задач, входящих в состав И/ИЛИ-графа. Программу, которую мы составим, можно рассматривать как обобщение программы поиска с предпочтением в пространстве состояний гл. 12.<br>   Начнем с того, что сформулируем критерий оптимальности, основанный на стоимостях дуг И/ИЛИ-графа. Во-первых, мы расширим наше представление И/ИЛИ-графов, дополнив его стоимостями дуг. Например, И/ИЛИ-граф рис. 13.4 можно представить следующими предложениями:<br>   а ---&gt; или : [b/1, с/3].<br>   b ---&gt; и : [d/1, e/1].<br>   с ---&gt; и : [f/2, g/1].<br>   e ---&gt; или : [h/6].<br>   f ---&gt; или : [h/2, i/3].<br>
		 <br>   цель( d). цель( g). цель( h).<br>   Стоимость решающего дерева мы определим как сумму стоимостей его дуг. Цель оптимизации - найти решающее дерево минимальной стоимости. Как и раньше, иллюстрацией служит рис. 13.4.<br>   Будет полезным определить <i>стоимость вершины</i> И/ИЛИ-графа как стоимость оптимального решающего дерева для этой вершины. Стоимость вершины, определенная таким образом, соответствует "трудности" соответствующей задачи.<br>   Мы будем предполагать, что стоимости вершин И/ИЛИ-графа можно оценить (не зная соответствующих решающих деревьев) при помощи эвристической функции <i>h</i>. Эти оценки будут использоваться для управления поиском. Наша программа поиска начнет свою работу со стартовой вершины и, распространяя поиск из уже просмотренных вершин на их преемников, будет постепенно наращивать дерево поиска. Этот процесс будет строить дерево даже в том случае, когда сам И/ИЛИ-граф не является деревом; при этом граф будет разворачиваться в дерево за счет дублирования своих отдельных частей.<br>   Для продолжения поиска будет всегда выбираться "наиболее перспективное" решающее дерево-кандидат. Каким же образом используется функция <i>h</i> для оценки степени перспективности решающего дерева-кандидата или, точнее, вершины-кандидата — корня этого дерева?<br><div align="center"><img border="1" src="_95.png"></div>   <b>Рис. 13.9.</b> Получение оценки <i>H</i> трудности задач И/ИЛИ-графа.<br>   Обозначим через <i>H(В)</i> оценку трудности вершины <i>В</i>. Для самой верхней вершины текущего дерева поиска <i>H(В)</i> просто совпадает с <i>h(В)</i>. С другой стороны, для оценки внутренней вершины дерева поиска нам не обязательно использовать непосредственно значение <i>h</i>, поскольку у нас есть некоторая дополнительная информация об этой вершине: мы знаем ее преемников. Следовательно, как показано на рис. 13.9, мы можем приближенно оценить трудность внутренней ИЛИ-вершины как<br>   <i> <div align="center"><img border="1" src="img_01.png_0"></div></i><br>   где <i>с(В, В<sub>i</sub>)</i> — стоимость дуги, ведущей из <i>В</i> в <i>В<sub>i</sub></i>. Взятие минимума в этой формуле оправдано тем обстоятельством, что для того, чтобы решить задачу <i>В</i>, нам нужно решить только одну из ее задач-преемников. Трудность И-вершины <i>В</i> можно приближенно оценить так:<br>    <img border="0" src="img_11.png"><br>   Будем называть <i>H</i>-оценку внутренней вершины "возвращенной" (backed-up) оценкой.<br>   Более практичной с точки зрения использования в нашей программе поиска является другая величина <i>F</i>, которую можно определить в терминах <i>H</i> следующим образом. Пусть <i>В1</i> — вершина-предшественник вершины <i>В</i> в дереве поиска, причем стоимость дуги, ведущей из <i>В1</i> в <i>В</i>, равна <i>с(В1, В)</i>, тогда положим<br>   <i>F( B) = с( В1, В) + H( В)</i><br>   Пусть <i>В1</i> — родительская вершина вершины <i>В</i>, а <i>В</i><sub>1</sub>, <i>В</i><sub>2</sub>, … — ее дочерние вершины, тогда, в соответствии с определениями <i>F</i> и <i>H</i>, имеем<br>    <img border="0" src="img_21.png">,  если <i>В</i> — ИЛИ-вершина<br>    <img border="0" src="img_3.png">,  если <i>В</i> — И-вершина<br>   Хотя стартовая вершина <i>А</i> и не имеет предшественника, будем считать, что стоимость ведущей в нее (виртуальной) дуги равна 0. Если положить <i>h</i> равным 0 для всех вершин И/ИЛИ-дерева, то для любого найденного оптимального решающего дерева окажется, что его стоимость, т.е. сумма стоимостей его дуг, в точности равна  <i>F(A)</i>.<br>   На любой стадии поиска каждый преемник ИЛИ-вершины соответствует некоторому альтернативному решающему дереву-кандидату. Процесс поиска всегда принимает решение продолжать просмотр того дерева-кандидата, для которого <i>F</i>-оценка минимальна. Вернемся еще раз к рис. 13.4 и посмотрим, как будет вести себя процесс, поиска на примере И/ИЛИ-графа, изображенного на этом рисунке. В начале дерево поиска состоит всего из одной вершины — стартовой вершины  <i>а</i>, далее дерево постепенно "растет" до тех пор, пока не будет найдено решающее дерево. На рис. 13.10, показан ряд "мгновенных снимков", сделанных в процессе роста дерева поиска. Для простоты мы предположим, что <i>h =</i> 0 для всех вершин. Числа, приписанные вершинам на рис. 13.10 — это их <i>F</i>-оценки (разумеется, по мере накопления информации в процессе поиска они изменяются). Ниже даются некоторые пояснительные замечания к рис. 13.10.<br>   После распространения поиска из первоначального дерева (снимок А) получается дерево В. Вершина <i>а</i> — это ИЛИ-вершина, поэтому мы имеем два решающих дерева-кандидата: <i>b</i> и <i>с</i>. Поскольку <i>F( b) = 1 &lt; 3 = F( c)</i>, для продолжения поиска выбирается альтернатива <i>b</i>. Насколько далеко может зайти процесс роста поддерева <i>b</i>? Этот процесс может продолжаться до тех пор, пока не произойдет одно из двух событий:<br>   (1) <i>F</i>-оценка вершины <i>b</i> станет больше, чем  <i>F</i>-оценка ее конкурента <i>с</i>, или<br>   (2) обнаружится, что найдено решающее дерево.<br>   В связи с этим, начиная просмотр поддерева-кандидата <i>b</i>, мы устанавливаем верхнюю границу для <i>F( b)</i>: <i>F( b) </i>&#8804;<i> 3 = F( c)</i>. Сначала порождаются преемники <i>d</i> и <i>e</i> вершины <i>b</i> (снимок С),после чего <i>F</i>-оценка <i>b</i> возрастает до 3. Так как это значение не превосходит верхнюю границу, рост дерева-кандидата с корнем в <i>b</i> продолжается. Вершина <i>d</i> оказывается целевой вершиной, а после распространения поиска из вершины <i>e</i> на один шаг получаем дерево, показанное на снимке D. В этот момент выясняется, что <i>F( b) = 9 &gt; 3</i>,  и рост дерева <i>b </i>прекращается. В результате процесс поиска не успевает "осознать", что <i>h</i> — это тоже целевая вершина и что порождено решающее дерево. Вместо этого происходит переключение активности на конкурирующую альтернативу  <i>с</i>.  Поскольку в этот момент <i>F( b) =</i> 9, устанавливается верхняя граница для  <i>F( c)</i>,  равная 9. Дерево-кандидат с корнем  <i>с</i>   наращивается (с учетом установленного ограничения) до тех пор, пока не возникает ситуация, показанная на снимке  E.  Теперь процесс поиска обнаруживает, что найдено решающее дерево (включающее в себя целевые вершины <i>h</i> и <i>g</i>), на чем поиск заканчивается. Заметьте, что в качестве результата процесс поиска выдает наиболее дешевое из двух возможных решающих деревьев, а именно решающее дерево рис. 13.4(с).<br><div align="center"><img border="1" src="_98.png"></div>   <b>Рис. 13.10.</b> Трассировка процесса поиска с предпочтением в И/ИЛИ-графе (<i>h =</i> 0) при решении задачи рис. 13.4. <br></div>
<h4 align="center">
<a name="TOC_id3449918"></a>13.4.2. Программа поиска<br></h4>
<div>   Программа, в которой реализованы идеи предыдущего раздела, показана на рис. 13.12. Прежде, чем мы перейдем к объяснению отдельных деталей этой программы, давайте рассмотрим тот способ представления дерева поиска, который в ней используется.<br>   Существует несколько случаев, как показано на рис. 13.11. Различные формы представления поискового дерева возникают как комбинации следующих возможных вариантов, относящихся к размеру дерева и к его "решающему статусу".<br>   • Размер:<br>    (1) дерево состоит из одной вершины (листа) или<br>    (2) оно имеет корень и (непустые) поддеревья.<br>   • Решающий статус:<br>    (1) обнаружено, что дерево соответствует решению задачи (т.е. является решающим деревом) или<br>    (2) оно все еще решающее дерево-<i>кандидат</i>.<br><div align="center"><img border="1" src="_991.png"></div>
		 <br><div align="center"><img border="1" src="_992.jpg"></div>   <b>Рис. 13.11.</b> Представление дерева поиска.<br>   Основной функтор, используемый для представления дерева, указывает, какая из комбинаций этих воз-можностей имеется в виду. Это может быть одна из следующих комбинаций:<br>   лист  решлист  дер  решдер<br>   Далее, в представление дерева входят все или некоторые из следующих объектов:<br>   • корневая вершина дерева,<br>   • <i>F</i>-оценка дерева,<br>   • стоимость С дуги И/ИЛИ-графа, ведущей в корень дерева,<br>   • список поддеревьев,<br>   • отношение (И или ИЛИ) между поддеревьями.<br>   Список поддеревьев всегда упорядочен по возрастанию <i>F</i>-оценок. Поддеревья, являющиеся решающими деревьями, помещаются в конец списка.<br>   Обратимся теперь к программе рис. 13.12. Отношение самого высокого уровня — это<br>   и_или( Верш, РешДер)<br>   где Верш — стартовая вершина. Программа строит решающее дерево (если таковое существует), рассчитывая на то, что оно окажется оптимальным решением. Будет ли это решение в действительности самым дешевым, зависит от той функции <i>h</i>, которую использует алгоритм. Существует теорема, в которой говорится о том, как оптимальность решения зависит от <i>h</i>. Эта теорема аналогична теореме о допустимости алгоритма поиска с предпочтением в пространстве состояний (гл. 12). Обозначим через <i>С( В)</i>  стоимость оптимального решающего дерева для вершины <i>В</i>. Если для каждой вершины <i>В</i> И/ИЛИ-графа эвристическая оценка  <i>h(B)</i>&#8804;<i>C(B)</i>, то гарантируется, что процедура и_или найдет оптимальное решение. Если же <i>h</i> не удовлетворяет этому условию, то найденное решение может оказаться субоптимальным. Существует тривиальная эвристическая функция, удовлетворяющая условию оптимальности, а именно <i>h =</i> 0 для всех вершин. Ее недостатком является отсутствие эвристической силы.<br>   Основную роль в программе рис. 13.12 играет отношение<br>   расширить( Дер, Предел, Дер1, ЕстьРеш)<br>   Дер и Предел — его "входные" аргументы, а Дер1 и ЕстьРеш — "выходные". Аргументы имеют следующий смысл:<br>   Дер — дерево поиска, подлежащее расширению.<br>   Предел — предельное значение <i>F</i>-оценки, при котором еще разрешено наращивать дерево Дер.<br>   ЕстьРеш — индикатор, значения которого указывают на то, какой из следующих трех случаев имеет место:<br>   (1) ЕстьРеш = да: Дер можно "нарастить" (с учетом ограничения Предел) таким образом, чтобы образовалось решающее дерево Дер1.<br>   (2) ЕстьРеш = нет: дерево Дер можно расширить до состояния Дер1, для которого <i>F</i>-оценка превосходит Предел, но прежде чем <i>F</i>-оценка превзошла Предел, решающее дерево не было обнаружено.<br>   (3) ЕстьРеш = никогда: Дер не содержит решения.<br>   В зависимости от случая Дер1 — это либо решающее дерево, либо Дер, расширенное до момента перехода через Предел; если ЕстьРеш = никогда, то переменная Дер1 неинициализирована.<br>   Процедура<br>   расширспис( Деревья, Предел, Деревья1, ЕстьРеш)<br>   аналогична процедуре расширить. Так же, как и в процедуре расширить, Предел задает ограничение на рост дерева, а ЕстьРеш — это индикатор, указывающий, каков результат расширения ("да", "нет" или "никогда"). Первый аргумент — это, на этот раз, список деревьев (И-список или ИЛИ-список):<br>   Деревья = или:[Д1, Д2, ...] или<br>   Деревья = и : [Д1, Д2, ...]<br>   Процедура расширспис выбирает из списка Деревья наиболее перспективное дерево (исходя из <i>F</i>-оценок). Так как деревья в списке упорядочены, таким деревом является первый элемент списка. Наиболее перспективное дерево подвергается расширению с новым ограничением Предел1. Значение Предел1 зависит от Предел, а также от других деревьев списка. Если Деревья — это ИЛИ-список, то Предел1 устанавливается как наименьшая из двух величин: Предел и <i>F</i>-оценка следующего по "качеству" дерева из списка Деревья. Если Деревья — это И-дерево, то Предел1 устанавливается равным Предел минус сумма <i>F</i>-оценок всех остальных деревьев из списка. Значение переменной Деревья1 зависит от случая, задаваемого индикатором ЕстьРеш. Если ЕстьРеш = нет, то Деревья1 — это то же самое, что и список Деревья, причем наиболее перспективное дерево расширено с учетом ограничения Предел1. Если ЕстьРеш = да, то Деревья1 — это решение для всего списка Деревья (найденное без выхода за границы значения Предел). Если ЕстьРеш = никогда, то переменная Деревья1 неинициализирована.<br>   Процедура продолжить, вызываемая после расширения списка деревьев, решает, что делать дальше, в зависимости от результата срабатывания процедуры расширить. Эта процедура либо строит решающее дерево, либо уточняет дерево поиска и продолжает процесс его наращивания, либо выдает сообщение "никогда" в случае, когда было обнаружено, что список деревьев не содержит решения.<br>
		 <br>   /* ПРОГРАММА И/ИЛИ-ПОИСКА С ПРЕДПОЧТЕНИЕМ<br>   Эта программа порождает только одно решение. Гарантируется, что это решение самое дешевое при условии, что используемая эвристическая функция является нижней гранью реальной стоимости решающих деревьев.<br>   Дерево поиска имеет одну из следующих форм:<br>   дер( Верш, F, С, Поддеревья) дерево-кандидат<br>   лист( Верш, F, C)            лист дерева поиска<br>   решдер( Верш, F, Поддеревья) решающее дерево<br>   решлист( Верш, F)            лист решающего дерева<br>   С - стоимость дуги, ведущей в Верш<br>   F = С + H, где H - эвристическая оценка оптимального решающего дерева с корнем Верш<br>   Список Поддеревья упорядочен таким образом, что<br>   (1) решающие поддеревья находятся в конце списка;<br>   (2) остальные поддеревья расположены в порядке возрастания F-оценок<br>   */<br>
		 <br>   :- op( 500, xfx, :).<br>   :- op( 600, xfx, ---&gt;).<br>
		 <br>   и_или( Верш, РешДер) :-<br>    расширить( лист( Верш, 0, 0), 9999, РешДер, да).<br>     % Предполагается, что 9999  &gt;  любой F-оценки<br>
		 <br>   % Процедура расширить( Дер, Предел, НовДер, ЕстьРеш)<br>   % расширяет Дер в пределах ограничения Предел<br>   % и порождает НовДер с "решающим статусом" ЕстьРеш.<br>
		 <br>   % Случай 1:  выход за ограничение<br>   расширить( Дер, Предел, Дер, нет) :-<br>    f( Дер, F),  F &gt; Предел, !. % Выход за ограничение<br>
		 <br>   % В остальных случаях F &#8804; Предел<br>   % Случай 2:  встретилась целевая вершина<br>   расширить( лист( Верш, F, С), _, решлист( Верш, F), да) : -<br>    цель( Верш), !.<br>
		 <br>   % Случай 3:  порождение преемников листа<br>   расширить( лист( Верш, F,C), Предел, НовДер, ЕстьРеш) :-<br>    расшлист( Верш, С, Дер1), !,<br>    расширить( Дер1, Предел, НовДер, ЕстьРеш);<br>    ЕстьРеш = никогда, !.       % Нет преемников, тупик<br>
		 <br>   % Случай 4:  расширить дерево<br>   расширить( дер( Верш, F, С, Поддеревья),<br>    Предел, НовДер, ЕстьРеш) :-<br>    Предел1 is Предел - С,<br>    расширспис( Поддеревья, Предел1, НовПоддер, ЕстьРеш1),<br>    продолжить( ЕстьРеш1, Верш, С, НовПоддер, Предел,<br>     НовДер, ЕстьРеш).<br>
		 <br>   % расширспис( Деревья, Предел, Деревья1, ЕстьРеш)<br>   % расширяет деревья из заданного списка с учетом<br>   % ограничения Предел и выдает новый список Деревья1<br>   % с "решающим статусом" ЕстьРеш.<br>   расширспис( Деревья, Предел, Деревья1, ЕстьРеш) :-<br>    выбор( Деревья, Дер, ОстДер, Предел, Предел1),<br>    расширить( Дер, Предел1, НовДер, ЕстьРеш1),<br>    собрать( ОстДер, НовДер, ЕстьРеш1, Деревья1, ЕстьРеш).<br>
		 <br>   % "продолжить" решает, что делать после расширения<br>   % списка деревьев<br>   продолжить( да, Верш, С, Поддеревья, _,<br>    решдер( Верш, F, Поддеревья), да): -<br>    оценка( Поддеревья, H), F is С + H, !.<br>   продолжить( никогда, _, _, _, _, _, никогда) :- !.<br>   продолжить( нет, Верш, С, Поддеревья, Предел,<br>    НовДер, ЕстьРеш) :-<br>    оценка( Поддеревья, H), F is С + H, !,<br>    расширить( дер( Верш, F, С, Поддеревья), Предел,<br>     НовДер, ЕстьРеш).<br>
		 <br>   % "собрать" соединяет результат расширения дерева со списком деревьев<br>   собрать( или : _, Дер, да, Дер, да):- !. % Есть решение ИЛИ-списка<br>   собрать( или : ДД, Дер, нет, или : НовДД, нет) :-<br>    встав( Дер, ДД, НовДД), !.  % Нет решения ИЛИ-списка<br>   собрать( или : [], _, никогда, _, никогда) :- !.<br>     % Больше нет кандидатов<br>   собрать( или:ДД, _, никогда, или:ДД, нет) :- !.<br>     % Есть еще кандидаты<br>   собрать( и : ДД, Дер, да, и : [Дер Э ДД], да ) :-<br>    всереш( ДД), !.             % Есть решение И-списка<br>   собрать( и : _, _, никогда, _, никогда) :- !.<br>     % Нет решения И-списка<br>   собрать( и : ДД, Дер, ДаНет, и : НовДД, нет) :-<br>    встав( Дер, ДД, НовДД), !.  % Пока нет решения И-списка<br>
		 <br>   % "расшлист" формирует дерево из вершины и ее преемников<br>   расшлист( Верш, С, дер( Верш, F, С, Оп : Поддеревья)) :-<br>    Верш---&gt; Оп : Преемники,<br>    оценить( Преемники, Поддеревья),<br>    оценка( Оп : Поддеревья, H), F is С + H.<br>    оценить( [], []).<br>
		 <br>   оценить( [Верш/С | ВершиныСтоим], Деревья) :-<br>    h( Верш, H), F is С + H,<br>    оценить( ВершиныСтоим, Деревья1),<br>    встав( лист( Верш, F, С), Деревья1, Деревья).<br>
		 <br>   % "всереш" проверяет, все ли деревья в списке "решены"<br>   всереш([]).<br>   всереш( [Дер | Деревья] ) :-<br>    реш( Дер),<br>    всереш( Деревья).<br>
		 <br>   реш( решдер( _, _, _ ) ).<br>   реш( решлист( _ , _) ).<br>
		 <br>   f( Дер, F) :-              % Извлечь F-оценку дерева<br>    arg( 2, Дер, F), !.       % F - это 2-й аргумент Дер<br>
		 <br>   % встав( Дер, ДД, НовДД) вставляет Дер в список<br>   % деревьев ДД; результат - НовДД<br>   встав( Д, [], [Д] ) :- !.<br>   встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-<br>    реш( Д1), !.<br>   встав( Д, [Д1 | ДД], [Д1 | ДД1] ) :-<br>    реш( Д),<br>    встав( Д, ДД, ДД1), !.<br>   встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-<br>    f( Д, F), f( Д1, F1), F=&lt; F1, !.<br>   встав( Д, [Д1 | ДД], [ Д1 | ДД1] ) :-<br>    встав( Д, ДД, ДД1).<br>
		 <br>   % "оценка" находит "возвращенную" F-оценку И/ИЛИ-списка деревьев<br>   оценка( или :[Дер | _ ], F) :-<br>    % Первое дерево ИЛИ-списка - наилучшее<br>    f( Дер, F), !.<br>   оценка( и :[], 0) :- !.<br>   оценка( и : [Дер1 | ДД], F) :-<br>    f( Дер1, F1),<br>    оценка( и : ДД, F2),<br>    F is F1 + F2, !.<br>   оценка( Дер, F) :-<br>    f( Дер, F).<br>
		 <br>   % Отношение выбор( Деревья, Лучшее, Остальные, Предел, Предел1):<br>   % Остальные - И/ИЛИ-список Деревья без его "лучшего" дерева<br>   % Лучшее; Предел - ограничение для Списка Деревья, Предел1 -<br>   % ограничение для дерева Лучшее<br>   выбор( Оп : [Дер], Дер, Оп : [], Предел, Предел) :- !.<br>     % Только один кандидат<br>   выбор( Оп : [Дер | ДД], Дер, Оп : ДД, Предел, Предел1) :-<br>    оценка( Оп : ДД, F),<br>    ( Оп = или, !, мин( Предел, F, Предел1);<br>      Оп = и, Предел1 is Предел - F).<br>
		 <br>   мин( А, В, А) :- А &lt; В, !.<br>   мин( А, В, В).<br>   <b>Рис. 13.12.</b> Программа поиска с предпочтением в И/ИЛИ-графе.<br>
		 <br>   Еще одна процедура<br>   собрать( ОстДер, НовДер, ЕстьРеш1, НовДеревья, ЕстьРеш)<br>   связывает между собой несколько объектов, с которыми работает расширспис. НовДер — это расширенное дерево, взятое из списка деревьев процедуры расширспис, ОстДер — остальные, не измененные деревья из этого списка, а ЕстьРеш1 указывает на "решающий статус" дерева НовДер. Процедура собрать имеет дело с несколькими случаями в зависимости от значения ЕстьРеш1, а также от того, является ли список деревьев И-списком или ИЛИ-списком. Например, предложение<br>   собрать( или : _, Дер, да, Дер, да).<br>   означает: в случае, когда список деревьев — это ИЛИ-список и при только что проведенном расширении получено решающее дерево, считать, что задача, соответствующая всему списку деревьев, также решена, а ее решающее дерево и есть само дерево Дер. Остальные случаи легко понять из текста процедуры собрать.<br>   Для отображения решающего дерева можно определить процедуру, аналогичную процедуре отобр (рис. 13.8). Оставляем это читателю в качестве упражнения.<br></div>
<h4 align="center">
<a name="TOC_id3451066"></a>13.4.3. Пример отношений, определяющих конкретную задачу: поиск маршрута<br></h4>
<div>   Давайте теперь сформулируем задачу нахождения маршрута как задачу поиска в И/ИЛИ-графе, причем сделаем это таким образом, чтобы наша формулировка могла бы быть непосредственно использована процедурой и_или рис. 13.12. Мы условимся, что карта дорог будет представлена при помощи отношения<br>   связь( Гор1, Гор2, P)<br>   означающего, что между городами Гор1 и Гор2 существует непосредственная связь, а соответствующее расстояние равно P. Далее, мы допустим, что существует отношение<br>   клпункт( Гор1-Гор2, Гор3)<br>   имеющее следующий смысл: для того, чтобы найти маршрут из Гор1 в Гор2, следует рассмотреть пути, проходящие через Гор3 (Гор3 — это "ключевой пункт" между Гор1 и Гор2). Например, на карте рис. 13.1 <i>f</i> и <i>g</i> — это ключевые пункты между <i>а</i> и <i>z</i>:<br>   клпункт( a-z, f).  клпункт( a-z, g).<br>   Мы реализуем следующий принцип построения маршрута:<br>    Для того, чтобы найти маршрут между городами X и Z, необходимо:<br>     (1) если между X и Z имеются ключевые пункты Y1, Y2, …, то найти один из путей:<br>      путь из X в Z через Y1, или<br>      путь из X в Z через Y2, или<br>      …<br>     (2) если между X и Z нет ключевых пунктов, то найти такой соседний с X город Y, что существует маршрут из Y в Z.<br>   Таким образом, мы имеем два вида задач, которые мы будем представлять как<br>   (1) X-Z         найти маршрут из X в Z<br>   (2) X-Z через Y найти маршрут из X в Z, проходящий через Y<br>   Здесь 'через' — это инфиксный оператор более высокого приоритета, чем '-', и более низкого, чем '---&gt;'. Теперь можно определить соответствующий И/ИЛИ-граф явным образом при помощи следующего фрагмента программы:<br>   :- op( 560, xfx, через)<br>
		 <br>   % Правила задачи X-Z, когда между  X  и  Z<br>   % имеются ключевые пункты,<br>   % стоимости всех дуг равны 0<br>   X-Z ---&gt; или : СписокЗадач<br>    :- bagof( ( X-Z через Y)/0, клпункт( X-Z, Y),<br>    СписокЗадач), !.<br>
		 <br>   % Правила для задачи X-Z без ключевых пунктов<br>   X-Z ---&gt; или : СписокЗадач<br>    :- bagof( ( Y-Z)/P, связь( X, Y, P), СписокЗадач).<br>
		 <br>   % Сведение задачи типа "через" к подзадачам,<br>   % связанным отношением И<br>   X-Z через Y---&gt; и : [( X-Y)/0, ( Y-Z)/0].<br>    цель( X-X) % Тривиальная задача: попасть из X в X<br>   Функцию <i>h</i> можно определить, например, как расстояние, которое нужно преодолеть при воздушном сообщении между городами.<br><h5>Упражнение</h5>   <b>13.4.</b> Напишите процедуру<br>   отобр2( РешДер)<br>   для отображения решающего дерева, найденного программой и_или рис. 13.12. Формат отображения пусть будет аналогичен тому, что применялся в процедуре отобр (рис. 13.8), так что процедуру отобр2 можно получить, внеся в отобр изменения, связанные с другим представлением деревьев. Другая полезная модификация — заменить в отобр цель write( Верш) на процедуру, определяемую пользователем<br>   печверш( Верш, H)<br>   которая выведет Верш в удобной для пользователя форме, а также конкретизирует H в соответствии с количеством символов, необходимом для представления Верш в этой форме. В дальнейшем H будет использоваться как величина отступа для поддеревьев.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3451358"></a>Резюме<br></h3>
<div>   • И/ИЛИ-граф — это формальный аппарат для представления задач. Такое представление является наиболее естественным и удобным для задач, которые разбиваются на независимые подзадачи. Примером могут служить игры.<br>   • Вершины И/ИЛИ-графа бывают двух типов: И-вершины и ИЛИ-вершины.<br>   • Конкретная задача определяется стартовой вершиной и целевым условием. Решение задачи представляется решающим деревом.<br>   • Для моделирования оптимизационных задач в И/ИЛИ-граф можно ввести стоимости дуг и вершин.<br>   • Процесс решения задачи, представленной И/ИЛИ-графом, включает в себя поиск в графе. Стратегия поиска в глубину предусматривает систематический просмотр графа и легко программируется. Однако эта стратегия может привести к неэффективности из-за комбинаторного взрыва.<br>   • Для оценки трудности задач можно применить эвристики, а для управления поиском — принцип эвристического поиска с предпочтением. Эта стратегия более трудна в реализации.<br>   • В данной главе были разработаны прологовские программы для поиска в глубину и поиска с предпочтением в И/ИЛИ-графах.<br>   • Были введены следующие понятия: <br>     И/ИЛИ-графы<br>     И-дуги, ИЛИ-дуги<br>     И-вершины, ИЛИ-вершины<br>     решающий путь, решающее дерево<br>     стоимость дуг и вершин<br>     эвристические оценки в И/ИЛИ-графах<br>     "возвращенные" оценки<br>     поиск в глубину в И/ИЛИ-графах<br>     поиск с предпочтением в И/ИЛИ-графах<br><h5>Литература</h5>   И/ИЛИ-графы и связанные с ними алгоритмы поиска являются частью классических механизмов искусственного интеллекта для решения задач и реализации машинных игр. Ранним примером прикладной задачи, использующей эти методы, может служить программа символического интегрирования (Slagle 1963). И/ИЛИ-поиск используется в самой пролог-системе. Общее описание И/ИЛИ-графов и алгоритма можно найти в учебниках по искусственному интеллекту (Nilsson 1971; Nilsson 1980). Наша программа поиска с предпочтением — это один из вариантов алгоритма, известного под названием АО*. Формальные свойства АО*-алгоритма (включая его допустимость) изучались несколькими авторами. Подробный обзор полученных результатов можно найти в книге Pearl (1984).<br>
		 <br>   Nilsson N.J. (1971). <i>Problem-Solving Methods in Artificial Intelligence</i>. McGraw-Hill.<br>   Nilsson N.J. (1980). <i>Principles of Artificial Intelligence</i>. Tioga; also Springer-Verlag.<br>   Pearl J. (1984). <i>Heuristics: Intelligent Search Strategies for Computer Problem Solving</i>. Addison-Wesley.<br>   Slagle J.R. (1963). A heuristic program that solves symbolic integration problems in freshman calculus. In: <i>Computers and Thought</i> (E. Feigenbaum, J. Feldman, eds.). McGraw-Hill. <br></div>
</div>
<h2 align="center">
<a name="TOC_id3451473"></a>Глава 14<br>Экспертные системы<br></h2>
<div>
<div>   Экспертная система - это программа, которая ведет себя подобно эксперту в некоторой проблемной области. Она должна иметь способность к <i>объяснению</i> своих решений и тех рассуждений, на основе которых эти решения были приняты. Часто от экспертной системы требуют, чтобы она могла работать с неточной и неполной информацией.<br>   Для того, чтобы построить экспертную систему, мы должны создать механизмы, обеспечивающие выполнение следующих функций: решение задач, взаимодействие с пользователем и работа в условиях неопределенности. В данной главе мы разработаем и peaлизуем основные идеи построения экспертных систем.<br></div>
<h3 align="center">
<a name="TOC_id3451500"></a>14.1. Функции, выполняемые экспертной системой<br></h3>
<div>   <i>Экспертная система</i> — это программа, которая ведет себя подобно эксперту в некоторой, обычно узкой, прикладной области. Типичные применения экспертных систем включают в себя такие задачи, как медицинская диагностика, локализация неисправностей в оборудовании и интерпретация результатов измерений. Экспертные системы должны решать задачи, требующие для своего решения экспертных знаний в некоторой конкретной области. В той или иной форме экспертные системы должны обладать этими знаниями. Поэтому их также называют <i>системами</i>,<i> основанными на знаниях</i>. Однако не всякую систему, основанную на знаниях, можно рассматривать как экспертную. Экспертная система должна также уметь каким-то образом <i>объяснять</i> свое поведение и свои решения пользователю, так же, как это делает эксперт-человек. Это особенно необходимо в областях, для которых характерна неопределенность, неточность информации (например, в медицинской диагностике). В этих случаях способность к объяснению нужна для того, чтобы повысить степень доверия пользователя к советам системы, а также для того, чтобы дать возможность пользователю обнаружить возможный дефект в рассуждениях системы. В связи с этим в экспертных системах следует предусматривать дружественное взаимодействие с пользователем, которое делает для пользователя процесс рассуждения системы "прозрачным".<br>   Часто к экспертным системам предъявляют дополнительное требование — способность иметь дело с неопределенностью и неполнотой. Информация о поставленной задаче может быть неполной или ненадежной; отношения между объектами предметной области могут быть приближенными. Например, может не быть полной уверенности в наличии у пациента некоторого симптома или в том, что данные, полученные лри измерении, верны; лекарство <i>может</i> стать причиной осложнения, хотя <i>обычно</i> этого не происходит. Во всех этих случаях необходимы рассуждения с использованием вероятностного подхода.<br>   В самом общем случае для того, чтобы построить экспертную систему, мы должны разработать механизмы выполнения следующих функций системы:<br>   • <i>решение задач</i> с использованием знаний о конкретной предметной области — возможно, при этом возникнет необходимость <i>иметь дело с неопределенностью</i><br>   • <i>взаимодействие с пользователем</i>, включая объяснение намерений и решений системы во время и после окончания процесса решения задачи.<br>   Каждая из этих функций может оказаться очень сложной и зависит от прикладной области, а также от различных практических требований. В процессе разработки и реализации могут возникать разнообразные трудные проблемы. В данной главе мы ограничился наметками основных идей, подлежащих в дальнейшем детализации и усовершенствованию.<br></div>
<h3 align="center">
<a name="TOC_id3451594"></a>14.2. Грубая структура экспертной системы<br></h3>
<div>   При разработке экспертной системы принято делить ее на три основных модуля, как показано на рис. 14.1:<br>   (1) база знаний,<br>   (2) машина логического вывода,<br>   (3) интерфейс с пользователем.<br>   <i>База знаний</i> содержит знания, относящиеся к конкретной прикладной области, в том числе отдельные факты, правила, описывающие отношения или явления, а также, возможно, методы, эвристики и различные идеи, относящиеся к решению задач в этой прикладной области. <i>Машина логического вывода</i> умеет активно использовать информацию, содержащуюся в базе знаний. <i>Интерфейс с пользователем</i> отвечает за бесперебойный обмен информацией между пользователем и системой; он также дает пользователю возможность наблюдать за процессом решения задач, протекающим в машине логического вывода. Принято рассматривать машину вывода и интерфейс как один крупный модуль, обычно называемый <i>оболочкой экспертной системы</i>, или, для краткости, просто <i>оболочкой</i>.<br><div align="center"><img border="1" src="_100.png"></div>   <b>Рис. 14.1.</b> Структура экспертной системы.<br>   В описанной выше структуре собственно знания отделены от алгоритмов, использующих эти знания. Такое разделение удобно по следующим соображениям. База знаний, очевидно, зависит от конкретного приложения. С другой стороны, оболочка, по крайней мере в принципе, независима от приложений. Таким образом, разумный способ разработки экспертной системы для нескольких приложений сводится к созданию универсальной оболочки, после чего для каждого приложения достаточно подключить к системе новую базу знаний. Разумеется, все эти базы знаний должны удовлетворять одному и тому же формализму, который оболочка "понимает". Практический опыт показывает, что для сложных экспертных систем наш сценарий с одной оболочкой и многими базами знаний работает не так гладко, как бы этого хотелось, за исключением тех случаев, когда прикладные области очень близки. Тем не менее даже если переход от одной прикладной области к другой требует модификации оболочки, то по крайней мере основные принципы ее построения обычно удается сохранить.<br>   В этой главе мы намерены разработать относительно простую оболочку, при помощи которой, несмотря на. ее простоту, мы сможем проиллюстрировать основные идеи и методы в области экспертных систем. Мы будем придерживаться следующего плана:<br>   (1) Выбрать формальный аппарат для представления знаний.<br>   (2) Разработать механизм логического вывода, соответствующий этому формализму.<br>   (3) Добавить средства взаимодействия с пользователем.<br>   (4) Обеспечить возможность работы в условиях неопределенности.<br></div>
<h3 align="center">
<a name="TOC_id3451691"></a>14.3. Правила типа "если-то" для представления знаний<br></h3>
<div>   В качестве кандидата на использование в экспертной системе можно рассматривать, в принципе, любой непротиворечивый формализм, в рамках которого можно описывать знания о некоторой проблемной области. Однако самым популярным формальным языком представления знаний является язык правил типа "если-то" (или кратко: "если-то"-правил), называемых также <i>продукциями</i>. Каждое такое правило есть, вообще говоря, некоторое условное утверждение, но возможны и различные другие интерпретации. Вот примеры:<br>   <i>• если</i> предварительное условие P <i>то</i> заключение (вывод) С<br>   • <i>если</i> ситуация S <i>то</i> действие А<br>   • <i>если</i> выполнены условия C1 и C2 <i>то</i> не выполнено условие С<br>   "Если-то"-правила обычно оказываются весьма естественным выразительным средством представления знаний. Кроме того, они обладают следующими привлекательными свойствами:<br>   • <i>Модульность</i>: каждое правило описывает небольшой, относительно независимый фрагмент знаний.<br>   • Возможность <i>инкрементного наращивания</i>: добавление новых правил в базу знаний происходит относительно независимо от других правил.<br>   • <i>Удобство модификации</i> (как следствие модульности): старые правила можно изменять и заменять на новые относительно независимо от других правил.<br>   • Применение правил способствует <i>прозрачности</i> системы.<br>   Последнее свойство — это важное, отличительное свойство экспертных систем. Под прозрачностью мы понимаем способность системы к объяснению принятых решений и полученных результатов. Применение "если-то"-правил облегчает получение ответов на следующие основные типы вопросов пользователя:<br>   (1) Вопросы типа "как": <i>Как</i> вы пришли к этому выводу?<br>   (2) Вопросы типа "почему": <i>Почему</i> вас интересует эта информация?<br>   Механизмы, основанные на "если-то"-правилах, для формирования ответов на подобные вопросы мы обсудим позже.<br>
		 <br>   <i>если</i><br>    1 тип инфекции — это первичная бактериемия и<br>    2 материал для посева был отобран стерильно, и<br>    3 предполагаемые ворота инфекции — желудочно-кишечный тракт<br>   <i>то</i><br>    имеются веские аргументы (0.7) за то,<br>    что инфекционный агент является бактерией<br>   <b>Рис. 14.2.</b> "Если-то"-правило медицинской консультативной системы MYCIN (Shortliffe, 1976). Параметр 0.7 показывает степень доверия этому правилу.<br>
		 <br>   "Если-то"-правила часто применяют для определения логических отношений между понятиями предметной области. Про чисто логические отношения можно сказать, что они принадлежат к "категорическим знаниям", "категорическим" — потому, что соответствующие утверждения всегда, абсолютно верны. Однако в некоторых предметных областях, таких, как медицинская диагностика, преобладают "мягкие" или вероятностные знания. Эти знания являются "мягкими"; в том смысле, что говорить об их применимости к любым практическим ситуациям можно только до некоторой степени ("часто, но не всегда"). В таких случаях используют модифицированные "если-то"-правила, дополняя их логическую интерпретацию вероятностной оценкой. Например:<br>   <i>если</i> условие А <i>то</i> заключение В <i>с уверенностью</i> F<br>   Рис. 14.2, 14.3 и 14.4 дают представление о разнообразии способов, которыми знания могут быть выражены при помощи "если-то"-правил. На этих рисунках приведены примеры правил из трех различных систем, основанных на знаниях: медицинской консультативной системы MYCIN, системы AL/X для диагностики неисправностей в оборудовании и системы AL3 для решения шахматных задач.<br>   Вообще говоря, если вы хотите разработать серьезную экспертную систему для некоторой выбранной вами предметной области, вы должны провести консультации с экспертами в этой области и многое узнать о ней сами. Достигнуть определенного понимания предметной области после общения с экспертами и чтения литературы, а затем облечь это понимание в форму представления знаний в рамках выбранного формального языка — это искусство, называемое <i>инженерией знаний</i>. Как правило, это сложная задача, требующая больших усилий, чего мы не можем себе позволить в данной книге. Но какая-нибудь предметная область и какая-нибудь база данных нам необходимы в качестве материала для экспериментов. С практической точки зрения нам для этой цели вполне подойдет "игрушечная" база знаний. На рис. 14.5 показана часть такой базы знаний. Она состоит из простых правил, помогающих идентифицировать животных по их основным признаками в предположении, что задача идентификации ограничена только небольшим числом разных животных.<br>
		 <br>   <i>если</i><br>    давление в v-01 достигло уровня открытия выпускного клапана<br>   <i>то</i><br>    выпускной клапан в v-01 открылся<br>    [N=0.005, S=400]<br>   <i>если</i><br>    давление в v-01 не достигло уровня открытия выпускного клапана и выпускной клапан в v-01 открылся<br>   <i>то</i><br>    преждевременное открытие выпускного клапана (сместилась установка порогового давления)<br>    [N=0.001, S=2000]<br>   <b>Рис. 14.3.</b> Два правила из демонстрационной базы знаний системы AL/X для диагностики неисправностей (Reiter 1980). N и S — величины "необходимости" и "достаточности", детально описанные в разд. 14.7. Величина S указывает степень, с которой условие влечет за собой заключение (вывод). Величина N указывает, до какой степени истинность условия необходима для того, чтобы заключение было истинным.<br>
		 <br>   <i>если</i><br>    1 существует гипотеза <i>H</i>, что план <i>P</i> ведет к успеху, и<br>    2 существуют две гипотезы<br>     <i>H1</i>, что план <i>P1</i> опровергает план <i>P</i>, и<br>     <i>Н2</i>, что план <i>Р2</i> опровергает план <i>P</i>, и<br>    3 имеют место факты:<br>      гипотеза <i>H1</i> ложна и<br>      гипотеза <i>Н2</i> ложна<br>   <i>то</i><br>    1 породить гипотезу <i>Н3</i>, что составной план <i>"P1 или Р2"</i> опровергает план <i>P</i>, и<br>    2 породить факт: <i>из  Н3 следует не( H)</i><br>   <b>Рис. 14.4.</b> Правило уточнения плана из системы AL3 для решения шахматных задач (Bratko 1982).<br>
		 <br>   Правила, содержащиеся в базе знаний, имеют вид<br>   ИмяПравила : если Условие то Заключение<br>   где Заключение — это простое утверждение, а Условие — это набор простых утверждений, соединенных между собой операторами и и или. Мы также разрешим в части условия использовать оператор не, хотя и с некоторыми оговорками. При надлежащем прологовском определении этих операторов (как это сделано на рис. 14.5) правила станут синтаксически верными предложениями Пролога. Заметим, что оператор и связывает операнды сильнее, чем или, что соответствует обычным соглашениям.<br>
		 <br>   % Небольшая база знаний для идентификации животных<br>   :- op( 100, xfx, [имеет, 'кормит детенышей',<br>    'не может', ест, откладывает, это]).<br>   :- op( 100, xf, [плавает, летает, хорошо]).<br>
		 <br>   прав1: если<br>    Животное имеет шерсть<br>    или<br>    Животное 'кормит детенышей' молоком<br>   то<br>    Животное это млекопитающее.<br>
		 <br>   прав2: если<br>    Животное имеет перья<br>    или<br>    Животное летает и<br>    Животное откладывает яйца<br>   то<br>    Животное это птица.<br>
		 <br>   прав3: если<br>    Животное это млекопитающее и<br>    ( Животное ест мясо<br>      или<br>      Животное имеет 'острые зубы' и<br>      Животное имеет когти и<br>      Животное имеет<br>      'глаза, направленные вперед' )<br>   то<br>    Животное это хищник.<br>
		 <br>   прав4: если<br>    Животное это хищник и<br>    Животное имеет<br>     'рыжевато-коричневый цвет' и<br>    Животное имеет 'темные пятна'<br>   то<br>    Животное это гепард.<br>
		 <br>   прав5: если<br>    Животное это хищник и<br>    Животное имеет<br>     'рыжевато-коричневый цвет' и<br>    Животное имеет 'черные полосы'<br>   то<br>    Животное это тигр.<br>
		 <br>   прав6: если<br>    Животное это птица и<br>    Животное 'не может' летать и<br>    Животное плавает<br>   то<br>    Животное это пингвин.<br>
		 <br>   прав7: если<br>    Животное это птица и<br>    Животное летает хорошо<br>   то<br>    Животное это альбатрос.<br>
		 <br>   факт: X это животное :-<br>    принадлежит( X, [гепард, тигр, пингвин, альбатрос]).<br>
		 <br>   можно_спросить( _ 'кормит детенышей' _,<br>    'Животное' 'кормит детенышей' 'Чем').<br>   можно_спросить( _ летает, 'Животное' летает).<br>   можно_спросить( _ откладывает яйца,<br>    'Животное' откладывает яйца).<br>   можно_спросить( _ ест _, 'Животное' ест 'Что').<br>   можно_спросить( _ имеет _,'Животное' имеет 'Нечто').<br>   можно_спросить( _ 'не может' _,<br>    'Животное' 'не может' 'Что делать').<br>   можно_спросить( _ плавает, 'Животное' плавает).<br>   можно_спросить( _ летает хорошо,<br>    'Животное' летает хорошо).<br>   <b>Рис. 14.5.</b> Простая база знаний для идентификации животных. Заимствовано из Winston (1984). Отношение "можно_спросить" определяет вопросы, которые можно задавать пользователю. Операторы если, то, и, или определены на рис. 14.10.<br>
		 <br>   Рассмотрим еще одну небольшую базу знаний, которая может помочь локализовать неисправности в простой электрической схеме, состоящей из электрических приборов и предохранителей. Электрическая схема показана на рис. 14.6. Вот одно из возможных правил:<br>   <i>если</i><br>    лампа1 включена <i>и</i><br>    лампа1 не работает  <i>и</i><br>    предохранитель1 заведомо цел<br>   <i>то</i><br>    лампа1 заведомо неисправна.<br>   Вот другой пример правила:<br>   <i>если</i><br>    радиатор работает<br>   <i>то</i><br>    предохранитель1 заведомо цел.<br><div align="center"><img border="1" src="_101.png"></div>   <b>Рис. 14.6.</b> Соединения между предохранителями и приборами в простой электрической схеме.<br>   Эти два правила опираются на некоторые факты (относящиеся к нашей <i>конкретной</i> схеме), а именно что <i>лампа1</i> соединена с <i>предохранитель1</i> и что <i>лампа1</i> и <i>радиатор</i> имеют общий предохранитель. Для другой схемы нам понадобится еще один набор правил. Поэтому было бы лучше сформулировать правила в более общем виде (используя прологовские переменные) так, чтобы они были применимы к любой схеме, а затем уже дополнять их информацией о конкретной схеме. Например, вот одно из полезных правил: если прибор включен, но не работает, а соответствующий предохранитель цел, то прибор неисправен. На наш формальный язык это транслируется так:<br>   правило_поломки:<br>    если<br>     Прибор включен и<br>     не (Прибор работает) и<br>     Прибор соединен с Предохранитель и<br>     Предохранитель заведомо цел<br>    то<br>     Прибор заведомо неисправен.<br>   База знаний такого рода показана на рис. 14. 7.<br>
		 <br>   % Небольшая база знаний для локализации неисправностей в<br>   % электрической схеме<br>
		 <br>   % Если прибор включен, но не работает, и предохранитель цел,<br>   % то прибор неисправен.<br>   правило_поломки:<br>    если<br>     вкл( Прибор) и<br>     прибор( Прибор) и<br>     не работает( Прибор) и<br>     соед( Прибор, Предохр) и<br>     доказано( цел( Предохр) )<br>    то<br>     доказано( неиспр( Прибор) ).<br>
		 <br>   % Если устройство работает, то его предохранитель цел<br>   правило_цел_предохр:<br>    если<br>     соед( Прибор, Предохр)<br>     и работает( Прибор)<br>    то<br>     доказано( цел( Предохр) ).<br>
		 <br>   % Если два различных прибора подключены к одному и тому же<br>   % предохранителю, оба включены и не работают, то предохранитель<br>   % сгорел.<br>   % ЗАМЕЧАНИЕ: предполагается, что из двух приборов неисправных -<br>   % не более одного!<br>   правило_предохр:<br>    если<br>     соед( Прибор1, Предохр) и<br>     вкл( Прибор1) и<br>     не работает( Прибор1) и<br>     общ_предохр( Прибор2, Прибор1) и<br>     вкл( Прибор2) и<br>     не работает( Прибор2)<br>    то<br>     доказано( сгорел( Предохр) ).<br>
		 <br>   правило_общ_предохр:<br>    если<br>     соед( Прибор1, Предохр) и<br>     соед( Прибор2, Предохр) и<br>     различны( Прибор1, Прибор2)<br>    то<br>     общ_предохр( Прибор1, Прибор2).<br>
		 <br>   факт: различны( X, Y) :- not (X=Y).<br>   факт: прибор( радиатор).<br>   факт: прибор( лампа1).<br>   факт: прибор( лампа2).<br>   факт: прибор( лампа3).<br>   факт: прибор( лампа4).<br>   факт: соед( лампа1, предохр1).<br>   факт: соед( лампа2, предохр1).<br>   факт: соед( радиатор, предохр1).<br>   факт: соед( лампа3, предохр2).<br>   факт: соед( лампа4, предохр2).<br>
		 <br>   можно_спросить( вкл( П), вкл( 'Прибор') ).<br>   можно_спросить( работает( П), работает(' Прибор')).<br>   <b>Рис. 14.7.</b> База знаний для локализации неисправностей в схеме, показанной на рис. 14.6.<br>
		 <br><h5>Упражнения</h5>   <b>14.1.</b> Рассмотрите "если-то"-правила рис. 14.2-14.4 и транслируйте их в нашу систему обозначений для правил. Предложите расширение нотации, чтобы, при необходимости, можно было работать с оценками уверенности.<br>   <b>14.2.</b> Придумайте какую-нибудь задачу принятия решений и сформулируйте соответствующие знания в форме "если-то"-правил. Можете рассмотреть, например, планирование отпуска, предсказание погоды, простой медицинский диагноз и лечение и т.п.<br></div>
<h3 align="center">
<a name="TOC_id3452800"></a>14.4. Разработка оболочки<br></h3>
<div>
<div>   Если мы посмотрим на правила наших двух маленьких баз знаний рис. 14.5 и 14.7, мы сразу увидим, что они по своему смыслу эквивалентны правилам Пролога. Однако, с точки зрения синтаксиса Пролога, эти правила в том виде, как они написаны, соответствуют всего лишь фактам. Для того, чтобы заставить их работать, самое простое, что может прийти в голову, это переписать их в виде настоящих прологовских правил. Например:<br>   Животное это млекопитающее :-<br>    Животное имеет шерсть;<br>    Животное 'кормит детенышей' молоком.<br>
		 <br>   Животное это хищник :-<br>    Животное это млекопитающее,<br>    Животное ест мясо.<br>   ...<br>   Теперь эта программа сможет подтвердить, что тигр по имени Питер — это действительно тигр, если мы добавим в нее некоторые из свойств Питера (в виде прологовских фактов):<br>   питер имеет шерсть.<br>   питер ленив.<br>   питер большой.<br>   питер имеет 'рыжевато-коричневый цвет'.<br>   питер имеет 'черные полосы'.<br>   питер ест мясо.<br>   Тогда мы можем спросить:<br>   ?- питер это тигр.<br>   yes<br>
		 <br>   ?- питер это гепард.<br>   no<br>   Хотя пролог-система и отвечает на вопросы, используя для этого нашу базу знаний, нельзя сказать, что ее поведение вполне соответствует поведению эксперта. Это происходит по крайней мере по двум причинам:<br>   (1) Мы не можем попросить систему объяснить свой ответ; например, <i>как</i> она установила, что Питер это тигр, и <i>почему</i> Питер это <i>не</i> гепард.<br>   (2) Прежде, чем задать вопрос, нужно ввести в систему всю необходимую информацию (в виде прологовских фактов). Но тогда пользователь, возможно, введет какую-нибудь лишнюю информацию (как в нашем примере) или же упустит какую-нибудь информацию, имеющую решающее значение. В первом случае будет проделана ненужная работа, а во втором - система будет давать неверные ответы.<br>   Для того, чтобы исправить эти два недостатка, мы нуждаемся в более совершенном способе взаимодействия между пользователем и системой во время и после завершения процесса рассуждений. Поставим себе целью добиться того, чтобы система взаимодействовала с пользователем так, как в следующем примере диалога (ответы пользователя даются полужирным шрифтом, реплики пролог-системы — курсивом):<br>   <i>Пожалуйста, спрашивайте:</i><br>   <b>питер это тигр.</b><br>
		 <br>   <i>Это правда: питер имеет шерсть?</i><br>   <b>да.</b><br>
		 <br>   <i>Это правда: питер ест мясо?</i><br>   <b>нет.</b><br>
		 <br>   <i>Это правда: питер имеет острые зубы?</i><br>   <b>да.</b><br>
		 <br>   <i>Это правда: питер имеет когти?</i><br>   <b>почему.</b><br>
		 <br>   <i>Чтобы проверить по прав3, что питер это хищник,</i><br>   <i>Чтобы проверить по прав5, что питер это тигр</i><br>   <i>Это был ваш вопрос</i><br>
		 <br>   <i>Это правда: питер имеет когти?</i><br>   <b>да.</b><br>
		 <br>   <i>Это правда: питер имеет глаза, направленные вперед?</i><br>   <b>да.</b><br>
		 <br>   <i>Это правда: питер имеет рыжевато-коричневый цвет?</i><br>   <b>да.</b><br>
		 <br>   <i>Это правда: питер имеет черные полосы?</i><br>   <b>да.</b><br>
		 <br>   <i>(питер это тигр) это правда</i><br>   <i>Хотите узнать, как?</i><br>   <b>да.</b><br>
		 <br>   <i>питер это тигр</i><br>   <i> было выведено по прав5 из</i><br>   <i>  питер это хищник,</i><br>   <i>   было выведено по прав3 из</i><br>   <i>    питер это млекопитающее</i><br>   <i>     было выведено по прав1 из</i><br>   <i>      питер имеет шерсть</i><br>   <i>       было сказано</i><br>   <i>    и</i><br>   <i>    питер имеет острые зубы</i><br>   <i>     было сказано</i><br>   <i>    и</i><br>   <i>    питер имеет когти</i><br>   <i>     было сказано</i><br>   <i>    и</i><br>   <i>    питер имеет глаза, направленные вперед</i><br>   <i>     было сказано</i><br>   <i>    и</i><br>   <i>    питер имеет рыжевато-коричневый цвет</i><br>   <i>     было сказано</i><br>   <i>    и</i><br>   <i>    питер имеет черные полосы</i><br>   <i>     было сказано</i><br>   Как видно из диалога, система задает пользователю вопросы, касающиеся "примитивной" информации, например:<br>   <i>Это правда: питер ест мясо?</i><br>   Эту информацию нельзя отыскать в базе знаний или вывести из другой информации. На подобные вопросы пользователь может отвечать двумя способами:<br>   (1) сообщив системе в качестве ответа на вопрос необходимую информацию или<br>   (2) спросив систему, <i>почему</i> эта информация необходима.<br>   Последняя из двух возможностей полезна, поскольку она позволяет пользователю заглянуть внутрь системы и увидеть ее текущие намерения. Пользователь спросит "почему" в том случае, когда вопрос системы покажется ему не относящимся к делу либо когда ответ на вопрос системы потребует от него дополнительных усилий. Из объяснений системы пользователь поймет, стоит ли информация, которую запрашивает система, тех дополнительных усилий, которые необходимо приложить для ее приобретения. Предположим, например, что система спрашивает: "Это животное ест мясо?" Пользователь, не знающий ответа на этот вопрос, поскольку он никогда не видел, как это животное ело что-либо, может решить, что не стоит ждать, пока он застанет животное за едой и убедится, что оно действительно ест мясо.<br>   Для того, чтобы заглянуть внутрь системы и до какой-то степени представить себе протекающий в ней процесс рассуждений, можно воспользоваться прологовскими средствами трассировки. Но эти средства в большинстве случаев окажутся недостаточно гибкими для наших целей. Поэтому, вместо того, чтобы воспользоваться собственным механизмом интерпретации Пролога, который не сможет справиться с нужным нам способом взаимодействия с пользователем, мы создадим свое средство интерпретации в виде специальной надстройки над пролог-системой. Этот новый интерпретатор будет включать в себя средства для взаимодействия с пользователем.<br></div>
<h4 align="center">
<a name="TOC_id3453262"></a>14.4.1. Процесс рассуждений<br></h4>
<div>   Наш интерпретатор будет принимать вопрос и искать на него ответ. Язык правил допускает, чтобы в условной части правила была И/ИЛИ-комбинация условий. Вопрос на входе интерпретатора может быть такой же комбинацией подвопросов. Поэтому процесс поиска ответов на эти вопросы будет аналогичен процессу поиска в И/ИЛИ-графах, который мы обсуждали в гл. 13.<br>   Ответ на заданный вопрос можно найти несколькими способами в соответствии со следующими принципами:<br><blockquote>   Для того, чтобы найти ответ <i>Отв</i> на вопрос <i>В</i>, используйте одну из следующих возможностей:<br>   • если <i>В</i> найден в базе знаний в виде факта, то <i>Отв</i> — это "<i>В</i> это правда"<br>   • если в базе знаний существует правило вида<br>     "если <i>Условие</i> то <i>В</i>",<br>   то для получения ответа <i>Отв</i> рассмотрите <i>Условие</i><br>   • если вопрос <i>В</i> можно задавать пользователю, спросите пользователя об истинности <i>В</i><br>   • если в имеет вид <i>В1 и В2</i>, то рассмотрите <i>В1</i>, а затем,<br>     если <i>В1 </i>ложно, то положите <i>Отв </i>равным "<i>В </i>это ложь",  в противном случае рассмотрите <i>В2 </i>и получите <i>Отв </i>как соответствующую комбинацию ответов на вопросы <i>В1</i> и <i>В2</i><br>   • если <i>В</i> имеет вид <i>В1 или В2</i>, то рассмотрите <i>В1</i>, а затем,<br>     если <i>В1</i> истинно, то положите <i>Отв</i> равным "<i>В1</i> это правда",  в противном случае рассмотрите <i>В2</i> и получите <i>Oтв</i> как соответствующую комбинацию ответов на вопросы <i>В1</i> и <i>В2</i>.<br></blockquote>   Вопросы вида<br>   <i>не В</i><br>   обрабатываются не так просто, и мы обсудим их позже. <br></div>
<h4 align="center">
<a name="TOC_id3453440"></a>14.4.2. Формирование ответа на вопрос "почему"<br></h4>
<div>   Вопрос "<i>почему</i>" возникает в ситуации, когда система просит пользователя сообщить ей некоторую информацию, а пользователь желает знать, <i>почему</i> эта информация необходима. Допустим, что система спрашивает:<br>   <i>а — это правда?</i><br>   В ответ пользователь может спросить:<br>   <b>почему?</b><br>   Объяснение в этом случае выглядит примерно так:<br>   Потому, что<br>   Я могу использовать <i>а</i>,<br>     чтобы проверить по правилу <i>П<sub>а</sub></i>, что <i>b</i>, и<br>   Я могу использовать <i>b</i>,<br>     чтобы проверить по правилу <i>П<sub>b</sub></i>, что <i>с</i>, и<br>   Я могу использовать <i>с</i>,<br>     чтобы проверить по правилу <i>П<sub>c</sub></i>, что <i>d</i>, и<br>   …<br>   Я могу использовать <i>y</i>,<br>     чтобы проверить по правилу <i>П<sub>y</sub></i>, что <i>z</i>, и<br>   <i>z</i> — это ваш исходный вопрос.<br>   Объяснение — это демонстрация того, как система намерена использовать информацию, которую она хочет получить от пользователя. Намерения системы демонстрируются в виде цепочки правил и целей, соединяющей эту информацию с исходным вопросом.<br><div align="center"><img border="1" src="_102.png"></div>   <b>Рис. 14.8.</b> Объяснение типа "почему". На вопрос "Почему вас интересует текущая цель?" дается объяснение в виде цепочки правил и целей, соединяющей текущую цель с исходным вопросом пользователя, находящимся в верхушке дерева. Эта цепочка называется трассой.<br>   Будем называть такую цепочку <i>трассой</i>. Трассу можно себе представлять как цепочку правил, соединяющую в И/ИЛИ-дереве вопросов текущую цель с целью самого верхнего уровня так, как это показано на рис. 14.8. Таким образом, для формирования ответа на вопрос "почему" нужно двигаться в пространстве поиска от текущей цели вверх вплоть до самой верхней цели. Для того, чтобы суметь это сделать, нам придется в процессе рассуждений сохранять трассу в явном виде. <br></div>
<h4 align="center">
<a name="TOC_id3453601"></a>14.4.3. Формирование ответа на вопрос "как"<br></h4>
<div>   Получив ответ на свой вопрос, пользователь возможно захочет увидеть, <i>как</i> система пришла к такому заключению. Один из подходящих способов ответить на вопрос "как" — это представить доказательство, т.е. те правила и подцели, которые использовались для достижения полученного заключения. Это доказательство в случае нашего языка записи правил имеет вид решающего И/ИЛИ-дерева. Поэтому наша машина логического вывода будет не просто отвечать на вопрос, соответствующий цели самого верхнего уровня — этого нам недостаточно, а будет выдавать в качестве ответа решающее И/ИЛИ-дерево, составленное из имен правил и подцелей. Затем это дерево можно будет отобразить на выходе системы в качестве объяснения типа "как". Объяснению можно придать удобную для восприятия форму, если каждое поддерево печатать с надлежащим отступом, например:<br>   <i>питер это хищник</i><br>   <i> было выведено по прав3 из</i><br>   <i>  питер это млекопитающее</i><br>   <i>   было выведено по прав1 из</i><br>   <i>    питер имеет шерсть</i><br>   <i>     было сказано</i><br>   <i>  и</i><br>   <i>  питер ест мясо</i><br>   <i>   было сказано</i><br></div>
</div>
<h3 align="center">
<a name="TOC_id3453676"></a>14.5. Реализация<br></h3>
<div>
<div>   Теперь мы приступим к реализации нашей оболочки, следуя тем идеям, которые обсуждались в предыдущем разделе. На рис. 14.9 показаны основные объекты, которыми манипулирует оболочка. Цель — это вопрос, подлежащий рассмотрению; Трасса — это цепочка, составленная из "целей-предков" и правил, находящихся между вершиной Цель и вопросом самого верхнего уровня; Ответ — решающее дерево типа И/ИЛИ для вершины Цель.<br><div align="center"><img border="1" src="_103.png"></div>   <b>Рис. 14.9.</b> Отношение рассмотреть( Цель,  Трасса,  Ответ).<br>   Ответ — это И/ИЛИ решающее дерево для целевого утверждения Цель.<br>   Основными процедурами оболочки будут:<br>   рассмотреть( Цель, Трасса, Ответ)<br>   Эта процедура находит ответ Ответ на вопрос Цель. Процедура<br>   ответпольз( Цель, Трасса, Ответ)<br>   порождает решения для тех вопросов Цель, которые можно задавать пользователю. Она спрашивает пользователя об истинности утверждения Цель, а также отвечает на вопросы "почему". Процедура<br>   выдать( Ответ)<br>   выводит результат и отвечает на вопросы "как". Все эти процедуры приводятся в действие процедурой-драйвером эксперт.<br></div>
<h4 align="center">
<a name="TOC_id3453781"></a>14.5.1. Процедура рассмотреть<br></h4>
<div>   Центральной процедурой оболочки является процедура<br>   рассмотреть( Цель, Трасса, Ответ)<br>   которая будет находить ответ Ответ на заданный вопрос Цель, используя принципы, намеченные в общих чертах в разд. 14.4.1: найти Цель среди фактов базы знаний, или применить правило из базы знаний, или спросить пользователя, или же обработать Цель как И/ИЛИ-комбинацию подцелей.<br>   Аргументы имеют следующий смысл и следующую структуру:<br>   Цель<br>    вопрос, подлежащий рассмотрению, представленный как И/ИЛИ-комбинация простых утверждений, например<br>    X имеет перья или X летает или<br>    X откладывает яйца<br>   Трасса<br>    цепочка, составленная из целей-предков и правил, расположенных между Цель и исходной целью самого верхнего уровня. Представляется как список, состоящий из элементов вида<br>    Цель  по  Прав<br>    что означает: Цель рассматривалась с использованием правила Прав. Например, пусть исходной целью будет "питер это тигр", а текущей целью — "питер ест мясо". В соответствии с базой знаний рис. 14.5 имеем трассу<br>    [( питер это хищник) по прав3,<br>     ( питер это тигр) по прав5 ]<br>    Смысл ее можно выразить так:<br>    Я могу использовать "питер ест мясо" для того, чтобы проверить по прав3, что "питер это хищник".<br>    Далее, я могу использовать "питер это хищник" для того, чтобы проверить по прав5, что "питер это тигр".<br>   Ответ<br>    решающее И/ИЛИ-дерево для вопроса Цель. Общая форма представления для объекта Ответ:<br>    Заключение было Найдено<br>   где Найдено — это обоснование для результата Заключение. Следующие три примера иллюстрируют различные варианты ответов:<br>   (1) ( соед( радиатор, предохр1) это правда) было <br>      'найдено как факт'<br>   (2) (питер ест мясо) это ложь было сказано <br>   (3) (питер это хищник) это правда было <br>       ( 'выведено по' прав3 из<br>      (питер это млекопитающее) это правда было<br>       ( 'выведено по' прав1 из<br>      (питер имеет шерсть) это правда было сказано)<br>      и<br>      (питер ест мясо) это правда было сказано )<br>   На рис. 14.10 показана прологовская программа для процедуры рассмотреть. В этой программе реализованы принципы разд. 14.4.1 с использованием только что описанных структур данных.<br>
		 <br>   % Процедура<br>   %<br>   % рассмотреть( Цель, Трасса, Ответ)<br>   %<br>   % находит Ответ на вопрос Цель. Трасса - это цепочка<br>   % целей-предков и правил. "рассмотреть" стремится найти<br>   % положительный ответ на вопрос. Ответ "ложь" выдается<br>   % только в том случае, когда рассмотрены все возможности,<br>   % и все они дали результат "ложь".<br>
		 <br>   :- op( 900, xfx, :).<br>   :- op( 800, xfx, было).<br>   :- op( 870, fx, если).<br>   :- op( 880, xfx, то).<br>   :- op( 550, xfy, или).<br>   :- op( 540, xfy, и).<br>   :- op( 300, fx, 'выведено по').<br>   :- op( 600, xfx, из).<br>   :- op( 600, xfx, по).<br>
		 <br>   % В программе предполагается,что op( 700, хfх, это), op( 500, fx, не)<br>   рассмотреть( Цель, Трасса, Цель это правда<br>    было 'найдено как факт') :-<br>    факт : Цель.<br>
		 <br>   % Предполагается, что для каждого типа цели<br>   % существует только одно правило<br>   рассмотреть( Цель, Трасса,<br>    Цель это ПравдаЛожь<br>    было 'выведено по' Прав из Ответ) :-<br>    Прав : если Условие то Цель,<br>     % Правило, относящееся к цели<br>    рассмотреть( Условие, [Цель по Прав | Трасса], Ответ),<br>    истинность( Ответ, ПравдаЛожь).<br>   рассмотреть( Цель1 и Цель2, Трасса, Ответ) :- !,<br>    рассмотреть( Цель1, Трасса, Ответ1),<br>    продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ).<br>   рассмотреть( Цель1 или Цель2, Трасса, Ответ) :-<br>    рассм_да( Цель1, Трасса, Ответ);<br>     % Положительный ответ на Цель1<br>    рассм_да( Цель2, Трасса, Ответ).<br>     % Положительный ответ на Цель2<br>   рассмотреть( Цель1 или Цель2, Трасса,<br>    Ответ1 и Ответ2) :- !,<br>    not рассм_да( Цель1, Трасса, _ ),<br>    not рассм_да( Цель2, Трасса, _ ),<br>     % Нет положительного ответа<br>    рассмотреть( Цель1, Трасса, Ответ1),<br>     % Ответ1 отрицательный<br>    рассмотреть( Цель2, Трасса, Ответ2).<br>     % Ответ2 отрицательный<br>   рассмотреть( Цель, Трасса,<br>    Цель это Ответ было сказано) :-<br>    ответпольз( Цель, Трасса, Ответ). % Ответ дан пользователем<br>
		 <br>   рассм_да( Цель, Трасса, Ответ) :-<br>    рассмотреть( Цель, Трасса, Ответ),<br>    положительный( Ответ).<br>
		 <br>   продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ) :-<br>    положительный( Ответ1),<br>    рассмотреть( Цель2, Трасса, Ответ2),<br>    ( положительный( Ответ2), Ответ = Ответ1 и Ответ2;<br>    отрицательный( Ответ2), Ответ = Ответ2).<br>   продолжить( Ответ1, Цель1 и Цель2, _, Ответ1) :-<br>    отрицательный( Ответ1).<br>
		 <br>   истинность( Вопрос это ПравдаЛожь было Найдено,<br>    ПравдаЛожь) :- !.<br>   истинность( Ответ1 и Ответ2, ПравдаЛожь) :-<br>    истинность( Ответ1, правда),<br>    истинность( Ответ2, правда), !,<br>    ПравдаЛожь = правда;<br>    ПравдаЛожь = ложь.<br>
		 <br>   положительный( Ответ) :-<br>    истинность( Ответ, правда).<br>
		 <br>   отрицательный( Ответ) :-<br>    истинность( Ответ, ложь).<br>   <b>Рис. 14.10.</b> Основная процедура оболочки экспертной системы. <br></div>
<h4 align="center">
<a name="TOC_id3454310"></a>14.5.2. Процедура ответпольз<br></h4>
<div>   Прежде чем перейти к написанию процедуры ответпольз, давайте рассмотрим одну полезную вспомогательную процедуру<br>   принять( Ответ)<br>   В процессе диалога часто возникает ситуация, когда от пользователя ожидается ответ "да", "нет" или "почему". Процедура принять предназначена для того, чтобы извлечь один из этих ответов, понимая его правильно и в тех случаях, когда пользователь применяет сокращения ('д' или 'н') или делает ошибки. Если ответ пользователя непонятен, то принять просит дать другой вариант ответа.<br>   принять( Ответ) :-<br>    read( Ответ1),<br>    означает( Ответ1, Значение), !,<br>     % Ответ1 означает что-нибудь?<br>    Ответ = Значение;                          % Да<br>    nl, write( 'Непонятно, попробуйте еще раз, % Нет<br>                пожалуйста'), nl,<br>    принять( Ответ). % Новая попытка<br>
		 <br>   означает( да, да).<br>   означает( д, да).<br>   означает( нет, нет).<br>   означает( н, нет).<br>   означает( почему, почему).<br>   означает( п, почему).<br>   Следует заметить, что процедурой принять нужно пользоваться с осторожностью, так как она содержит взаимодействие с пользователем. Следующий фрагмент программы может служить примером неудачной попытки запрограммировать интерпретацию ответов пользователя:<br>   принять( да), интерп_да( ...);<br>   принять( нет), интерп_нет( ...);<br>   ...<br>   Здесь, если пользователь ответит "нет", то программа попросит его повторить свой ответ. Поэтому более правильный способ такой:<br>   принять( Ответ),<br>    ( Ответ = да, интерп_да( ...);<br>      Ответ = нет, интерп_нет( ...);<br>      ... )<br>   Процедура<br>   ответпольз( Цель, Трасса, Ответ)<br>   спрашивает пользователя об истинности утверждения Цель. Ответ — это результат запроса. Трасса используется для объяснения в случае, если пользователь спросит "почему".<br>   Сначала процедура ответпольз должна проверить, является ли Цель информацией, которую можно запрашивать у пользователя. Это свойство объекта Цель задается отношением<br>   можно_спросить( Цель)<br>   которое в дальнейшем будет усовершенствовано. Если спросить можно, то утверждение Цель выдается пользователю, который, в свою очередь, указывает истинно оно или ложно. Если пользователь спросит "почему", то ему выдается Трасса. Если утверждение Цель истинно, то пользователь укажет также значения содержащихся в нем переменных (если таковые имеются).<br>   Все вышеизложенное можно запрограммировать (в качестве первой попытки) следующим образом:<br>   остветпольз( Цель, Трасса, Ответ) :-<br>    можно_спросить( Цель), % Можно ли спрашивать<br>    спросить( Цель, Трасса, Ответ).<br>     % Задать вопрос относительно утверждения Цель<br>
		 <br>   спросить( Цель, Трасса, Ответ) :-<br>    показать( Цель),<br>     % Показать пользователю вопрос<br>    принять(Ответ1),       % Прочесть ответ<br>    обработать( Ответ1, Цель, Трасса, Ответ).<br>     % Обработать ответ<br>
		 <br>   обработать( почему, Цель, Трасса, Ответ) :-<br>     % Задан вопрос "почему"<br>    показать_трассу( Трасса),<br>     % Выдача ответа на вопрос "почему"<br>    спросить( Цель, Трасса, Ответ).<br>     % Еще раз спросить<br>   обработать( да, Цель, Трасса, Ответ) :-<br>     % Пользователь ответил, что Цель истинна<br>    Ответ = правда,<br>    запрос_перем( Цель);<br>     % Вопрос о значении переменных<br>    спросить( Цель, Трасса, Ответ).<br>     % Потребовать от пользователя новых решений<br>   обработать( нет, Цель, Трасса, ложь).<br>     % Пользователь ответил, что Цель ложна<br>
		 <br>   показать( Цель) :-<br>    nl, write( 'Это правда:'),<br>    write( Цель), write( ?), nl.<br>   Обращение к процедуре запрос_перем( Цель) нужно для того, чтобы попросить пользователя указать значение каждой из переменных, содержащихся в утверждении Цель:<br>   запрос_перем( Терм) :-<br>    var( Терм), !, % Переменная ?<br>    nl, write( Терм), write( '='),<br>    read( Терм).   % Считать значение переменной<br>   запрос_перем( Терм) :-<br>    Терм =.. [Функтор | Аргументы],<br>     % Получить аргументы структуры<br>    запрос_арг( Аргументы).<br>     % Запросить значения переменных в аргументах<br>
		 <br>   запрос_арг( []).<br>   запрос_арг( [Терм | Термы]) :-<br>    запрос_перем( Терм),<br>    запрос_арг( Термы).<br>   Проведем несколько экспериментов с процедурой ответпольз. Пусть, например, известно, что пользователя можно спрашивать о наличии бинарного отношения ест:<br>   можно_спросить( X ест Y).<br>   (В приведенных ниже диалогах между пролог-системой и пользователем тексты пользователя даются <b>полужирным шрифтом</b>, а реплики пролог-системы <i>курсивом</i>).<br>   <b>?- ответпольз( питер ест мясо, [], Ответ).</b><br>
		 <br>   <i>Это правда: питер ест мясо?</i> % Вопрос пользователю<br>   <b>да.</b>                         % Ответ пользователя<br>
		 <br>   <i>Ответ = правда</i><br>   Более интересный пример диалога (с использованием переменных) мог бы выглядеть примерно так:<br>   <b>?- ответпольз( Кто ест Что, [], Ответ).</b><br>
		 <br>   <i>Это правда: _17 ест _18?</i><br>     % Пролог дает переменным свои внутренние имена<br>   <b>да.</b><br>   <i>_17 =</i><b>питер</b>.<br>   <i>_18 =</i><b>мясо</b>.<br>
		 <br>   <i>Ответ = правда.</i><br>   <i>Кто = питер</i><br>   <i>Что = мясо;</i> % Возврат для получения других решений<br>
		 <br>   <i>Это правда: _17 ест _18?</i><br>   <b>да.</b><br>   <i>_17 =</i><b>сьюзен.</b><br>   <i>_18</i> = <b>бананы.</b><br>
		 <br>   <i>Ответ = правда</i><br>   <i>Кто = сьюзен</i><br>   <i>Что = бананы;</i><br>
		 <br>   <i>Это правда : _17 ест _18?</i><br>   <b>нет.</b><br>   <i>Ответ = ложь</i><br></div>
<h4 align="center">
<a name="TOC_id3454900"></a>14.5.3. Усовершенствование процедуры ответпольз<br></h4>
<div>   Один из недостатков нашей процедуры ответпольз, который хорошо виден из приведенного выше диалога, — это появление на выходе системы имен, генерируемых пролог-системой, что выглядит довольно неуклюже. Символы, подобные _17, следовало бы заменить на более осмысленные слова.<br>   Другой, более серьезный дефект этой версии процедуры ответпольз состоит в следующем. Если мы еще раз обратимся к ответпольз, задав ту же самую цель, то пользователю придется повторно вводить все варианты решений. Поэтому, если наша экспертная система придет в процессе рассуждений к рассмотрению той же самой цели второй раз, то, вместо того, чтобы использовать информацию, уже полученную от пользователя, она проведет с пользователем в точности тот же самый скучный диалог.<br>   Давайте исправим эти два дефекта. Во-первых, улучшение внешнего вида запросов системы будет основано на введении стандартного формата для каждой "запрашиваемой" цели. Для этого в отношение можно_спросить мы добавим второй аргумент, который и будет задавать этот формат, как видно из следующего примера:<br>   можно_спросить(X ест Y, 'Животное' ест 'Что-то').<br>   При передаче запроса пользователю каждая переменная вопроса должна быть заменена на ключевое слово, взятое из формата, например:<br>   <b>?- ответпольз( X ест Y, [], Ответ).</b><br>
		 <br>   <i>Это правда: Животное ест Что-то?</i><br>   <b>да.</b><br>
		 <br>   <i>Животное =</i><b>питер.</b><br>   <i>Что-то =</i><b>мясо.</b><br>
		 <br>   <i>Ответ = правда</i><br>   <i>X = питер</i><br>   <i>Y = мясо</i><br>   В улучшенной версии процедуры ответпольз, показанной на рис. 14.11, такое форматирование запросов выполняется процедурой<br>   формат( Цель, ВнешФормат, Вопрос, Перем0, Перем )<br>   Здесь Цель — утверждение, которое нужно форматировать. ВнешФормат определяет внешний формат этого утверждения, задаваемый отношением<br>   можно_спросить( Цель, ВнешФормат)<br>   Вопрос — это Цель, отформатированная в соответствии с ВнешФормат. Перем — список переменных, входящих в Цель, вместе с соответствующими ключевыми словами (как указано в ВнешФормат), причем список Перем получается из списка Перем0 добавлением новых переменных. Например:<br>   ?- формат( X передает документы Y,<br>    'Кто' передает 'Что' 'Кому',<br>    Вопрос, [], Перем).<br>
		 <br>   Вопрос = 'Кто' передает документы 'Кому',<br>    Перем = [ X/'Кто', Y/'Кому'].<br>   Второе усовершенствование, состоящее в устранении повторных вопросов к пользователю, будет более трудным. Во-первых, все ответы пользователя следует запоминать, с тем чтобы их можно было отыскать в памяти в более поздний момент времени. Для этого достаточно сделать ответы пользователя элементами некоторого отношения и применить assert, например<br>   assert( сказано( мери передает документы друзьям, правда) ).<br>   В ситуации, когда имеется несколько решений, предложенных пользователем для одной и той же цели, в память относительно нее будет записано несколько фактов. Здесь возникает одно осложнение. Допустим, что в нескольких местах программы встречаются различные варианты некоторой цели (отличающиеся именованием переменных). Например:<br>   ( X имеет Y) и   % Первый вариант - Цель1<br>   ...<br>
		 <br>   ( X1 имеет Y1) и % Второй вариант - Цель2<br>   ...<br>   Допустим также, что пользователя просят (через механизм возвратов) предложить несколько решений для Цель1. Затем процесс рассуждений продвигается вплоть до Цель2. Так как у нас уже есть несколько решений для Цель1, мы захотим, чтобы система автоматически применила их и к Цель2 (поскольку очевидно, что они удовлетворяют Цель2). Теперь предположим, что система пытается применить эти решения к Цель2, но ни одно из них не удовлетворяет некоторой другой цели, расположенной ниже. Система делает возврат к Цель2 и просит пользователя предложить новые решения. Если пользователь введет еще несколько решений, то их также придется запомнить. И если система в дальнейшем сделает возврат к Цель1, то эти новые решения надо будет применить к Цель1.<br>   Для того, чтобы правильным образом использовать информацию, вводимую пользователем по запросам из разных точек программы, мы будем снабжать каждую такую информацию специальным индексом. Таким образом, факты, запоминаемые системой, будут иметь вид<br>   сказано( Цель, Истинность, Индекс)<br>   где Индекс — это значение счетчика, ответов пользователя. Процедура<br>   ответпольз( Цель, Трасса, Ответ)<br>   теперь должна будет отслеживать число решений, уже порожденных механизмом возвратов к моменту обращения к этой процедуре. Это можно сделать при помощи другого варианта процедуры ответпольз с четырьмя аргументами:<br>   ответпольз( Цель, Трасса, Ответ, N)<br>   где N — некоторое целое число. Такое обращение к ответпольз должно порождать решения для Цель с индексами, начиная с N и далее. Обращение<br>   ответпольз( Цель, Трасса, Ответ)<br>   соответствует получению <i>всех</i> решений, индексируемых, начиная с 1, поэтому мы имеем следующее соотношение:<br>   ответпольз( Цель, Трасса, Ответ) :-<br>    ответпольз( Цель, Трасса, Ответ, 1).<br>   Принцип работы процедуры<br>   ответпольз( Цель, Трасса, Ответ, N)<br>   таков: сначала получить решения для Цель, отыскивая в памяти все уже известные решения с индексами, начиная с N и далее. Когда все старые решения исчерпаются, начать задавать вопросы пользователю относительно утверждения Цель, записывая полученные таким образом новые решения в память при помощи assert и индексируя их должным образом при помощи целых чисел. Когда пользователь сообщит, что больше нет решений, записать в память факт<br>   конец_ответов( Цель)<br>   Если пользователь с самого начала скажет, что решений нет вообще, то записать факт<br>   сказано( Цель, ложь, Индекс)<br>   Находя в памяти те или иные решения, процедура ответпольз должна правильно интерпретировать подобную информацию.<br>   Однако существует еще одна трудность. Пользователь может, оставляя некоторые переменные неконкретизированными, указывать общие решения. Если найдено положительное решение, более общее, чем Цель, или столь же общее, как Цель, то нет смысла продолжать задавать вопросы об утверждении Цель, поскольку мы уже имеем более общее решение. Аналогичным образом следует поступить, если обнаружен факт<br>   сказано( Цель, ложь, _ )<br>   Программа ответпольз, показанная на рис. 14.11, учитывает все вышеприведенные соображения. В нее введен новый аргумент Копия (копия утверждения Цель), который используется в нескольких случаях сопоставлений вместо Цель, с тем чтобы оставить в неприкосновенности переменные утверждения Цель. Эта программа использует также два вспомогательных отношения. Одно из них<br>   конкретный( Терм)<br>   истинно, если Терм не содержит переменных. Другое<br>   конкретизация( Терм, Терм1)<br>   означает, что Терм1 есть некоторая конкретизация (частный случай) терма Терм, т.е. Терм — это утверждение не менее общее, чем Терм1. Например:<br>   конкретизация( X передает информацию Y,<br>    мэри передает информацию Z)<br>   Обе процедуры основаны на еще одной процедуре:<br>   нумпер( Терм, N, М)<br>   Эта процедура "нумерует" переменные, содержащиеся в Терм, заменяя каждую из них на некоторый специальный новый терм таким образом, чтобы эти "нумерующие" термы соответствовали числам от N до M–1, Например, пусть эти термы имеют вид<br>   пер/0, пер/1, пер/2, ...<br>   тогда в результате обращения к системе<br>   ?- Терм = f( X, t( a,Y, X) ), нумпер( Терм, 5, М).<br>   мы получим<br>   Терм = f( пер/5, t( а, пер/6, пер/5) )<br>   М = 7<br>
		 <br>   % Процедура<br>   %<br>   % ответпольз( Цель, Трасса, Ответ)<br>   %<br>   % порождает, используя механизм возвратов, все решения<br>   % для целевого утверждения Цель, которые указал пользователь.<br>   % Трасса - это цепочка целей-предков и правил,<br>   % используемая для объяснения типа "почему".<br>   ответпольз( Цель, Трасса, Ответ) :-<br>    можно_спросить( Цель, _ ), % Можно спросить?<br>    копия( Цель, Копия),       % Переименование переменных<br>    ответпольз( Цель, Копия, Трасса, Ответ, 1).<br>
		 <br>   % Не спрашивать второй раз относительно конкретизированной цели<br>   ответпольз( Цель, _, _, _, N) :-<br>    N &gt; 1,                     % Повторный вопрос?<br>    конкретный( Цель),  !,     % Больше не спрашивать<br>    fail.<br>
		 <br>   % Известен ли ответ для всех конкретизации утверждения Цель?<br>   ответпольз( Цель, Копия, _, Ответ, _ ) :-<br>    сказано( Копия, Ответ, _ ),<br>    конкретизация( Копия, Цель), !. % Ответ известен<br>
		 <br>   % Найти все известные решения для Цель с индексами, начиная с N<br>   ответпольз( Цель, _, _, правда, N) :-<br>    сказано( Цель, правда, М),<br>    М &gt;= N.<br>
		 <br>   % Все уже сказано об утверждении Цель?<br>   ответпольз( Цель, Копия, _, Ответ, _) :-<br>    конец_ответов( Копия),<br>    конкретизация( Копия, Цель), !, % Уже все сказано<br>    fail.<br>
		 <br>   % Попросить пользователя дать (еще) решения<br>   ответпольз( Цель, _, Трасса, Ответ, N) :-<br>    спросить_польз( Цель, Трасса, Ответ, N).<br>
		 <br>   спросить_польз( Цель, Трасса, Ответ, N) :-<br>    можно спросить( Цель, ВнешФормат),<br>    формат( Цель, ВнешФормат, Вопрос, [], Перем),<br>     % Получить формат вопроса<br>    спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).<br>
		 <br>   спросить( Цель, Вопрос, Перем, Трасса, Ответ, N) :-<br>    nl,<br>    ( Перем = [], !,                % Сформулировать вопрос<br>    write( 'Это правда: ');<br>    write( 'Есть (еще) решения для :' )),<br>    write( Вопрос), write( '?'),<br>    принять( Ответ1), !,            % Ответ1 - да/нет/почему<br>    обработать( Ответ1, Цель, Вопрос, Перем,<br>                Трасса, Ответ, N).<br>
		 <br>   обработать( почему, Цель, Вопрос, Перем,<br>    Трасса, Ответ, N):-<br>    выд_трассу( Трасса),<br>    спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).<br>   обработать( да, Цель,_, Перем, Трасса, правда, N) :-<br>    след_индекс( Инд),<br>     % Получить новый индекс для "сказано"<br>    Инд1 is Инд + 1,<br>    ( запрос_перем( Перем),<br>      assertz( сказано( Цель, правда, Инд) );<br>       % Запись решения<br>    копия( Цель, Копия),            % Копирование цели<br>    ответпольз( Цель, Копия, Трасса, Ответ, Инд1) ).<br>     % Есть еще решения?<br>   обработать( нет, Цель, _, _, _, ложь, N) :-<br>    копия( Цель, Копия),<br>    сказано( Копия, правда, _), !,<br>     % 'нет' означает, больше нет решений<br>    assertz( конец_ответов( Цель) ),<br>     % Отметить конец ответов<br>    fail;<br>    след_индекс( Инд),<br>     % Следующий свободный индекс для "сказано"<br>    assertz( сказано( Цель, ложь, Инд) ).<br>     % 'нет' означает нет ни одного решения<br>
		 <br>   формат( Пер, Имя, Имя, Перем, [Пер/Имя | Перем]) :-<br>    var( Пер), !.<br>   формат( Атом, Имя, Атом, Перем, Перем) :-<br>    atomic( Атом), !,<br>    atomic( Имя).<br>   формат( Цель, Форм, Вопрос, Перем0, Перем) :-<br>    Цель =.. [Функтор | Apг1],<br>    Форм =.. [Функтор | Форм1],<br>    формвсе( Apг1, Форм1, Арг2, Перем0, Перем),<br>    Вопрос =.. [Функтор | Арг2].<br>
		 <br>   формвсе( [], [], [], Перем, Перем).<br>   формвсе( [X | СпХ], [Ф | СпФ], [В | СпВ], Перем0, Перем) :-<br>    формвсе( СпХ, СпФ, СпВ, Перем0, Перем1),<br>    формат( X, Ф, В, Перем1, Перем).<br>
		 <br>   запрос_перем( []).<br>   запрос_перем( [Переменная/Имя | Переменные]) :-<br>    nl, write( Имя), write( '='),<br>    read( Переменная),<br>    запрос_перем( Переменные).<br>
		 <br>   выд_трассу( []) :-<br>    nl, write( 'Это был ваш вопрос'), nl.<br>   выд_трассу( [Цель по Прав | Трасса] ) :-<br>    nl, write( 'Чтобы проверить по' ),<br>    write( Прав), write( ', что'),<br>    write( Цель),<br>    выд_трассу( Трасса).<br>
		 <br>   конкретный( Терм) :-<br>    нумпер( Терм, 0, 0).            % Нет переменных в Терм'е<br>
		 <br>   % конкретизация( Т1, Т2) означает, что Т2 - конкретизация Т1,<br>   % т.е. терм Т1 - более общий, чем Т2, или той же степени<br>   % общности, что и Т2<br>   конкретизация( Терм, Терм1) :-<br>     % Терм1 - частный случай Терм'а<br>    копия( Терм1, Терм2),<br>     % Копия Терм1 с новыми переменными<br>    нумпер( Терм2, 0, _), !,<br>    Терм = Терм2.       % Успех, если Терм1 - частный случай Терм2<br>
		 <br>   копия( Терм, НовТерм) :-<br>     % Копия Терм' а с новыми переменными<br>    asserta( copy( Терм) ),<br>    retract( сору( НовТерм) ), !.<br>
		 <br>   посл_индекс( 0).     % Начальный индекс для "сказано"<br>
		 <br>   след_индекс( Инд) :- % Следующий индекс для "сказано"<br>    retract( посл_индекс( ПослИнд) ), !,<br>    Инд is ПослИнд + 1,<br>    assert( посл_индекс( Инд) ).<br>   <b>Рис. 14.11.</b> Оболочка экспертной системы: Вопросы к пользователю и ответы на вопросы "почему".<br>
		 <br>   Отношение, подобное нумпер, часто входит в состав пролог-системы в качестве встроенной процедуры. Если это не так, то его можно реализовать программно следующим способом:<br>   нумпер( Терм, N, Nплюс1) :- <br>    var( Терм), !, % Переменная? <br>    Терм = пер/N, <br>    Nплюс1 is N + 1. <br>   нумпер( Терм, N, М) :-<br>    Терм =.. [Функтор | Аргументы], % Структура или атом<br>    нумарг( Аргументы, N, M).<br>     % Пронумеровать переменные в аргументах<br>
		 <br>   нумарг( [], N, N) :- !.<br>   нумарг( [X | Спис], N, M) :-<br>    нумпер( X, N, N1),<br>    нумарг( Спис, N1, М).<br></div>
<h4 align="center">
<a name="TOC_id3456046"></a>14.5.4. Процедура  выдать<br></h4>
<div>   Процедура<br>   выдать( Ответ)<br>   приведенная на рис. 14.12, показывает пользователю окончательный результат консультационного сеанса и дает объяснения типа "как". Ответ включает в себя как ответ на вопрос пользователя, так и дерево вывода, демонстрирующее <i>как</i> система пришла к такому заключению. Сначала процедура выдать представляет пользователю свое заключение. Затем, если пользователь пожелает узнать, <i>как</i> это заключение достигнуто, то печатается дерево вывода в некоторой удобной для восприятия форме - это и есть объяснение типа "как". Форма объяснения показана в примере разд. 14.4.3.<br></div>
<h4 align="center">
<a name="TOC_id3456084"></a>14.5.5. Драйвер верхнего уровня<br></h4>
<div>   И наконец, для того, чтобы иметь удобный доступ к оболочке из интерпретатора Пролога, нам необходима процедура, выполняющая функцию "драйвера". На рис. 14.13 показано, как могла бы выглядеть предназначенная для этой цели процедура эксперт. Драйвер эксперт производит запуск трех основных модулей оболочки (рис. 14.10–14.12) и координирует их работу. Например:<br>   <b>?- эксперт.</b><br>   <i>Пожалуйста, спрашивайте:</i>       % Приглашение пользователю<br>   <b>X это животное и голиаф это X.</b> % Вопрос пользователя<br>   <i>Это правда:  голиаф имеет шерсть?</i><br>   <b>...</b><br>
		 <br>   % Выдача заключения консультационного сеанса и<br>   % объяснения типа "как"<br>   выдать( Ответ) :-<br>    nl, заключение( Ответ),<br>    nl, write( 'Хотите узнать, как?'),<br>    принять( Ответ1),<br>    ( Ответ1 = да, !, отобр( Ответ);<br>      true).                        % Показ решающего дерева<br>
		 <br>   заключение( Ответ1 и Ответ2) :- !,<br>    заключение( Ответ1), write( 'и'),<br>    заключение( Ответ2).<br>   заключение( Заключение было Найдено) :-<br>    write( Заключение).<br>
		 <br>   % "отобр" отображает полное решающее дерево<br>   отобр( Решение) :-<br>    nl, отобр( Решение, 0), !.      % Отступ 0<br>   отобр( Ответ1 и Ответ2, H) :- !, % Отступ H<br>    отобр( Ответ1, H),<br>    tab( H), write( 'и'), nl,<br>    отобр( Ответ2, H).<br>   отобр( Ответ был Найден, H) :-   % Отступ H<br>    tab( H), печответ( Ответ),      % Показ заключения<br>    nl, tab( H),<br>    write( 'было'),<br>    отобр1( Найден, H).             % Показ доказательства<br>
		 <br>   отобр1( Выведено из Ответ, H) :- !,<br>    write( Выведено), write( 'из'), % Показ имени правила<br>    nl, H1 is H + 4,<br>    отобр( Ответ, H1).              % Показ "предшественника"<br>   отобр1( Найдено, _ ) :-<br>     % Найдено = 'сказано' или 'найдено как факт'<br>    write( Найдено), nl.<br>
		 <br>   печответ( Цель это правда) :- !,<br>    write( Цель).      % На выходе 'это правда' опускается<br>   печответ( Ответ) :- % Отрицательный ответ<br>    write( Ответ).<br>   <b>Рис. 14.12.</b> Оболочка экспертной системы: Отображение окончательного результата и объяснение типа "как".<br></div>
<h4 align="center">
<a name="TOC_id3456305"></a>14.5.6. Одно замечание по поводу программы-оболочки<br></h4>
<div>   В некоторых местах нашей программы-оболочки обнаруживается недостаток той "декларативной ясности", которая так характерна для программ, написанных на Прологе. Причина состоит в том, что нам пришлось предусмотреть в этой программе довольно жесткое управление процессом функционирования оболочки. Ведь, согласно нашему замыслу, экспертная система должна была не только находить ответы на вопросы, но и делать это некоторым разумным с точки зрения пользователя способом. В связи с этим нам пришлось реализовать вполне определенное <i>поведение</i> системы в процессе решения задач, а не просто некоторое отношение ввода-вывода. В результате получилась программа более процедурного характера, чем обычно. Все это может послужить примером ситуации, когда, не имея возможности рассчитывать на собственные процедурные механизмы Пролога, мы вынуждены взять на себя детальное описание процедурного поведения системы.<br></div>
<h4 align="center">
<a name="TOC_id3456331"></a>14.5.7. Цели с отрицанием<br></h4>
<div>   Использование знака отрицания в левых частях правил, а следовательно, и в вопросах, обрабатываемых процедурой рассмотреть, представляется естественным и его следует разрешить. В качестве первой попытки можно предложить следующий способ работы с отрицанием целей:<br>   рассмотреть( не Цель, Трасса, Ответ) :- !,<br>    рассмотреть( Цель, Трасса, Ответ1),<br>    обратить( Ответ1, Ответ).<br>     % Получить обратное истинностное значение<br>
		 <br>   обратить( Цель это правда было Найдено,<br>    ( не Цель) это ложь было Найдено).<br>   обратить( Цель это ложь было Найдено,<br>    ( не Цель) это правда было Найдено).<br>
		 <br>   % Процедура-драйвер верхнего уровня<br>   эксперт :-<br>    принять_вопрос( Вопрос),<br>     % Ввести вопрос пользователя<br>    ( ответ_да( Вопрос);<br>     % Попытка найти положительный ответ<br>    ответ_нет( Вопрос) ).<br>     % Если нет положительного ответа, то найти отрицательный<br>
		 <br>   ответ_да( Вопрос) :-<br>     % Искать положительный ответ на Вопрос<br>    статус( отрицательный),<br>     % Пока еще нет положительного ответа<br>    рассмотреть( Вопрос, [], Ответ), % Трасса пуста<br>    положительный( Ответ), % Искать положительный ответ<br>    статус( положительный),<br>     % Найден положительный ответ<br>    выдать( Ответ), nl,<br>    write( 'Нужны еще решения?' ),<br>    принять( Ответ1), % Прочесть ответ пользователя<br>    Ответ1 = нет.<br>     % В противном случае возврат к "рассмотреть"<br>
		 <br>   ответ_нет( Вопрос):-<br>     % Искать отрицательный ответ на Вопрос<br>    retract( пока_нет_положительного_решения), !,<br>     % Не было положительного решения?<br>    рассмотреть( Вопрос, [], Ответ),<br>    отрицательный( Ответ),<br>    выдать( Ответ), nl,<br>    write( 'Нужны еще решения?' ),<br>    принять( Ответ1),<br>    Ответ1 = нет.<br>     % В противном случае - возврат к "рассмотреть"<br>
		 <br>   статус( отрицательный) :-<br>    assert( пока_нет_положительного_решения).<br>   статус( положительный) :-<br>    retract( пока_нет_положительного_решения), !; true.<br>
		 <br>   принять_вопрос( Вопрос) :-<br>    nl, write( 'Пожалуйста, спрашивайте:'), nl,<br>    read( Вопрос).<br>   <b>Рис. 14.13.</b> Оболочка экспертной системы: драйвер. Обращение к оболочке из Пролога при помощи процедуры эксперт.<br>
		 <br>   Если Цель конкретизирована, то все в порядке, если же нет, то возникают трудности. Рассмотрим, например, такой диалог:<br>   <b>?- эксперт.</b><br>
		 <br>   <i>Пожалуйста, спрашивайте:</i><br>   <b>не ( X ест мясо).</b><br>
		 <br>   <i>Есть (еще) решения для : Животное</i><br>   <b>да.</b><br>   <i>Животное =</i><b>тигр</b>.<br>   В этот момент система даст ответ:<br>   <i>не ( тигр ест мясо) это ложь</i><br>   Такой ответ нас не может удовлетворить. Источник затруднения следует искать в том, какой смысл мы вкладываем в вопросы типа<br>   не ( X ест мясо)<br>   В действительности мы хотим спросить: "Существует ли такой X, что X не ест мяса?" Однако процедура рассмотреть (так как мы ее определили) проинтерпретирует этот вопрос следующим образом:<br>   (1) Существует ли такой X, что X ест мясо?<br>   (2) Да, тигр ест мясо.<br>   Итак,<br>   (3) не (тигр ест мясо) это ложь.<br>   Короче говоря, интерпретация такова — "Правда ли, что никакой X не ест мясо?" Положительный ответ мы получим, только если <i>никто</i> не ест мяса. Можно также сказать, что процедура рассмотреть отвечает на вопрос так, как будто X находится под знаком квантора <i>всеобщности</i>:<br>    для <i>всех</i> X: не (X ест мясо)?<br>   а не квантора существования, в чем и состояло наше намерение:<br>    для <i>некоторого</i> X: не (X ест мясо)?<br>   Если рассматриваемый вопрос конкретизирован, то проблемы исчезают. В противном случае правильный способ работы с отрицаниями становится более сложным. Например, вот некоторые из возможных правил:<br>   Для того, чтобы рассмотреть <i>(не Цель)</i>, рассмотрите <i>Цель</i>, а затем:<br>   • если <i>Цель</i> это ложь, то <i>(не Цель)</i> это правда;<br>   • если <i>Цель'</i> — это некоторое решение для <i>Цель</i>, и <i>Цель'</i> — утверждение той же степени общности, что и <i>Цель</i>, то <i>(не Цель)</i> это ложь;<br>   • если <i>Цель'</i> — это некоторое решение для <i>Цель</i>, и <i>Цель'</i> — более конкретное утверждение, чем <i>Цель</i>, то об утверждении <i>(не Цель)</i> нельзя сказать ничего определенного.<br>   Можно избежать всех этих осложнений, если потребовать, чтобы отрицания стояли только перед конкретизированными целями. Если правила базы знаний формулировать должным образом, то часто удается удовлетворить этому условию. Нам это удалось в "правиле поломки" (рис. 14.7):<br>   правило_поломки:<br>    если<br>     вкл( Прибор) и<br>     прибор( Прибор) и % Конкретизация<br>     не работает( Прибор) и<br>     соед( Прибор, Предохр) и<br>     доказано( цел( Предохр) )<br>    то<br>     доказано( неиспр( Прибор) ).<br>   Здесь условие<br>   прибор( Прибор)<br>   "защищает" следующее за ним условие<br>   не работает( Прибор)<br>   от неконкретизированной переменной.<br><h5>Упражнение</h5>   <b>14.3.</b> База знаний может, в принципе, содержать циклы. Например:<br>   прав1: если бутылка_пуста то джон_пьян.<br>   прав2: если джон_пьян то бутылка_пуста.<br>   Работая с подобной базой знаний, наша процедура рассмотреть может зациклиться на обработке одних и тех же целей. Внесите в процедуру рассмотреть изменения, предотвращающие зацикливание. Используйте для этого объект Трасса. Однако соблюдайте осторожность: если текущая цель <i>сопоставима</i> с одной из предыдущих целей, то такую ситуацию следует рассматривать как цикл только в том случае, когда текущая цель имеет большую, степень общности, чем предыдущая.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3456865"></a>14.6. Работа с неопределенностью <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3456871"></a>14.6.1. Степень достоверности<br></h4>
<div>   Наша оболочка экспертной системы, описанная в предыдущем разделе, может работать только с такими вопросами (утверждениями), которые либо истинны, либо ложны. Предметные области, в которых на любой вопрос можно ответить "правда" или "ложь", называются <i>категорическими</i>. Наши правила базы знания (также, как и данные) были категорическими, это были "категорические импликации". Однако многие области экспертных знаний не являются категорическими. Как правило, в заключениях эксперта много догадок (впрочем, высказанных с большой уверенностью), которые обычно верны, но могут быть и исключения. Как данные, относящиеся к конкретной задаче, так и импликации, содержащиеся в правилах, могут быть не вполне определенными. Неопределенность можно промоделировать, приписывая утверждениям некоторые характеристики, отличные от "<i>истина</i>" и "<i>ложь</i>". Характеристики могут иметь свое внешнее выражение в форме дескрипторов, таких, как, например, <i>верно</i>, <i>весьма вероятно</i>, <i>вероятно</i>, <i>маловероятно</i>, <i>невозможно</i>. Другой способ: степень уверенности может выражаться в форме действительного числа, заключенного в некотором интервале, например между 0 и 1 или между -5 и +5. Такую числовую характеристику называют по-разному — "коэффициент определенности", "степень доверия" или "субъективная уверенность". Более естественным было бы использовать вероятности (в математическом смысле слова), но попытки применить их на практике приводят к трудностям. Происходит это по следующим причинам:<br>   • Экспертам, по-видимому, неудобно мыслить в терминах вероятностей. Их оценки правдоподобия не вполне соответствуют математическому определению вероятностей.<br>   • Работа с вероятностями, корректная с точки зрения математики, потребовала бы или какой-нибудь недоступной информации, или каких-либо упрощающих допущений, не вполне оправданных с точки зрения практического приложения.<br>   Поэтому, даже если выбранная мера правдоподобия лежит в интервале 0 и 1, более правильным будет называть ее из осторожности "субъективной уверенностью", подчеркивая этим, что имеется в виду оценка, данная экспертом. Оценки эксперта не удовлетворяют всем требованиям теории вероятностей. Кроме того, вычисления над такими оценками могут отличаться от исчисления вероятностей. Но, несмотря на это, они могут служить вполне адекватной моделью того, как человек оценивает достоверность своих выводов.<br>   Для работы в условиях неопределенности было придумано множество различных механизмов. Мы будем рассматривать здесь механизм, используемый в системах Prospector и AL/X для минералогической разведки и локализации неисправностей соответственно. Следует заметить, что модель, применяемая в системе Prospector, несовершенна как с теоретической, так и с практической точек зрения. Однако она использовалась на практике, она проста и может служить хорошей иллюстрацией при изложении основных принципов, а потому вполне подойдет нам, по крайней мере для первого знакомства с этой областью. С другой стороны, известно, что даже в значительно более сложных моделях не обходится без трудностей. <br></div>
<h4 align="center">
<a name="TOC_id3456966"></a>14.6.2. Модель Prospector'а<br></h4>
<div>   Достоверность событий моделируется с помощью действительных чисел, заключенных в интервале между 0 и 1. Для простоты изложения мы будем называть их "вероятностями", хотя более точный термин "субъективная уверенность". Отношения между событиями можно представить графически в форме "сети вывода". На рис. 14.14 показан пример сети вывода. События изображаются прямоугольниками, а отношения между ними — стрелками. Овалами изображены комбинации событий (И, ИЛИ, НЕ).<br>   Мы будем считать, что отношения между событиями (стрелки) являются своего рода "мягкими импликациями". Пусть имеются два события <i>E</i> и <i>H</i>, и пусть информация о том, что имело место событие <i>E</i>, оказывает влияние на нашу уверенность в том, что произошло событие <i>H</i>. Если это влияние является "категорической импликацией", то можно просто написать<br>   если <i>E</i> то <i>H</i><br>   В случае же "мягкой импликации" это отношение может быть менее определенным, так что ему можно приписать некоторую "силу", с которой оно действует:<br>   если <i>E</i> то <i>H</i> с силой S<br>   Та сила, с которой достоверность <i>E</i> влияет на уверенность в <i>H</i>, моделируется в системе Prospector при помощи двух параметров:<br>   <i>N</i> = "коэффициент необходимости"<br>   <i>S</i>  = "коэффициент достаточности"<br><div align="center"><img border="1" src="_104.png"></div>   <b>Рис. 14.14.</b> Сеть вывода системы AL/X (заимствовано из Reiter (1980)). Числа, приписанные прямоугольникам, — априорные вероятности событий; числами на стрелках задается "сила" отношений между событиями.<br>   В сети вывода это изображается так:<br>   <i>E ------------&gt; H</i><br>   <i>       (N, S)</i><br>   Два события, участвующие в отношении, часто называют "фактом" и "гипотезой" соответственно. Допустим, что мы проверяем гипотезу <i>H</i>. Тогда мы будем искать такой факт <i>E</i>, который мог бы подтвердить либо опровергнуть эту гипотезу. <i>S</i> говорит нам, в какой степени <i>достаточно</i> факта <i>E</i> для подтверждения гипотезы <i>H</i>; <i>N</i> — насколько <i>необходим</i> факт <i>E</i> для подтверждения гипотезы <i>H</i>. Если факт <i>E</i> имел место, то чем больше <i>S</i>, тем больше уверенности в <i>H</i>. С другой стороны, если не верно, что имел место факт <i>E</i>, то чем больше <i>N</i>, тем менее вероятно, что гипотеза <i>H</i> верна. В случае, когда степень достоверности <i>E</i> находится где-то между полной достоверностью и невозможностью, степень достоверности <i>H</i> определяется при помощи интерполяции между двумя крайними случаями. Крайние случаи таковы:<br>   (1) известно, что факта <i>E</i> не было<br>   (2) известно, что факт <i>E</i> имел место<br>   (3) ничего не известно относительно <i>E</i><br>   Для каждого события <i>H</i> сети вывода существует априорная вероятность <i>р<sub>o</sub></i>(<i>H</i>) (безусловная) вероятность события <i>H</i> в состоянии, когда неизвестно ни одного положительного или отрицательного факта. Если становится известным какой-нибудь факт <i>E</i>, то вероятность <i>H</i> меняет свое значение с  <i>р<sub>o</sub></i>(<i>H</i>) на  <i>p</i>(<i>H|E</i>). Величина изменения зависит от "силы" стрелки, ведущей из <i>E</i> в <i>H</i>. Итак, мы начинаем проверку гипотез, принимая их априорные вероятности. В дальнейшем происходит накопление информации о фактах, что находит свое отражение в изменении вероятностей событий сети. Эти изменения распространяются по сети от события к событию в соответствии со связями между событиями. Например, рассмотрим рис. 14.14 и предположим, что получена информация о срабатывании индикатора открытия выпускного клапана. Эта информация повлияет на нашу уверенность в том, что выпускной клапан открылся, что, в свою очередь, повлияет на уверенность в том, что сместилась установка порогового давления.<br><div align="center"><img border="1" src="_105.png"></div>   <b>Рис. 14.15.</b> Правила распространения вероятностей по сети, принятые в системах Prospector и AL/X: (а) "мягкая импликация" с силой (<i>N</i>, <i>S</i>); (b) логические комбинации отношений.<br>   На рис. 14.15 показан один из способов реализации этого эффекта распространения информации по сети. Часть вычислений производится не над вероятностями, а над <i>шансами</i>. Это удобно, хотя в принципе и не обязательно. Между шансами и вероятностями имеет место простое соотношение:<br>   <i>шанс = вер / </i>(1<i> – вер</i>)<br>   <i>вер = шанс / </i>(1<i> + шанс</i>)<br>   Пусть между <i>E</i> и <i>H</i> существует отношение "мягкой импликации", тогда, в соответствии с рис. 14.15,<br>   <i>шанс</i>(<i>H|E</i>) <i>= M * шанс</i>(<i>H</i>)<br>   где множитель <i>M</i> определяется априорной и апостериорной вероятностями с учетом силы (<i>N, S</i>) связи между <i>E</i> и <i>H</i>. Предполагается, что правила Prospector'a (рис. 14.15) для вычисления вероятностей логических комбинаций событий (использующие <i>min</i> и <i>max</i>) правильно моделируют поведение человека при оценке субъективной уверенности в таких составных событиях. <br></div>
<h4 align="center">
<a name="TOC_id3457356"></a>14.6.3. Принципы реализации<br></h4>
<div>   Давайте сначала расширим правила языка, с тем чтобы получить возможность работать с неопределенностью. К каждому, правилу мы можем добавить "силовой модификатор", определяемый двумя неотрицательными действительными числами <i>S </i>и <i>N</i>. Вот соответствующий формат:<br>   Имя Правила: если<br>                 Условие<br>                то<br>                 Заключение<br>                с<br>                 Сила( N, S).<br>   Примеры правил рис. 14.14 можно изобразить в этой форме так:<br>   прав1 : если<br>            не давлоткр и<br>            открклап<br>           то<br>            открклрано<br>           с<br>            сила( 0.001, 2000).<br>
		 <br>   прав2 : если<br>            сепзапвд<br>           то<br>            давлоткр<br>           с<br>            сила( 0.05, 400).<br>   Для того, чтобы произвести соответствующее расширение оболочки экспертной системы (разд. 14.5), нам понадобится внести изменения в большинство процедур. Давайте сосредоточимся только на одной из них, а именно на процедуре<br>   рассмотреть( Цель, Трасса, Ответ)<br>   Мы предположим, что утверждение Цель не содержит переменных (как это сделано в Prospector'e и в AL/X). Это сильно упростит дело (особенно в процедуре ответпольз). Таким образом, Цель будет логической комбинацией элементарных утверждений. Например:<br>   не давлоткр и открклап<br>   Цепочку целей-предков и правил Трасса можно представить таким же способом, как это сделано в разд. 14.5. Однако форму представления объекта Ответ придется модифицировать для того, чтобы включить в нее вероятности. Цель и ее вероятность можно соединить в один терм следующим образом:<br>   Цель : Вероятность<br>   Получим такой пример объекта Ответ:<br>   индоткр : 1 было сказано<br>   Смысл ответа: пользователь сообщил системе, что событие индоткр произошло, и что это абсолютно достоверно.<br>   Представление объекта Ответ требует еще одной модификации, в связи с тем, что в одно и то же событие могут вести несколько независимых связей, которые все окажут влияние на вероятность этого события — его шанс будет помножен (рис. 14.15) на все множители. В этом случае Ответ будет содержать список всех ветвей вывода заключения. Приведем пример ответа такого рода для сети рис. 14.14 (для наглядности расположенный на нескольких строках):<br>   давлоткр : 1 было 'выведено по'<br>    [ прав2 из сепзапвд : 1 было сказано,<br>      прав5 из диагсеп : 1 было сказано ]<br>   Процедура рассмотреть, выдающая ответы в такой форме, показана на рис. 14.16. Она обращается к предикату<br>   импликация( Р0, P, Сила, Вер0, Вер)<br>   соответствующему отношению "мягкой импликации" (см. рис. 14.15). Р0 — априорная вероятность события <i>E</i>, а P — его апостериорная вероятность. Сила — сила импликации, представленная как<br>   сила( N, S)<br>   Вер0 и Вер — соответственно априорная и апостериорная вероятности гипотезы <i>H</i>.<br>   Следует заметить, что наша реализация очень проста, она обеспечивает только изменение вероятностей при распространении информации по сети вывода и иногда ведет себя недостаточно разумно. Никакого внимания не уделяется отбору для анализа наиболее важной в данный момент информации. В более сложной версии следовало бы направлять процесс поиска ответа в сторону наиболее существенных фактов. Кроме того, необходимо стремиться к тому, чтобы пользователю задавалось как можно меньше вопросов.<br>   Наконец, несколько замечаний относительно новой версии процедуры ответпольз. Она будет проще, чем процедура рис. 14.11, так как в запросах, передаваемых пользователю, уже не будет переменных. На этот раз пользователь в качестве ответа введет некоторую вероятность (вместо "да" или "нет"). Если пользователю ничего неизвестно о событии, содержащемся в вопросе, то вероятность этого события не изменится. Пользователь может также задать вопрос "почему" и получить изображение объекта Трасса в качестве объяснения. Кроме того, следует разрешить пользователю задавать вопрос: "Какова текущая вероятность моей гипотезы?" Тогда, если он устал вводить новую информацию (или у него мало времени), он может прекратить консультационный сеанс, довольствуясь ответом системы, полученным на основании неполной информации.<br>
		 <br>   % Процедура<br>   % рассмотреть( Цель, Трасса, Ответ)<br>   %<br>   % находит степень правдоподобия утверждения "цель это правда".<br>   % Оценка правдоподобия содержится в объекте Ответ. Трасса - это<br>   % цепочка целей-предшественников и правил, которую можно<br>   % использовать в объяснении типа "почему"<br>   рассмотреть( Цель, Трасса, ( Цель: Вер) было<br>    'выведено по' ПравОтв) :-<br>    bagof( Прав: если Условие то Цель с Сила, Правила),<br>     % Все правила, относящиеся к цели<br>    априори( Цель, Вер0),<br>     % Априорная вероятность цели<br>    модиф( Вер0, Правила, Трасса, Вер, ПравОтв).<br>     % Модифицировать априорные вероятности<br>   рассмотреть( Цель1 и Цель2, Трасса,<br>    ( Цель1 и Цель2 : Вер было 'выведено из'<br>      ( Ответ1 и Ответ2) ) :-<br>    !,<br>    рассмотреть( Цель1, Трасса, Ответ1),<br>    рассмотреть( Цель2, Трасса, Ответ2),<br>    вероятность( Ответ1, В1),<br>    вероятность( Ответ2, В2),<br>    мин( В1, В2, Вер).<br>   рассмотреть( Цель1 или Цель2, Трасса,<br>    ( Цель или Цель2:Вер) было 'выведено из'<br>      ( Ответ1 и Ответ2) ) :-<br>    !,<br>    рассмотреть( Цель1, Трасса, Ответ1),<br>    рассмотреть( Цель2, Трасса, Ответ2),<br>    вероятность( Ответ1, В1),<br>    вероятность( Ответ2, В2),<br>    макс( В1, В2, Вер).<br>   рассмотреть( не Цель, Трасса,<br>    ( не Цель:Вер) было 'выведено из' Ответ) :-<br>    !,<br>    рассмотреть( Цель, Трасса, Ответ),<br>    вероятность( Ответ, В),<br>    обратить( В, Вер).<br>   рассмотреть( Цель, Трасса, ( Цель: Вер) было сказано) :-<br>    ответпольз( Цель, Трасса, Вер).<br>
		 <br>   % Ответ, выведенный пользователем<br>   % Отношение<br>   %<br>   % модиф( Вер0, Правила, Трасса, Вер, ПравОтв)<br>   %<br>   % Существует Цель с априорной вероятностью Вер0. Правила имеют<br>   % отношение к утверждению Цель; суммарное влияние этих правил<br>   % (точнее, их условных частей) на Вер0 приводит к тому,<br>   % что Вер0 заменяется на апостериорную вероятность Вер;<br>   % Трасса - список целей-предков и правил, использовавшихся<br>   % при выводе утверждения Цель;<br>   % ПравОтв - результаты анализа условных частей<br>   % правил из списка Правила.<br>   модиф( Вер0, [], Трасса, Вер0, []).<br>     % Нет правил - нет модификации<br>   модиф( Вер0,<br>    [ Прав : если Усл то Цель с Сила | Правила],<br>    Трасса, Вер, [Прав из Ответ | ПравОтв] ):-<br>    рассмотреть( Усл, [Цель по Прав | Трасса], Ответ),<br>     % Условие из первого правила<br>    априори( Усл, В0),<br>    вероятность( Ответ, В),<br>    импликация( В0, В, Сила, Вер0, Вер1),<br>     % "Мягкая" импликация<br>    модиф( Вер1, Правила, Трасса, Вер, ПравОтв).<br>   <b>Рис. 14.16.</b> Определение степени правдоподобия гипотезы при помощи распространения информации об оценке уверенности по сети вывода.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3457932"></a>14.7. Заключительные замечания<br></h3>
<div>   Нашу оболочку экспертной системы можно развивать в целом ряде направлений. В данный момент уместно сделать несколько критических замечаний и высказать предложения по усовершенствованию нашей программы.<br>   В нашей программе, являющейся упрощенной реализацией, не уделено достаточного внимания вопросам эффективности. В более эффективной реализации потребовалось бы использовать более сложные структуры данных, ввести индексирование или иерархическую структуризацию множества правил и т.п.<br>   Наша процедура рассмотреть подвержена зацикливанию в тех случаях, когда в правилах базы знаний "циклически" упоминается одна и та же цель. Этот недостаток легко исправить, предусмотрев в рассмотреть соответствующий контроль, т.е. проверку, не является ли текущая цель частным случаем некоторой цели, уже введенной в состав объекта Трасса.<br>   Наше объяснение типа "как" выводит дерево доказательства целиком. В случае больших деревьев, удобнее было бы вывести только верхнюю часть дерева, а затем дать пользователю возможность "гулять" по остальной части дерева по своему желанию. Тогда пользователь смог бы просматривать дерево выборочным образом, используя команды, такие как "Вниз по ветви 1", "Вниз по ветви 2", …, "Вверх", "Достаточно".<br>   В объяснениях типа "как" и "почему" наша оболочка ссылается на правила, указывая их имена, и не показывает их в явном виде. Необходимо, чтобы во время консультационного сеанса пользователь мог, по желанию, запрашивать те или иные правила и получать их явные изображения.<br>   Известно, что придать диалогу с пользователем естественный характер при помощи умелой постановки вопросов - сложная задача. Наш способ ее решения работает только в определенных пределах и во многих случаях приводит к самым разным проблемам, например:<br>   <i>Это правда: сьюзен летает?</i><br>   <b>нет.</b><br>   <i>Это правда: сьюзен летает хорошо?</i><br>   Конечно же нет, раз она совсем не летает! Другой пример:<br>   <i>Есть (еще) решения для: Кто-нибудь летает?</i><br>   <b>да.</b><br>   <i>Кто-нибудь =</i> <b>птица</b>.<br>   <i>Это правда: альбатрос летает?</i><br>   Для того, чтобы справиться с подобными нежелательными эффектами, следует ввести в экспертную систему дополнительные отношения между понятиями вместе с механизмами их обработки. Обычно эти новые отношения задают иерархию объектов и их свойств.<br>   Возможно еще одно усовершенствование процедуры взаимодействия с пользователем, предусматривающее планирование оптимальной стратегии постановки вопросов. Целью оптимизации является минимизация количества вопросов, которые необходимо задать пользователю для достижения некоторого окончательного логического заключения. Разумеется, возникнут различные варианты таких стратегий, и то, какая из них окажется оптимальной, будет зависеть от ответов пользователя. Принятие решения о выборе той или иной альтернативной стратегии можно основывать на <i>априорных</i> вероятностях, являющихся вероятностными оценками "стоимостей" альтернатив. Величины оценок, возможно, придется пересчитывать после каждого ответа пользователя.<br>   Существует еще одна величина, поддающаяся оптимизации: длина цепочки вывода. Такая оптимизация позволила бы давать более простые объяснения типа "как". Сложность объяснений можно также уменьшить за счет селективного подхода к правилам. Некоторые из правил можно было бы не включать в состав объектов Трасса и Ответ, порождаемых процедурой рассмотреть. С этой целью необходимо указывать в базе знаний, какие из правил "трассируемы", а следовательно, должны появляться в объяснениях, а какие можно опускать.<br>   В "разумной" экспертной системе следует предусмотреть вероятностные механизмы, заставляющие ее концентрировать свое внимание на наиболее правдоподобных гипотезах среди всех конкурирующих между собой гипотез. Такая экспертная система должна запрашивать у пользователя ту информацию, которая позволила бы распознать наилучшую среди наиболее правдоподобных гипотез.<br>   Наша экспертная система была классификационного или "анализирующего" типа, в противоположность системам "синтезирующего" типа, в которых ставится задача <i>построить</i> что-либо. В последнем случае результат работы - это план действий, предпринимаемых для выполнения этой задачи, например план действий робота, компьютерная конфигурация, удовлетворяющая заданным требованиям, или форсированная комбинация в шахматах. Наш пример, относящийся к локализации неисправностей, можно естественным образом расширить, чтобы включить в рассмотрение действия. Например, если система не может прийти к определенному выводу, поскольку приборы выключены, она даст рекомендацию: "Включить лампу 3". Здесь сразу возникнет задача построения оптимального плана: минимизировать число действий, необходимых для достижения окончательного вывода.<br><h5>Проекты</h5>   Завершите программирование нашей оболочки в части, касающейся неопределенной информации (процедура ответпольз и другие).<br>   Рассмотрите перечисленные выше критические замечания, а также возможные расширения нашей экспертной системы. Разработайте и реализуйте соответствующие усовершенствования.<br></div>
<h3 align="center">
<a name="TOC_id3458127"></a>Резюме <br></h3>
<div>   • Обычно от экспертных систем требуют выполнения следующих функций:<br>     решение задач в заданной предметной области,<br>     объяснение процесса решения задач,<br>     работа с неопределенной и неполной информацией.<br>   • Удобно считать, что экспертная система со стоит из двух модулей: оболочки и базы знаний. Оболочка в свою очередь состоит из механизма логического вывода и интерфейса с пользователем.<br>   • При создании экспертной системы необходимо принять решения о выборе формального языка представления знаний, механизма логического вывода, средств взаимодействия с пользователем и способа работы в условиях неопределенности.<br>   • "Если-то"-правила, или продукции являются наиболее часто применяемой формой представления знаний в экспертных системах.<br>   • Оболочка, разработанная в данной главе, интерпретирует "если-то"-правила, обеспечивает выдачу объяснений типа "как" и "почему" и запрашивает у пользователя необходимую информацию.<br>   • Машина логического вывода была расширена для работы с неопределенной информацией.<br>   • В данной главе были обсуждены следующие понятия:<br>     экспертные системы<br>     база знаний, оболочка,<br>     машина логического вывода<br>     "если-то"-правила, продукции<br>     объяснения типа "как" и "почему"<br>     категорические знания, неопределенные знания<br>     сеть вывода,<br>     распространение оценок достоверности по сети<br><h5>Литература</h5>   Книга Michie (1979) - это сборник статей, относящихся к различным аспектам экспертных систем и инженерии знаний. Две ранние экспертные системы, оказавшие большое влияние на развитие этой области, MYCIN и Prospector, описаны в Shortliffe (1976) и Duda et al (1979). Книга Buchanan and Shortliffe (1984) является хорошим сборником статей, посвященных результатам экспериментов с системой MYCIN. Weiss and Kulikowski (1984) описывают свой практический опыт разработки экспертных систем. Вопрос о работе в условиях неопределенности еще нельзя считать вполне решенным: в статье Quinlan (1983) сравниваются различные подходы к этой проблеме. Способ разработки нашей экспертной системы до некоторой степени аналогичен описанному в Hammond (1984). Некоторые примеры, использовавшиеся в тексте, заимствованы из Winston (1984), Shortliffe (1976), Duda et al (1979), Bratko (1982) и Reiter (1980).<br>
		 <br>   Bratko I. (1982). Knowledge-based problem-solving in AL3. In: <i>Machine Intelligence 10</i> (J.E. Hayes, D. Michie, Y.H. Pao, eds.). Ellis Horwood.<br>   Buchanan B.G. and Shortliffe E.H. (1984, eds.). <i>Rule-based Expert Systems: The МYСIN Experiments of the Stanford Heuristic Programming Project.</i> Addison-Wesley.<br>   Duda R., Gasschnig J. and Hart P. (1979). Model design in the Prospector consultant system for mineral exploration. In: <i>Expert Systems in the Microelectronic Age</i> (D. Michie, ed.). Edinburgh University Press.<br>   Hammond P. (1984). vMicro-PROLOG for Expert Systems. In: <i>Micro-PROLOG: Programming in Logic</i> (K.L. Clark, F.G. McCabe, eds.). Prentice-Hall.<br>   Michie D. (1979, ed.). <i>Expert Systems in the Microelectronic Age.</i> Edinburgh University Press.<br>   Quinlan J.R. (1983). Inferno: a cautious approach to uncertain reasoning. <i>The Computer Journal</i> <b>26</b>: 255-270.<br>   Reiter J. (1980). AL/X: An Expert System Using Plausible Inference. Oxford: Intelligent Terminals Ltd.<br>   Shortliffe E. (1976). <i>Computer-based Medical Consultations: MYCIN.</i> Elsevier.<br>   Weiss S.M. and Kulikowski CA. (1984). <i>A Practical Guide to Designing Expert Systems.</i> Chapman and Hall.<br>   Winston P. H. (1984). <i>Artificial Intelligence</i> (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]<br></div>
</div>
<h2 align="center">
<a name="TOC_id3458291"></a>Глава 15<br>Игры<br></h2>
<div>
<div>   В этой главе мы рассмотрим методы программирования игр двух лиц с полной информацией (таких, как шахматы). Для игр, представляющих интерес, деревья возможных продолжений слишком велики, чтобы можно было говорить о полном переборе, поэтому необходимы какие-то другие подходы. Один из таких методов, основанный на минимаксном принципе, имеет эффективную реализацию, известную под названием "альфа-бета алгоритм". В дополнение к этому стандартному методу, мы разработаем в этой главе программу на основе Языка Советов (Advice Language), который дает возможность вносить в шахматную программу знания о типовых ситуациях. Этот довольно подробный пример может послужить еще одной иллюстрацией того, насколько хорошо Пролог приспособлен для реализации систем, основанных на знаниях.<br></div>
<h3 align="center">
<a name="TOC_id3458314"></a>15.1. Игры двух лиц с полной информацией<br></h3>
<div>   Игры, которые мы собираемся обсуждать в данной главе, относятся к классу так называемых игр двух лиц с полной информацией. Примерами таких игр могут служить шахматы, шашки и т.п. В игре участвуют два игрока, которые ходят по очереди, причем оба они обладают полной информацией о текущей игровой ситуации (это определение исключает большинство карточных игр). Игра считается оконченной, если достигнута позиция, являющаяся согласно правилам игры "терминальной" (конечной), например матовая позиция в шахматах. Правилами игры также устанавливается, каков исход игры в этой терминальной позиции.<br>   Для игр такого рода возможно представление в виде <i>дерева игры</i> (или <i>игрового дерева</i>). Вершины этого дерева соответствуют ситуациям, а дуги — ходам. Начальная ситуация игры — это корневая вершина; листьями дерева представлены терминальные позиции.<br>   В большинстве игр этого типа возможны следующие исходы: <i>выигрыш</i>, <i>проигрыш</i> и <i>ничья</i>. Мы будем рассматривать здесь игры, имеющие только два возможных исхода — <i>выигрыш</i> и <i>проигрыш</i>. Игры, в которых возможна ничья, можно упрощенно считать играми с двумя исходами — <i>выигрыш</i> и <i>не-выигрыш</i>. Двух участников игры мы будем называть "игроком" и "противником". "Игрок" может выиграть в некоторой нетерминальной позиции с ходом игрока ("позиции игрока"), если в ней существует <i>какой-нибудь</i> разрешенный ход, приводящий к выигрышу. С другой стороны, некоторая нетерминальная позиция с ходом противника ("позиция противника") является выигранной для игрока, если <i>все</i> разрешенные ходы из этой позиции ведут к позициям, в которых возможен выигрыш. Эти правила находятся в полном соответствии с представлением задач в форме И/ИЛИ-дерева, которое мы обсуждали в гл. 13. Между понятиями, относящимися к И/ИЛИ-деревьям, и понятиями, используемыми в играх, можно установить взаимное соответствие следующим образом:<br><br><table border="1" align="center">
<tr>
<td>позиции игры</td>
<td>вершины, задачи</td>
</tr>
<tr>
<td>терминальные позиции выигрыша</td>
<td>целевые вершины, тривиально решаемые задачи</td>
</tr>
<tr>
<td>терминальные позиции проигрыша</td>
<td>задачи, не имеющие решения</td>
</tr>
<tr>
<td>выигранные позиции</td>
<td>задачи, имеющие решение</td>
</tr>
<tr>
<td>позиции игрока</td>
<td>ИЛИ-вершины</td>
</tr>
<tr>
<td>позиции противника</td>
<td>И-вершины</td>
</tr>
</table>
<br>   Очевидно, что аналогичным образом понятия, относящиеся к поиску в И/ИЛИ-деревьях, можно переосмыслить в терминах поиска в игровых деревьях.<br>   Ниже приводится простая программа, которая определяет, является ли некоторая позиция игрока выигранной.<br>   выигр( Поз) :-<br>    терм_выигр( Поз).<br>     % Терминальная выигранная позиция<br>   выигр( Поз) :-<br>    not терм_проигр( Поз),<br>    ход( Поз, Поз1), % Разрешенный ход в Поз1<br>    not ( ход( Поз1, Поз2),<br>    not выигр( Поз2) ).<br>     % Ни один из ходов противника не ведет к не-выигрышу<br>   Здесь правила игры встроены в предикат ход( Поз, Поз1), который порождает все разрешенные ходы, а также в предикаты терм_выигр( Поз) и терм_проигр( Поз), которые распознают терминальные позиции, являющиеся, согласно правилам игры, выигранными или проигранными. В последнем из правил программы, содержащем двойное отрицание (not), говорится: не существует хода противника, ведущего к не выигранной позиции. Другими словами: <i>все</i> ходы противника приводят к позициям, выигранным с точки зрения игрока.<br><div align="center"><img border="1" src="_106.png"></div>   <b>Рис. 15.1.</b> Сложность игровых деревьев в шахматах. Оценки основаны на том, что в каждой шахматной позиции существуют приблизительно 30 разрешенных ходов я что терминальные позиции расположены на глубине 40 ходов. Один ход равен двум полуходам (по одному полуходу с каждой стороны).<br>   Так же, как и аналогичная программа поиска в И/ИЛИ-графах, приведенная выше программа использует стратегию в глубину. Кроме того, в ней не исключается возможность зацикливания на одних и тех же позициях. Попытка устранить этот недостаток может привести к осложнениям, поскольку правила некоторых из игр допускают такое повторение позиций. Правда, разрешение повторять позиции часто носит условный характер, например по шахматным правилам после троекратного повторения позиции может быть объявлена ничья.<br>   Программа, которую мы составили, демонстрирует основные принципы программирования игр. Но практически приемлемая реализация таких сложных игр, как шахматы или го, потребовала бы привлечения значительно более мощных методов. Огромная комбинаторная сложность этих игр делает наш наивный переборный алгоритм, просматривающий дерево вплоть до терминальных игровых позиций, абсолютно непригодным. Этот вывод иллюстрирует (на примере шахмат) рис. 15.1: пространство поиска имеет астрономические размеры — около 10<sup>120</sup> позиций. Можно возразить, что в дереве на рис. 15.1 встречаются одинаковые позиции. Однако было показано, что число различных позиций дерева поиска находится далеко за пределами возможностей вычислительных машин обозримого будущего.<br><h5>Проект</h5>   Напишите программу для какой-нибудь простой игры (такой, как <i>ним</i>), использующую упрощенный алгоритм войска в И/ИЛИ-дереве.<br></div>
<h3 align="center">
<a name="TOC_id3458569"></a>15.2. Минимаксный принцип<br></h3>
<div>   Для игр, представляющих интерес, полный просмотр игрового дерева невозможен, поэтому были разработаны другие методы, предусматривающие просмотр только части дерева игры. Среди этих методов существует страндартный метод поиска, используемый в игровых (особенно в шахматных) программах и основанный на <i>минимаксном</i> принципе. Дерево игры просматривается только вплоть до некоторой глубины (обычно на несколько ходов), а затем для всех концевых вершин дерева поиска вычисляются оценки при помощи некоторой оценочной функции. Идея состоит в том, чтобы, получив оценки этих терминальных поисковых вершин, не продвигаться дальше и получить тем самым экономию времени. Далее, оценки терминальных позиций распространяются вверх по дереву поиска в соответствии с минимаксным принципом. В результате все вершины дерева поиска получают свои оценки. И наконец, игровая программа, участвующая в некоторой реальной игре, делает свой ход — ход, ведущий из исходной (корневой) позиции в наиболее перспективного (с точки зрения оценки) ее преемника.<br>   Обратите внимание на то, что мы здесь делаем определенное различие между "деревом игры" и "деревом поиска". Дерево поиска — это только часть дерева игры (его верхняя часть), т.е. та его часть, которая была явным образом порождена в процессе поиска. Таким образом, терминальные поисковые позиции совсем не обязательно должны совпадать с терминальными позициями самой игры.<br>   Очень многое зависит от оценочной функции, которая для большинства игр, представляющих интерес, является приближенной эвристической оценкой шансов на выигрыш одного из участников игры. Чем выше оценка, тем больше у него шансов выиграть и чем ниже оценка, тем больше шансов на выигрыш у его противника. Поскольку один из участников игры всегда стремится к высоким оценкам, а другой — к низким, мы дадим им имена МАКС и МИН соответственно. МАКС всегда выбирает ход с максимальной оценкой; в противоположность ему МИН всегда выбирает ход с минимальной оценкой. Пользуясь этим принципом (<i>минимаксным</i> принципом) и зная значения оценок для всех вершин "подножья" дерева поиска, можно определить оценки всех остальных вершин дерева. На рис. 15.2 показано, как это делается. На этом рисунке видно, что уровни позиций с ходом МАКС'а чередуются с уровнями позиций с ходом МИН'а. Оценки вершин нижнего уровня определяются при помощи оценочной функции. Оценки всех внутренних вершин можно определить, двигаясь снизу вверх от уровня к уровню, пока мы не достигнем корневой вершины. В результате, как видно из рис. 15.2, оценка корня оказывается равной 4, и, соответственно, лучшим ходом МАКС'а из позиции <i>а</i> — <i>a-b</i>. Лучший ответ МИН'а на этот ход — <i>b-d</i>, и т.д. Эту последовательность ходов называют также <i>основным вариантом</i>. Основной вариант показывает, какова "минимаксно-оптимальная" игра для обоих участников. Обратите внимание на то, что оценки всех позиций, входящих в основной вариант, совпадают.<br><div align="center"><img border="1" src="_107.png"></div>   <b>Рис. 15.2.</b> Статические (нижний уровень) и минимаксные рабочие оценки вершин дерева поиска. Выделенные ходы образуют <i>основной вариант</i>, т.е. минимаксно-оптимальную игру с обеих сторон.<br>   Мы различаем два вида оценок: оценки вершин нижнего уровня и оценки внутренних вершин (рабочие оценки). Первые из них называются также "статическими", так как они вычисляются при помощи "статической" оценочной функции, в противоположность рабочим оценкам, получаемым "динамически" при распространении статических оценок вверх по дереву.<br>   Правила распространения оценок можно сформулировать следующим образом. Будем обозначать статическую оценку позиции <i>P </i>через <i>v</i>(<i>P</i>), а ее рабочую оценку — через <i>V</i>(<i>P</i>). Пусть <i>P<sub>1</sub></i>, …, <i>Р<sub>n</sub></i> — разрешенные преемники позиции <i>P</i>. Тогда соотношения между статическими и рабочими оценками можно записать так:<br>   <i>V</i>(<i>P</i>)<i> = v</i>(<i>P</i>)<br>   если <i>P</i> — терминальная позиция дерева поиска (<i>n=</i>0)<br>    <img border="0" src="img_4.png"><br>   если <i>P</i> — позиция с ходом МАКС'а<br>    <img border="0" src="img_5.png"><br>   если <i>P</i> — позиция с ходом МИН'а<br>
		 <br>   % Минимаксная процедура: минимакс( Поз, ЛучшПоз, Оц)<br>   % Поз - позиция, Оц - ее минимаксная оценка;<br>   % лучший ход из Поз ведет в позицию ЛучшПоз<br>   минимакс( Поз, ЛучшПоз, Оц) :-<br>    оды( Поз, СписПоз), !,<br>     % СписПоз - список разрешенных ходов<br>    лучш( СписПоз, ЛучшПоз, Оц);<br>    стат_оц( Поз, Оц). % Поз не имеет преемников<br>
		 <br>   лучш( [Поз], Поз, Оц) :-<br>    минимакс( Поз, _, Оц), !.<br>   лучш( [Поз1 | СписПоз], ЛучшПоз, ЛучшОц) :-<br>    минимакс( Поз1, _, Оц1),<br>    лучш( СписПоз, Поз2, Оц2),<br>    выбор( Поз1, Оц1, Поз2, Оц2, ЛучшПоз, ЛучшОц).<br>
		 <br>   выбор( Поз0, Оц0, Поз1, Оц1, Поз0, Оц0) :-<br>    ход_мина( Поз0), Оц &gt; Оц1, !;<br>    ход_макса( Поз0), Оц &lt; Оц1, !.<br>   выбор( Поз0, Оц0, Поз1, Оц1, Поз1, Оц1).<br>   <b>Рис. 15.3.</b> Упрощенная реализация минимаксного принципа.<br>
		 <br>   Программа на Прологе, вычисляющая минимаксную рабочую оценку для некоторой заданной позиции, показана на рис. 15.3. Основное отношение этой программы —<br>   минимакс( Поз, ЛучшПоз, Оц)<br>   где Оц — минимаксная оценка позиции Поз, а ЛучшПоз — наилучшая позиция-преемник позиции Поз (лучший ход, позволяющий достигнуть оценки Оц). Отношение<br>   ходы( Поз, СписПоз)<br>   задает разрешенные ходы игры: СписПоз — это список разрешенных позиций-преемников позиции Поз. Предполагается, что цель ходы имеет неуспех, если Поз является терминальной поисковой позицией (листом дерева поиска). Отношение<br>   лучш( СписПоз, ЛучшПоз, ЛучшОц)<br>   выбирает из списка позиций-кандидатов СписПоз "наилучшую" позицию ЛучшПоз. ЛучшОц — оценка позиции ЛучшПоз, а следовательно, и позиции Поз. Под "наилучшей" оценкой мы понимаем либо максимальную, либо минимальную оценку, в зависимости от того, с чьей стороны ожидается ход.<br></div>
<h3 align="center">
<a name="TOC_id3458949"></a>15.3. Альфа-бета алгоритм: эффективная реализация минимаксного принципа<br></h3>
<div>   Программа, показанная на рис. 15.3, производит просмотр в глубину дерева поиска, систематически обходя <i>все</i> содержащиеся в нем позиции вплоть до терминальных; она вычисляет статические оценки <i>всех</i> терминальных позиций. Как правило, для того, чтобы получить правильную минимаксную оценку корневой вершины, совсем не обязательно проделывать эту работу полностью. Поэтому алгоритм поиска можно сделать более экономным. Его можно усовершенствовать, используя следующую идею. Предположим, что у нас есть два варианта хода. Как только мы узнали, что один из них явно хуже другого, мы можем принять правильное решение, не выясняя, на сколько <i>в точности</i> он хуже. Давайте используем этот принцип для сокращения дерева поиска рис. 15.2. Процесс поиска протекает следующим образом:<br>   (1) Начинаем с позиции <i>а</i>.<br>   (2) Переходим к <i>b</i>.<br>   (3) Переходим к <i>d</i>.<br>   (4) Берем максимальную из оценок преемников позиции <i>d</i>, получаем <i>V(d) =</i> 4.<br>   (5) Возвращаемся к <i>b</i> и переходим к  <i>e</i>.<br>   (6) Рассматриваем первого преемника позиции <i>e</i> с оценкой 5. В этот момент МАКС (который как раз и должен ходить в позиции <i>e</i>) обнаруживает, что ему гарантирована в позиции <i>e</i> оценка не меньшая, чем 5, независимо от оценок других (возможно, более предпочтительных) вариантов хода. Этого вполне достаточно для того, чтобы МИН, даже не зная точной оценки позиции <i>e</i>, понял, что для него в позиции <i>b</i> ход в <i>e</i> хуже, чем ход в <i>d</i>.<br>   На основании приведенного выше рассуждения мы можем пренебречь вторым преемником позиции <i>e</i> и приписать <i>e приближенную</i> оценку 5. Приближенный характер этой оценки не окажет никакого влияния на оценку позиции <i>b</i>, а следовательно, и позиции <i>а</i>.<br>   На этой идее основан знаменитый <i>альфа-бета алгоритм</i>, предназначенный для эффективной реализации минимаксного принципа. На рис. 15.4 показан результат работы альфа-бета алгоритма, примененного к нашему дереву рис. 15.2. Из рис. 15.4 видно, что некоторые из рабочих оценок стали приближенными. Однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную оценку корневой позиции. Сложность поиска уменьшилась до пяти обращений к оценочной функции по сравнению с восемью обращениями (в первоначальном дереве поиска рис. 15.2).<br>   Как уже говорилось раньше, ключевая идея альфа-бета отсечения состоит в том, чтобы найти ход не обязательно лучший, но "достаточно хороший" для того, чтобы принять правильное решение. Эту идею можно формализовать, введя два граничных значения, обычно обозначаемых через <i>Альфа</i> и <i>Бета</i>, между которыми должна заключаться рабочая оценка позиции. Смысл этих граничных значений таков: <i>Альфа</i> — это самое маленькое значение оценки, которое к настоящему моменту уже гарантировано для игрока МАКС; <i>Бета</i> — это самое большое значение оценки, на которое МАКС пока еще может надеяться. Разумеется, с точки зрения МИН'а, <i>Бета</i> является самым худшим значением оценки, которое для него уже гарантировано. Таким образом, действительное значение оценки (т.е. то, которое нужно найти) всегда лежит между <i>Альфа</i> и <i>Бета</i>. Если же стало известно, что оценка некоторой позиции лежит вне интервала <i>Альфа-Бета</i>, то этого достаточно для того, чтобы сделать вывод: данная позиция не входит в основной вариант. При этом точное значение оценки такой позиции знать не обязательно, его надо знать только тогда, когда оценка лежит между <i>Альфа</i> и <i>Бета</i>. "Достаточно хорошую" рабочую оценку  <i>V( P, Альфа, Бета)</i>  позиции <i>P</i> по отношению к <i>Альфа</i> и <i>Бета</i> можно определить формально как любое значение, удовлетворяющее следующим ограничениям:<br>   <i>V( P, Альфа, Бета) &#8804;  Альфа</i> если <i>V( P) &#8804; Альфа</i><br>   <i>V( P, Альфа, Бета) = V( P)</i> если <i>Альфа &lt; V( P) &lt; Бета</i><br>   <i>V( P, Альфа, Бета) &#8805; Бета</i> если <i>V( P) &#8805; Бета</i><br><div align="center"><img border="1" src="_108.png"></div>   <b>Рис. 15.4.</b> Дерево рис. 15.2 после применения альфа-бета алгоритма. Пунктиром показаны ветви, отсеченные альфа-бета алгоритмом для экономии времени поиска. В результате некоторые из рабочих оценок стали приближенными (вершины <i>c</i>, <i>e</i>, <i>f</i>; сравните с рис. 15.2). Однако этих приближенных оценок достаточно для вычисления точной оценки корневой вершины и построения основного варианта.<br>   Очевидно, что, умея вычислять "достаточно хорошую" оценку, мы всегда можем вычислить точную оценку корневой позиции <i>P</i>, установив границы интервала следующим образом:<br>   <i>V( P, -бесконечность, +бесконечность)  =  V( P)</i><br>   На рис. 15.5 показана реализация альфа-бета алгоритма в виде программы на Прологе. Здесь основное отношение —<br>   альфабета( Поз, Альфа, Бета, ХорПоз, Оц)<br>   где ХорПоз — преемник позиции Поз с "достаточно хорошей" оценкой Оц, удовлетворяющей всем указанным выше ограничениям:<br>   Оц<i>= V( Поз, Альфа, Бета)</i><br>   Процедура<br>   прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц)<br>   находит достаточно хорошую позицию ХорПоз в списке позиций СписПоз; Оц — приближенная (по отношению к Альфа и Бета) рабочая оценка позиции ХорПоз.<br>   Интервал между <i>Альфа</i> и <i>Бета</i> может сужаться (но не расширяться!) по мере углубления поиска, происходящего при рекурсивных обращениях к альфа-бета процедуре. Отношение<br>   нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета)<br>   определяет новый интервал (НовАльфа, НовБета). Он всегда уже, чем старый интервал (Альфа, Бета), или равен ему. Таким образом, чем глубже мы оказываемся в дереве поиска, тем сильнее проявляется тенденция к сжатию интервала <i>Альфа-Бета</i>, и в результате оценивание позиций на более глубоких уровнях происходит в условиях более тесных границ. При более узких интервалах допускается большая степень "приблизительности" при вычислении оценок, а следовательно, происходит больше отсечений ветвей дерева. Возникает интересный вопрос: насколько велика экономия, достигаемая альфа-бета алгоритмом по сравнению с программой минимаксного полного перебора рис. 15.3?<br>
		 <br>   % Альфа-бета алгоритм<br>   альфабета( Поз, Альфа, Бета, ХорПоз, Оц) :-<br>    ходы( Поз, СписПоз), !,<br>    прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц);<br>    стат_оц( Поз, Оц).<br>
		 <br>   прибл_лучш( [Поз | СписПоз], Альфа, Бета, ХорПоз, ХорОц) :-<br>    альфабета( Поз, Альфа, Бета, _, Оц),<br>    дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц).<br>
		 <br>   дост_хор( [], _, _, Поз, Оц, Поз, Оц) :- !.<br>    % Больше нет кандидатов<br>   дост_хор( _, Альфа, Бета, Поз, Оц, Поз, Оц) :-<br>    ход_мина( Поз), Оц &gt; Бета, !;<br>     % Переход через верхнюю границу<br>    ход_макса( Поз), Оц &lt; Альфа, !.<br>     % Переход через нижнюю границу<br>   дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц) :-<br>    нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета),<br>     % Уточнить границы<br>    прибл_лучш( СписПоз, НовАльфа, НовБета, Поз1, Оц1),<br>    выбор( Поз, Оц, Поз1, Оц1, ХорПоз, ХорОц).<br>
		 <br>   нов_границы( Альфа, Бета, Поз, Оц, Оц, Бета) :-<br>    ход_мина( Поз), Оц &gt; Альфа, !.<br>     % Увеличение нижней границы<br>   нов_границы( Альфа, Бета, Поз, Оц, Альфа, Оц) :-<br>    ход_макса( Поз), Оц &lt; Бета, !.<br>     % Уменьшение верхней границы<br>   нов_границы( Альфа, Бета, _, _, Альфа, Бета).<br>
		 <br>   выбор( Поз, Оц, Поз1, Оц1, Поз, Оц) :-<br>    ход_мина( Поз), Оц &gt; Оц1, !;<br>    ход_макса( Поз), Оц &lt; Оц1, !.<br>   выбор( _, _, Поз1, Оц1, Поз1, Оц1).<br>   <b>Рис. 15.5.</b> Реализация альфа-бета алгоритма.<br>
		 <br>   Эффективность альфа-бета процедуры зависит от порядка, в котором просматриваются позиции. Всегда лучше первыми рассматривать самые сильные ходы с каждой из сторон. Легко показать на примерах, что возможен настолько неудачный порядок просмотра, что альфа-бета алгоритму придется пройти через <i>все</i> вершины, которые просматривались минимаксным алгоритмом полного перебора. Это означает, что в худшем случае альфа-бета алгоритм не будет иметь никаких преимуществ. Однако, если порядок просмотра окажется удачным, то экономия может быть значительной. Пусть <i>N</i> — число терминальных поисковых позиций, для которых вычислялись статические оценки алгоритмом минимаксного полного перебора. Было доказано, что в лучшем случае, когда самые сильные ходы всегда рассматриваются первыми, альфа-бета алгоритм вычисляет статические оценки только для <i>N</i> позиций.<br>   Этот результат имеет один практический аспект, связанный с проведением турниров игровых программ. Шахматной программе, участвующей в турнире, обычно дается некоторое определенное время для вычисления очередного хода, и доступная программе глубина поиска зависит от этого времени. Альфа-бета алгоритм сможет пройти при поиске <i>вдвое глубже</i> по сравнению с минимаксным полным перебором, а опыт показывает, что применение той же оценочной функции, но на большей глубине приводит к более сильной игре.<br>   Экономию, получаемую за счет применения альфа-бета алгоритма, можно также выразить в терминах более эффективного коэффициента ветвления дерева поиска (т.е. числа ветвей, исходящих из каждой внутренней вершины). Пусть игровое дерево имеет единый коэффициент ветвления, равный <i>b</i>. Благодаря эффекту отсечения альфа-бета алгоритм просматривает только некоторые из существующих ветвей и тем самым уменьшает коэффициент ветвления. В результате коэффициент <i>b</i> превратится в <i>b</i> (в лучшем случае). В шахматных программах, использующих альфа-бета алгоритм, достигается коэффициент ветвления, равный 6, при наличии 30 различных вариантов хода в каждой позиции. Впрочем, на этот результат можно посмотреть и менее оптимистично: несмотря на применение альфа-бета алгоритма, после каждого продвижения вглубь на один полуход число терминальных поисковых вершин увеличивается примерно в 6 раз.<br><h5>Проект</h5>   Рассмотрите какую-нибудь игру двух лиц (например, какой-нибудь нетривиальный вариант крестиков-ноликов). Напишите отношения, задающие правила этой игры (разрешенные ходы и терминальные позиции). Предложите статическую оценочную функцию, пригодную для использования в игровой программе, основанной на альфа-бета алгоритме.<br></div>
<h3 align="center">
<a name="TOC_id3459573"></a>15.4. Минимаксные игровые программы: усовершенствования и ограничения<br></h3>
<div>   Минимаксный принцип и альфа-бета алгоритм лежат в основе многих удачных игровых программ, чаще всего шахматных. Общая схема подобной программы такова: произвести альфа-бета поиск из текущей позиции вплоть до некоторого предела по глубине (диктуемого временными ограничениями турнирных правил). Для оценки терминальных поисковых позиций использовать подобранную специально для данной игры оценочную функцию. Затем выполнить на игровой доске наилучший ход, найденный альфа-бета алгоритмом, принять ответный ход противника и запустить тот же цикл с начала.<br>   Таким образом, две основных составляющих игровой программы — это альфа-бета алгоритм и эвристическая оценочная функция. Для того, чтобы создать действительно хорошую программу для такой сложной игры, как шахматы, необходимо внести в эту базовую схему много различных усовершенствований. Ниже приводится краткое описание некоторых из стандартных приемов.<br>   Многое зависит от оценочной функции. Если бы мы располагали абсолютно точной оценочной функцией, мы могли бы ограничить поиск рассмотрением только непосредственных преемников текущей позиции, фактически исключив перебор. Но для таких игр, как шахматы, любая оценочная функция, имеющая практически приемлемую вычислительную сложность, по необходимости будет всего лишь эвристической оценкой. Такая оценка базируется на "статических" свойствах позиции (например, на количестве фигур) и в одних позициях работает надежнее, чем в других. Допустим, например, что мы имеем именно такую оценочную функцию, основанную на соотношении материала, и представим себе позицию, в которой у белых лишний конь. Ясно, что оценка будет в пользу белых. Здесь все в порядке, если позиция "спокойная" и черные не располагают какой-либо сильной угрозой. Но, с другой стороны, если на следующем ходу черные могут взять белого ферзя, то такая оценка может привести к фатальному просмотру из-за своей неспособности к <i>динамическому</i> восприятию позиции. Очевидно, что в спокойных позициях мы можем доверять такой статической оценке в большей степени, чем в активных позициях, когда с каждой из сторон имеются непосредственные угрозы взятия фигур. Поэтому статическую оценку следует использовать только для спокойных позиций. Что же касается активных позиций, то здесь существует такой стандартный прием: следует продолжить поиск из активной позиции за пределы ограничения по глубине и продолжать его до тех пор, пока не встретится спокойная позиция. В частности, таким образом производится просчет разменов фигур в шахматах.<br>   Еще одно усовершенствование — <i>эвристическое отсечение</i> (ветвей). Целью его является достижение большей предельной глубины поиска за счет отбрасывания менее перспективных продолжений. Этот метод позволяет отсекать ветви в дополнение к тем, которые отсекаются самим альфа-бета алгоритмом. В связи с этим возникает риск пропустить какое-нибудь хорошее продолжение и неправильно вычислить минимаксную оценку.<br>   Существует еще один прием, называемый <i>последовательным углублением</i>. Программа многократно выполняет альфа-бета поиск сначала до некоторой небольшой глубины, а затем, увеличивая предел по глубине при каждой итерации. Процесс завершается, когда истекает время, отведенное для вычисления очередного хода. Выполняется наилучший ход, найденный при наибольшей глубине, достигнутой программой. Этот метод имеет следующие преимущества:<br>   • он облегчает контроль времени: в момент, когда время истекает, всегда имеется некоторый ход — лучший из всех, найденных к настоящему моменту;<br>   • минимаксные оценки, вычисленные во время предыдущей итерации, можно использовать для предварительного упорядочивания позиций в следующей итерации, что помогает альфа-бета алгоритму следовать стратегии "самые сильные ходы — первыми".<br>   Метод последовательного углубления влечет за собой некоторые накладные расходы (из-за повторного поиска в верхней части игрового дерева), но они незначительны по сравнению c суммарными затратами.<br>   Для наших программ, основанных на описанной выше схеме, существует проблема, известная как "эффект горизонта". Представьте себе шахматную позицию, в которой программе грозит неминуемая потеря коня, однако эту потерю можно отложить, пожертвовав какую-либо менее ценную фигуру, скажем пешку. Эта немедленная жертва сможет отодвинуть потерю коня за пределы доступной глубины поиска (за "горизонт" программы). Не видя грозящей опасности, программа отдаст предпочтение продолжению с жертвой пешки, чтобы избежать быстрой гибели своего коня. В действительности программа потеряет <i>обе</i> фигуры — и пешку (без необходимости), и коня. Эффект горизонта можно несколько смягчить за счет углубления поиска вплоть до спокойных позиций.<br>   Существует, однако, более фундаментальное ограничение на возможности минимаксных игровых программ, проистекающее из той ограниченной формы представления знаний, которая в них используется. Это становится особенно заметным при сравнении лучших шахматных программ с шахматными мастерами (людьми). Хорошая программа просматривает миллионы (и даже больше) позиций, прежде чем принимает решение об очередном ходе. Психологические опыты показали, что шахматные мастера, как правило, просматривают десятки (максимум, несколько сотен) позиций. Несмотря на эту явно меньшую производительность, мастера-шахматисты обыгрывают программы без особых усилий. Преимущество их состоит в их знаниях, значительно превосходящих знания шахматных программ. Игры между машинами и сильными шахматистами показали, что огромное превосходство в вычислительной мощности не способно скомпенсировать недостаток знаний.<br>   Знания в минимаксных игровых программах имеют следующие три основные формы:<br>   • оценочная функция<br>   • эвристики для отсечения ветвей<br>   • эвристики для распознавания спокойных позиций<br>   Оценочная функция сводит все разнообразные аспекты игровой ситуации к одному числу, и это упрощение может нанести вред. В противоположность этому хороший игрок обладает пониманием позиции, охватывающим многие "измерения". Вот пример из области шахмат: оценочная функция оценивает позицию как равную и выдает значение 0. Оценка той же позиции, данная мастером-шахматистом, может быть значительно более информативной, а также может указывать на дальнейший ход игры, например: у белых лишняя пешка, но черные имеют неплохие атакующие возможности, что компенсирует материальный перевес, следовательно, шансы равны.<br>   Минимаксные шахматные программы часто хорошо проявляют себя в острой тактической борьбе, когда решающее значение имеет точный просчет форсированных вариантов. Их слабости обнаруживаются в спокойных позициях, так как они не способны к долговременному планированию, преобладающему при медленной, стратегической игре. Из-за отсутствия плана создается внешнее впечатление, что программа все время перескакивает с одной идеи" на другую. Особенно это заметно в эндшпилях.<br>   В оставшейся части главы мы рассмотрим еще один подход к программированию игр, основанный на внесении в программу знаний о типовых ситуациях при помощи так называемых "советов".<br></div>
<h3 align="center">
<a name="TOC_id3459744"></a>15.5. Знания о типовых ситуациях и механизм "советов"<br></h3>
<div>
<div>   В этом разделе рассматривается метод представления знаний о конкретной игре с использованием семейства Языков Советов. Языки Советов (Advice Languages) дают возможность пользователю декларативным способом описывать, какие идеи следует использовать в тех или иных типовых ситуациях. Идеи формулируются в терминах целей и средств, необходимых для их достижения. Интерпретатор Языка Советов определяет при помощи перебора, какая идея "работает" в данной ситуации.<br></div>
<h4 align="center">
<a name="TOC_id3459761"></a>15.5.1. Цели и ограничения на ходы<br></h4>
<div>   Основное понятие Языка Советов — "элементарный совет". Элементарный совет содержит указание о том, что следует делать (или <i>пытаться</i> делать) в некоторой типовой ситуации. Совет выражается в терминах тех <i>целей</i>, которые необходимо достичь, и тех <i>средств</i>, которые следует применять для этого. Мы называем участников игры "игроком" и "противником"; совет всегда относится к "игроку". Каждый элементарный совет имеет следующие четыре составные части:<br>   • <i>главная цель</i>: цель, к которой нужно стремиться;<br>   • <i>цель-поддержка</i>: цель, которая должна постоянно удовлетворяться в процессе достижения главной цели;<br>   • <i>ограничения на ходы игрока</i>: предикат, определяющий некоторое подмножество ходов из всех разрешенных ходов игрока (ходы, представляющие интерес с точки зрения достижения указанных целей).<br>   • <i>ограничения на ходы противника</i>: предикат, выбирающий ходы, которые должен рассмотреть противник (ходы, препятствующие достижению указанных целей).<br>   Рассмотрим, например, шахматный эндшпиль "король и пешка против короля". Здесь применима следующая очевидная идея: провести пешку в ферзи, продвигая ее вперед. В форме совета это выражается так:<br>   • <i>главная цель</i>: провести пешку;<br>   • <i>цель-поддержка</i>: не потерять пешку;<br>   • <i>ходы игрока</i>: продвигать пешку;<br>   • <i>ходы противника</i>: приближаться королем к пешке. <br></div>
<h4 align="center">
<a name="TOC_id3459853"></a>15.5.2. Выполнимость совета<br></h4>
<div>   Мы говорим, что элементарный совет <i>выполним</i> в данной позиции, если игрок может форсированным образом достигнуть главной цели, указанной в совете, при условии, что:<br>   (1) ни разу не нарушается цель-поддержка;<br>   (2) все ходы игрока удовлетворяют наложенным на них ограничениям;<br>   (3) противнику разрешено делать только те ходы, которые предусмотрены соответствующими ограничениями.<br>   С выполнимостью элементарного совета связано понятие <i>форсированного дерева</i>. Форсированное дерево задает детальную стратегию, которая гарантирует достижение главной цели при выполнении всех ограничений, содержащихся в элементарном совете. Таким образом, форсированное дерево указывает, как именно должен ходить игрок при любых ответах противника. Более точно, форсированное дерево T для заданной позиции P и элементарного совета А есть такое поддерево дерева игры, что<br>   • корень дерева T — позиция P;<br>   • все позиции из T удовлетворяют цели-поддержке;<br>   • все терминальные позиции из T удовлетворяют главной цели (что, однако, неверно ни для одной внутренней вершины);<br>   • для каждой внутренней позиции игрока в дереве T указан только один ход, причем он удовлетворяет ограничениям на ходы игрока;<br>   • из каждой внутренней позиции противника исходят все ходы противника (удовлетворяющие соответствующим ограничениям).<br>   Каждый элементарный совет можно рассматривать как описание некоторой небольшой специальной игры, имеющей следующие правила. Участникам игры разрешено ходить в пределах ограничений, наложенных на их ходы; позиция, не удовлетворяющая цели-поддержке, считается выигрышем "противника". Нетерминальная позиция считается выигранной с точки зрения игрока, если данный элементарный совет в ней выполним. Таким образом, для того, чтобы выиграть в этой игре, игрок должен следовать стратегии, задаваемой форсированным деревом. <br></div>
<h4 align="center">
<a name="TOC_id3459922"></a>15.5.3. Правила и таблицы советов<br></h4>
<div>   В Языках Советов отдельные элементарные советы объединяются в полную схему представления знаний, имеющую следующую иерархическую структуру. Элементарный совет является частью "если-то"-правила. Набор "если-то"-правил образует <i>таблицу советов</i>. Множество таблиц советов имеет структуру иерархической сети. Каждая таблица советов выполняет роль эксперта в своей узкой области и работает с какой-нибудь специфической подзадачей. Примером такого специализированного эксперта может служить таблица советов, содержащая знания о том, как поставить мат королем и ладьей. Эта таблица вызывается в том случае, когда в процессе игры возникает соответствующее окончание.<br>   Мы рассмотрим здесь упрощенную версию Языка Советов, допускающую только одну таблицу советов. Будем называть эту версию Язык Советов 0 или, для краткости, AL0 (Advice Language 0). Ниже описывается структура языка AL0, синтаксически специально приспособленная для удобной реализации на Прологе.<br>   Программа на AL0 называется <i>таблицей советов</i>. Таблица советов представляет из себя <i>упорядоченное</i> множество "если-то"-правил. Каждое правило имеет вид:<br>   ИмяПравила: если Условие то СписокСоветов<br>   Условие — это логическое выражение, состоящее из имен предикатов, соединенных между собой логическими связками и, или, не.  СписокСоветов — список имен элементарных советов. Приведем пример правила под названием "правило_края" из окончания "король и ладья против короля":<br>   правило_края:<br>    если король_противника_на_краю и короли_рядом<br>    то [мат_2, потеснить, приблизиться,<br>        сохранить_простр, отделить].<br>   В этом правиле говорится: если в текущей позиции король противника находится на краю доски, а король игрока расположен близко к королю противника (точнее, расстояние между королями меньше четырех клеток), то попытаться выполнить в указанном порядке предпочтения следующие советы: "мат_2", "потеснить", "приблизиться", "сохранить_простр", "отделить". Элементарные советы расположены в порядке убывания их "притязаний" на успех: сначала попытаться поставить мат в два хода, если не получится — "потеснить" короля противника в угол и т.д. Обратите внимание на то, что при соответствующем определении операторов наше правило станет синтаксически корректным предложением Пролога.<br>   Для представления элементарных советов в виде прологовских предложений предназначен еще один формат:<br>   совет( ИмяСовета,<br>          ГлавнаяЦель:<br>          ЦельПоддержка:<br>          ХодыИгрока:<br>          ХодыПротивника).<br>   Цели представляются как выражения, состоящие из имен предикатов и логических связок и, или, не.  Ограничения на ходы сторон — это тоже выражения, состоящие из имен предикатов и связок и и затем: связка и имеет обычный логический смысл, а затем задает порядок. Например, ограничение, имеющее вид<br>   Огр1 затем Огр2<br>   означает: сначала рассмотреть ходы, удовлетворяющие ограничению Oгp1, а затем — ходы, удовлетворяющие Огр2.<br>   Например, элементарный совет, относящийся к мату в два хода в окончании "король и ладья против короля", записанный в такой синтаксической форме, имеет вид:<br>   совет( мат_2,<br>          мат:<br>          не потеря_ладьи:<br>          (глубина = 0) и разреш затем<br>          (глубина = 2) и ход_шах :<br>          (глубина = 1) и разреш ).<br>   Здесь главная цель — мат, цель-поддержка не потеря_ладьи. Ограничение на ходы игрока означает: на глубине 0 (т.е. в текущей позиции) попробовать любой разрешенный ход и затем на глубине 2 (следующий ход игрока) пробовать только ходы с шахом. Глубина измеряется в полуходах. Ограничение на ходы противника: любой разрешенный ход на глубине 1.<br>   В процессе игры таблица советов используется многократно вплоть до окончания игры, при этом выполняется следующий основной цикл: построить форсированное дерево, затем играть в соответствии с этим деревом, пока не произойдет выход из него; построить другое форсированное дерево и т.д. Форсированное дерево строится каждый раз таким образом: берется текущая позиция Поз и просматриваются одно за другим все правила таблицы советов; для каждого правила сопоставляется Поз с предварительным условием этого правила и просмотр прекращается, когда будет обнаружено правило, для которого Поз удовлетворяет предварительному условию. В этом случае надо рассмотреть список советов найденного правила: обработать элементарные советы один за другим, пока не будет построено форсированное дерево, представляющее собой детальную стратегию игры в этой позиции.<br>   Следует обратить внимание на существенность того порядка, в котором перечисляются правила в таблице советов. Правило, которое реально используется, — это первое из тех правил, предварительные условия которых согласуются с текущей позицией. Для любой возможной позиции должно существовать по крайней мере одно такое правило. Из него берется список советов, и первый из выполнимых советов списка используется в игре.<br>   Таким образом, таблица советов это программа в высшей степени непроцедурного характера. Интерпретатор языка AL0 принимает на входе некоторую позицию, а затем, "исполняя" таблицу советов, строит форсированное дерево, определяющее стратегию игры в этой позиции.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3460186"></a>15.6. Программа на языке  AL0 для игры в шахматном эндшпиле<br></h3>
<div>
<div>   При реализации какой-либо игровой программы на языке  AL0  ее можно для удобства разбить на три модуля:<br>   (1) интерпретатор языка  AL0,<br>   (2) таблица советов на языке  AL0,<br>   (3) библиотека предикатов, используемых в таблице советов (в том числе предикаты, задающие правила игры).<br>   Эта структура соответствует обычной структуре системы, основанной на знаниях:<br>   • Интерпретатор  AL0  выполняет функцию машины логического вывода.<br>   • Таблица советов вместе с библиотекой предикатов образует базу знаний.<br></div>
<h4 align="center">
<a name="TOC_id3460219"></a>15.6.1. Миниатюрный интерпретатор языка <i>AL0</i><br></h4>
<div>   Реализация на Прологе миниатюрного, не зависящего от конкретной игры интерпретатора языка AL0 показана на рис. 15.6. Эта программа осуществляет также взаимодействие с пользователем во время игры. Центральная задача этой программы — использовать знания, записанные в таблице советов, то есть интерпретировать программу на языке советов AL0 с целью построения форсированных деревьев и их "исполнения" в процессе игры. Базовый алгоритм порождения форсированных деревьев аналогичен поиску с предпочтением в И/ИЛИ-графах гл. 13, при этом форсированное дерево соответствует решающему И/ИЛИ-дереву. Этот алгоритм также напоминает алгоритм построения решающего дерева ответа на вопрос пользователя, применявшийся в оболочке экспертной системы (гл. 14).<br>   Программа на рис. 15.6 составлена в предположении, что она играет белыми, а ее противник — черными. Программа запускается процедурой<br>   игра( Поз)<br>   где Поз — выбранная начальная позиция. Если в позиции Поз ходит противник, то программа принимает его ход, в противном случае — "консультируется" с таблицей советов, приложенной к программе, порождает форсированное дерево и делает свой ход в соответствии с этим деревом. Так продолжается до окончания игры, которое обнаруживает предикат конец_игры (например, если поставлен мат).<br>
		 <br>   % Миниатюрный интерпретатор языка AL0<br>   %<br>   % Эта программа играет, начиная с заданной позиции,<br>   % используя знания, записанные на языке AL0<br>   :- op( 200, xfy, :).<br>   :- op( 220, xfy, ..).<br>   :- op( 185, fx, если).<br>   :- op( 190, xfx, то).<br>   :- op( 180, xfy, или).<br>   :- op( 160, xfy, и).<br>   :- op( 140, fx, не).<br>
		 <br>   игра( Поз) :-         % Играть, начиная с Поз<br>    игра( Поз, nil).<br>     % Начать с пустого форсированного дерева<br>   игра( Поз, ФорсДер) :-<br>    отобр( Поз),<br>    ( конец_игры( Поз),  % Конец игры?<br>      write( 'Конец игры'), nl, !;<br>    сделать_ход( Поз, ФорсДер, Поз1, ФорсДер1), !,<br>    игра( Поз1, ФорсДер1) ).<br>
		 <br>   % Игрок ходит в соответствии с форсированным деревом<br>   сделать_ход( Поз, Ход .. ФДер1, Поз1, ФДер1) :-<br>    чей_ход( Поз, б),    % Программа играет белыми<br>    разрход( Поз, Ход, Поз1),<br>    показать_ход( Ход).<br>
		 <br>   % Прием хода противника<br>   сделать_ход( Поз, ФДер, Поз1, ФДер1) :-<br>    чей_ход( Поз, ч),<br>    write( 'Ваш ход:'),<br>    read( Ход),<br>    ( разрход( Поз, Ход, Поз1),<br>      поддер( ФДер, Ход, ФДер1), !;<br>       % Вниз по форс. дереву<br>    write( 'Неразрешенный ход'), nl,<br>    сделать_ход( Поз, ФДер, Поз1, ФДер1) ).<br>
		 <br>   % Если текущее форсированное дерево пусто, построить новое<br>   сделать_ход( Поз, nil, Поз1, ФДер1) :-<br>    чей_ход( Поз, б),<br>    восст_глуб( Поз, Поз0),<br>     % Поз0 = Поз с глубиной 0<br>    стратегия( Поз0, ФДер), !,<br>     % Новое форсированное дерево<br>    сделать_ход( Поз0, ФДер, Поз1, ФДер1).<br>
		 <br>   % Выбрать форсированное поддерево, соответствующее Ход'у<br>   поддер( ФДеревья, Ход, Фдер) :-<br>    принадлежит( Ход . . Фдер, ФДеревья), !.<br>   поддер( _, _, nil).<br>
		 <br>   стратегия( Поз, ФорсДер) :-<br>     % Найти форс. дерево для Поз<br>    Прав : если Условие то СписСов,<br>     % Обращение к таблице советов<br>    удовл( Условие, Поз, _ ), !,<br>     % Сопоставить Поз с предварительным условием<br>    принадлежит( ИмяСовета, СписСов),<br>     % По очереди попробовать элем. советы<br>    nl, write( 'Пробую'), write( ИмяСовета),<br>    выполн_совет( ИмяСовета, Поз, ФорсДер), !.<br>
		 <br>   выполн_совет( ИмяСовета, Поз, Фдер) :-<br>    совет( ИмяСовета, Совет),<br>     % Найти элементарный совет<br>    выполн( Совет, Поз, Поз, ФДер).<br>
		 <br>   % "выполн" требует две позиции для сравнивающих предикатов<br>   выполн( Совет, Поз, КорнПоз, ФДер) :-<br>    поддержка( Совет, ЦП),<br>    удовл( ЦП, Поз, КорнПоз),<br>     % Сопоставить Поз с целью-поддержкой<br>    выполн1( Совет, Поз, КорнПоз, ФДер).<br>
		 <br>   выполн1( Совет, Поз, КорнПоз, nil) :-<br>    главцель( Совет, ГлЦ),<br>    удовл( ГлЦ, Поз, КорнПоз), !.<br>     % Главная цель удовлетворяется<br>   выполн1( Совет, Поз, КорнПоз, Ход .. ФДеревья) :-<br>    чей_ход( Поз, б), !, % Программа играет белыми<br>    ходы_игрока( Совет, ХодыИгрока),<br>     % Ограничения на ходы игрока<br>    ход( ХодыИгрока, Поз, Ход, Поз1),<br>     % Ход, удовлетворяющий ограничению<br>    выполн( Совет, Поз1, КорнПоз, ФДеревья).<br>   выполн1( Совет, Поз, КорнПоз, ФДеревья) :-<br>    чей_ход( Поз, ч), !, % Противник играет черными<br>    ходы_противника( Совет, ХодыПр),<br>    bagof ( Ход .. Поз1, ход( ХодыПр, Поз, Ход, Поз1), ХПспис),<br>    выполн_все( Совет, ХПспис, КорнПоз, ФДеревья).<br>     % Совет выполним во всех преемниках Поз<br>
		 <br>   выполн_все( _, [], _, []).<br>   выполн_все( Совет, [Ход .. Поз | ХПспис], КорнПоз,<br>    [Ход .. ФД | ФДД] ) :-<br>    выполн( Совет, Поз, КорнПоз, ФД),<br>   выполн_все( Совет, ХПспис, КорнПоз, ФДД).<br>
		 <br>   % Интерпретация главной цели и цели-поддержки:<br>   % цель - это И / ИЛИ / НЕ комбинация. имен предикатов<br>   удовл( Цель1 и Цель2, Поз, КорнПоз) :- !,<br>    удовл( Цель1, Поз, КорнПоз),<br>    удовл( Цель2, Поз, КорнПоз).<br>   удовл( Цель1 или Цель2, Поз, КорнПоз) :- !,<br>    ( удовл( Цель1, Поз, КорнПоз);<br>      удовл( Цель2, Поз, КорнПоз) ).<br>   удовл( не Цель, Поз, КорнПоз) :- !,<br>    not удовл( Цель, Поз, КорнПоз ).<br>   удовл( Пред, Поз, КорнПоз) :-<br>    ( Усл =.. [Пред, Поз];<br>     % Большинство предикатов не зависит от КорнПоз<br>      Усл =.. [Пред, Поз, КорнПоз] ),<br>    call( Усл).<br>
		 <br>   % Интерпретация ограничений на ходы<br>   ход( Ходы1 и Ходы2, Поз, Ход, Поз1) :- !,<br>    ход( Ходы1, Поз, Ход, Поз1),<br>    ход( Ходы2, Поз, Ход, Поз1).<br>   ход( Ходы1 затем Ходы2, Поз, Ход, Поз1) :- !,<br>    ( ход( Ходы1, Поз, Ход, Поз1);<br>      ход( Ходы2, Поз, Ход, Поз1) ).<br>
		 <br>   % Доступ к компонентам элементарного совета<br>   главцель( ГлЦ : _, ГлЦ).<br>
		 <br>   поддержка( ГлЦ : ЦП : _, ЦП).<br>
		 <br>   ходы_игрока( ГлЦ : ЦП : ХодыИгрока : _, Ходы Игрока).<br>
		 <br>   ходы_противника( ГлЦ : ЦП: ХодыИгр : ХодыПр :_,<br>    ХодыПр).<br>
		 <br>   принадлежит( X, [X | Спис]).<br>   принадлежит( X, [Y | Спис]) :-<br>    принадлежит( X, Спис).<br>   <b>Рис. 15.6.</b> Миниатюрный интерпретатор языка AL0.<br>
		 <br>   Форсированное дерево — это дерево ходов, представленное в программе следующей структурой:<br>   Ход .. [ Ответ1 .. Фдер1, Ответ2 .. Фдер2, ... ]<br>   Здесь ".." — инфиксный оператор; Ход — первый ход "игрока"; Ответ1, Ответ2, … — возможные ответы противника; Фдер1, Фдер2, … — форсированные поддеревья для каждого из этих ответов.<br></div>
<h4 align="center">
<a name="TOC_id3460858"></a>15.6.2. Программа на языке советов для эндшпиля "король и ладья против короля"<br></h4>
<div>   Общий принцип достижения выигрыша королем и ладьей против единственной фигуры противника, короля, состоит в том, чтобы заставить короля отступить к краю доски или, при необходимости, загнать его в угол, а затем поставить мат в несколько ходов. В детальном изложении эта стратегия выглядит так:<br>   Повторять циклически, пока не будет поставлен мат (постоянно проверяя, что не возникла патовая позиция и что нет нападения на незащищенную ладью):<br>   (1) Найти способ поставить королю противника мат в два хода.<br>   (2) Если не удалось, то найти способ уменьшить ту область доски, в которой король противника "заперт" под воздействием ладьи.<br>   (3) Если и это не удалось, то найти способ приблизить своего короля к королю противника.<br>   (4) Если ни один из элементарных советов 1, 2, или 3 не выполним, то найти способ сохранить все имеющиеся к настоящему моменту "достижения" в смысле (2) и (3) (т.е. сделать выжидающий ход).<br>   (5) Если ни одна из целей 1, 2, 3 или 4 не достижима, то найти способ получить позицию, в которой ладья занимает вертикальную или горизонтальную линию, отделяющую одного короля от другого.<br>   Описанные выше принципы реализованы во всех деталях в таблице советов на языке AL0, показанной на рис. 15.7. Эта таблица может работать под управлением интерпретатора рис. 15.6. Рис. 15.8 иллюстрирует смысл некоторых из предикатов, использованных в таблице советов, а также показывает, как эта таблица работает.<br>   В таблице используются следующие предикаты:<br>   <i>Предикаты целей</i><br><br><table border="1" align="center">
<tr>
<td>мат</td>
<td>мат королю противника</td>
</tr>
<tr>
<td>пат</td>
<td>пат королю противника</td>
</tr>
<tr>
<td>потеря_ладьи</td>
<td>король противника может взять ладью</td>
</tr>
<tr>
<td>ладья_под_боем</td>
<td>король противника может напасть на ладью прежде, чем наш король сможет ее защитить</td>
</tr>
<tr>
<td>уменьш_простр</td>
<td>уменьшилось "жизненное пространство" короля противника, ограничиваемое ладьей</td>
</tr>
<tr>
<td>раздел</td>
<td>ладья занимает вертикальную или горизонтальную линию, разделяющую королей</td>
</tr>
<tr>
<td>ближе_к_клетке</td>
<td>наш король приблизился к "критической клетке" (см. рис. 15.9), т.е. манхеттеновское расстояние до нее уменьшилось</td>
</tr>
<tr>
<td>l_конфиг</td>
<td>"L-конфигурация" (рис. 15.9)</td>
</tr>
<tr>
<td>простр_больше_2</td>
<td>"жизненное пространство" короля противника занимает больше двух клеток</td>
</tr>
</table>
<br>   <i>Предикаты, ограничивающие ходы</i><br><br><table border="1" align="center">
<tr>
<td>глубина = N</td>
<td>ход на глубине N дерева поиска</td>
</tr>
<tr>
<td>разреш</td>
<td>любой разрешенный ход</td>
</tr>
<tr>
<td>ход_шах</td>
<td>ход, объявляющий шах</td>
</tr>
<tr>
<td>ход_ладьей</td>
<td>ход ладьей</td>
</tr>
<tr>
<td>нет_хода</td>
<td>ни один ход не подходит</td>
</tr>
<tr>
<td>сначала_диаг</td>
<td>ход королем, преимущественно по диагонали</td>
</tr>
</table>
<br>
		 <br>   % Окончание "король и ладья против короля" на языке AL0<br>   % Правила<br>   правило_края:<br>    если король_противника_на_краю и короли_рядом<br>    то [мат_2, потеснить, приблизиться,<br>        сохранить_простр, отделить_2, отделить_3].<br>
		 <br>   иначе_правило<br>    если любая_поз<br>    то [ потеснить, приблизиться, сохранить_простр,<br>         отделить_2, отделить_3].<br>
		 <br>   % Элементарные советы<br>   совет( мат_2,<br>          мат :<br>          не потеря_ладьи и король_противника_на_краю:<br>          (глубина = 0) и разреш<br>          затем (глубина = 2) и ход_шах :<br>          (глубина = 1) и разреш ).<br>
		 <br>   совет( потеснить,<br>          уменьш_простр и не ладья_под_боем и<br>          раздел и не пат :<br>          не потеря_ладьи :<br>          (глубина = 0) и ход_ладьей :<br>          нет_хода ).<br>
		 <br>   совет( приблизиться,<br>          ближе _к_клетке и не ладья_под_боем и<br>          (раздел или l_конфиг) и<br>          (простр_больше_2 или не наш_король_на_краю):<br>          не потеря_ладьи :<br>          (глубина = 0) и сначала_диаг :<br>          нет_хода ).<br>
		 <br>   совет( сохранить_простр,<br>          ход_противника и не ладья_под_боем и раздел<br>          и не_дальше_от_ладьи и<br>          (простр_больше_2 или не наш_король_на_краю):<br>          не потеря_ладьи :<br>          (глубина = 0) и сначала_диаг :<br>          нет_хода ).<br>
		 <br>   совет( отделить_2,<br>          ход_противника и раздел и не ладья_под_боем:<br>          не потеря_ладьи :<br>          (глубина &lt; 3) и разреш :<br>          (глубина &lt; 2) и разреш ).<br>
		 <br>   совет( отделить_3,<br>          ход_противника и раздел и не ладья_под_боем:<br>          не потеря_ладьи :<br>          (глубина &lt; 5) и разреш :<br>          (глубина &lt; 4) и разреш ).<br>   <b>Рис. 15.7.</b> Таблица советов на языке AL0 для окончания "король и ладья против короля". Таблица состоит из двух правил и шести элементарных советов.<br>
		 <br><div align="center"><img border="1" src="_109.png"></div>   <b>Рис. 15.8.</b> Фрагмент шахматной партии, полученный с использованием таблицы советов рис. 15.7 и иллюстрирующий применение стратегии оттеснения короля в угол доски. В этой последовательности ходов выполнялись элементарные советы: сохранить_ простр (выжидающий ход, сохраняющий "жизненное пространство" черного короля) и потеснить (ход, сокращающий "жизненное пространство"). Область, в которой заключен черный король, выделена штриховкой. После выполнения последнего совета потеснить эта область сократилась с восьми до шести клеток.<br><div align="center"><img border="1" src="_110.png"></div>   <b>Рис. 15.9.</b> (а) "Критическая клетка" отмечена крестиком. Она используется при маневрировании с целью оттеснить черного короля. Белый король приближается к "критической клетке", двигаясь, как указано на рисунке. (б) Три фигуры образуют конфигурацию, напоминающую букву L.<br>   Аргументами этих предикатов являются либо позиции (в предикатах целей), либо ходы (в предикатах, ограничивающих ходы). Предикаты целей могут иметь один или два аргумента. Первый из аргументов — это всегда текущая вершина поиска; второй аргумент (если он имеется) — корневая вершина дерева поиска. Второй аргумент необходим в так называемых сравнивающих предикатах, которые сравнивают корневую и текущую позиции в том или ином отношении. Например, предикат уменьш_простр проверяет, сократилось ли "жизненное пространство" короля противника (рис. 15.8). Эти предикаты вместе с шахматными правилами (применительно к окончанию "король и ладья против короля"), а также процедура для отображения текущего состояния игровой доски (отобр( Поз)) запрограммированы на рис. 15.10.<br>   На рис. 15.8 показано, как играет наша программа, основанная на механизме советов. При продолжении игры из последней позиции рис. 15.8 она могла бы протекать так, как в приведенном ниже варианте (в предположении, что "противник" ходит именно так, как указано). Здесь использована алгебраическая шахматная нотация, в которой вертикальные линии пронумерованы, как 'а', 'b', 'с', … а горизонтальные — как 1, 2, 3, …. Например, ход ЧК b7 означает: передвинуть черного короля на клетку, расположенную на пересечении вертикальной линии 'b' с горизонтальной линией 7.<br>   …        ЧК b7<br>   БК d5  ЧК с7<br>   БК с5  ЧК b7<br>   БЛ с6  ЧК а7<br>   БЛ b6  ЧК а8<br>   БК b5  ЧК а7<br>   БК с6  ЧК а8<br>   БК с7  ЧК а7<br>   БЛ с6  ЧК а8<br>   БЛ а6  мат<br>   Теперь уместно задать некоторые вопросы. Во-первых, является ли наша программа-советчик <i>корректной</i> в том смысле, что она ставит мат при любом варианте защиты со стороны противника и при любой начальной позиции, в которой на доске король и ладья против короля? В статье Bratko (1978) приведено формальное доказательство того, что таблица советов, практически совпадающая с таблицей рис. 15.7, действительно является корректной в указанном смысле.<br>   Другой возможный вопрос: является ли программа оптимальной, то есть верно ли, что она ставит мат за минимальное число ходов? Нетрудно показать на примерах, что игру нашей программы в этом смысле нельзя назвать оптимальной. Известно, что оптимальный вариант в этом окончании (т.е. предполагающий оптимальную игру с обеих сторон) имеет длину не более 16 ходов. Хотя наша таблица советов и далека от этого оптимума, было показано, что число, ходов наверняка не превосходит 50. Это важный результат в связи с тем, что в шахматах существует "правило 50-ти ходов": в эндшпилях типа "король и ладья против короля" противник, имеющий преимущество, должен поставить, мат не более, чем за 50 ходов; иначе может быть объявлена ничья.<br>
		 <br>   % Библиотека предикатов для окончания<br>   % "король и ладья против короля"<br>
		 <br>   % Позиция представлена стуктурой:<br>   % ЧейХод..Бх : Бу..Лх : Лу..Чх : Чу..Глуб<br>   % ЧейХод - с чьей стороны ход в этой позиции ('б' или 'ч')<br>   % Бх, Бу - координаты белого короля<br>   % Лх, Лу - координаты белой ладьи<br>   % Чх, Чу - координаты черного короля<br>   % Глуб - глубина, на которой находится эта позиция в дереве<br>   % поиска<br>
		 <br>   % Отношения выбора элементов позиции<br>   чей_ход( ЧейХод.._, ЧейХод).<br>   бк( _..БК.._, БК).                % Белый король<br>   бл( _.._..БЛ.._, БЛ).             % Белая ладья<br>   чк( _.._.._..ЧК.._, ЧК).          % Черный король<br>   глуб( _.._.._.._..Глуб, Глуб).<br>   восст_глуб( ЧХ..Б..Л..Ч..Г, ЧХ..Б..Л..Ч..0).<br>     % Формируется копия позиции, глубина устанавливается в 0<br>
		 <br>   % Некоторые отношения между клетками доски<br>   сосед_чсл( N, N1) :- % Соседнее число "в пределах доски"<br>    ( N1 is N + 1;<br>      N1 is N - 1 ),<br>    внутри( N1).<br>
		 <br>   внутри( N) :-<br>    N &gt; 0, N &lt; 9.<br>
		 <br>   сосед_диаг( X : Y, X1 : Y1) :-<br>     % Соседние клетки по диагонали<br>    сосед_чсл( X, X1 ), сосед_чсл( Y, Y1).<br>
		 <br>   сосед_верт( X : Y, X : Y1) :-<br>     % Соседние клетки по вертикали<br>    сосед_чсл( Y, Y1).<br>
		 <br>   сосед_гор( X : Y, X1 : Y) :-<br>     % Соседние клетки по горизонтали<br>    сосед_чсл( X, X1).<br>
		 <br>   сосед( S, S1) :-<br>     % Соседние клетки (предпочтение - диагонали)<br>    сосед_диаг( S, S1);<br>    сосед_гор( S, S1);<br>    сосед_верт( S, S1).<br>
		 <br>   конец_игры( Поз) :-<br>    мат( Поз).<br>
		 <br>   % Предикаты, ограничивающие ходы<br>   % Специализированное генераторы ходов вида:<br>   % ход( Ограничение, Поз, Ход, Поз1)<br>   ход( глубина &lt; Макс, Поз, Ход, Поз1) :-<br>    глуб( Поз, Г),<br>    Г &lt; Макс, !.<br>   ход( глубина = Г, Поз, Ход, Поз1) :-<br>    глуб( Поз, Г), !.<br>   ход( сначала диаг, б..Б..Л..Ч..Г, Б-Б1,<br>    ч..Б1..Л..Ч..Г1) :-<br>    Г1 is Г + l,<br>    сосед( Б, Б1),<br>     % "сосед" порождает сначала диагональные ходы<br>    not сосед( Б1, Ч), % Не попасть под шах<br>    Б1 \== Л.          % Не столкнуться с ладьей<br>   ход( ход ладьей, б..Б..Лх : Лу..Ч..Г, Лх : Лу-Л,<br>    ч..Б..Л..Ч..Г1) :-<br>    Г1 is Г + 1,<br>    коорд( I),                       % Число между 1 и 8<br>    ( Л = Лх : I; Л = I : Лу),<br>     % По горизонтали или по вертикали<br>    Л \== Лх : Лу,                   % Обязательно двигаться<br>    not мешает( Лх : Лу, Б, Л).      % Мешает белый король<br>   ход( ход_шах, Поз, Л-Лх : Лу, Поз1) :-<br>    бл( Поз, Л),<br>    чк( Поз, Чх : Чу),<br>    ( Лх = Чх; Лу = Чу),<br>     % Ладья и черный король на одной линии<br>    ход( ход_ладьей, Поз, Л-Лх : Лу, Поз1).<br>   ход( разреш, б..П, М, П1) :-<br>    ( Огр = сначала_диаг; Огр = ход ладьей),<br>    ход( Огр, б..П, М, П1).<br>   ход( разреш, ч..Б..Л..Ч..Г, Ч-Ч1, б..Б..Л..Ч1..Г1) :-<br>    Г1 is Г + 1,<br>    сосед( Ч, Ч1),<br>    not шах( б..Б..Л..Ч1..Г1).<br>
		 <br>   разрход( Поз, Ход, Поз1) :-<br>    ход( разреш, Поз, Ход, Поз1).<br>    шах( _..Б..Лх : Лу..Чх : Чу.._ ) :-<br>    сосед( Б, Чх : Чу);              % Короли рядом<br>    ( Лх = Чх; Лу = Чу),<br>    Лх : Лу \== Чх : Чу,             % Нет взятия ладьи<br>    not мешает( Лх : Лу, Б, Чх : Чу).<br>
		 <br>   мешает( S, S1, S1) :- !.<br>   мешает( X1 : Y, X2 : Y, Х3 : Y) :-<br>    упоряд( X1, Х2, Х3), !.<br>   мешает( X : Y1, X : Y2, X : Y3) :-<br>    упоряд( Y1, Y2, Y3).<br>
		 <br>   упоряд( N1, N2, N3) :-<br>    N1 &lt; N2, N2 &lt; N3;<br>    N3 &lt; N2, N2 &lt; N1.<br>
		 <br>   коорд( 1). коорд( 2). коорд( 3). коорд( 4).<br>   коорд( 5). коорд( 6). коорд( 7). коорд( 8).<br>
		 <br>   % Предикаты целей<br>   любая_поз( Поз).<br>
		 <br>   ход_противника( б.._ ).           % Противник ходит белыми<br>
		 <br>   мат( Поз) :-<br>    чей_ход( Поз, ч),<br>    шах( Поз),<br>    not разрход( Поз, _, _ ).<br>
		 <br>   пат( Поз) :-<br>    чей_ход( Поз, ч),<br>    not шах( Поз),<br>    not разрход( Поз, _, _ ).<br>
		 <br>   уменьш_простр( Поз, КорнПоз) :-<br>    простр( Поз, Пр),<br>    простр( КорнПоз, КорнПр),<br>    Пр &lt; КорнПр.<br>
		 <br>   ладья_под_боем( ЧейХод..Б..Л..Ч.._ ) :-<br>    расст( Б, Л, P1),<br>    расст( Ч, Л, Р2),<br>    ( ЧейХод = б, !, P1 &gt; Р2 + 1;<br>      ЧейХод = ч,  !,  P1 &gt; Р2 ).<br>
		 <br>   ближе_к_клетке( Поз, КорнПоз) :-<br>    расст_до_клетки( Поз, P1),<br>    расст_до_клетки( КорнПоз, Р2),<br>    P1 &lt; Р2.<br>
		 <br>   расст_до_клетки( Поз, Мрасст) :-<br>                  % Манхеттеновское расстояние<br>    бк( Поз, БК), % между БК и критической клеткой<br>    кк( Поз, КК), % Критическая клетка<br>    манх_расст( БК, КК, Мрасст).<br>
		 <br>   раздел( _..Бх : Бу..Лх : Лу.. Чх : Чу.._ ) :-<br>    упоряд( Бх, Лх, Чх), !;<br>    упоряд( Бу, Лу, Чу).<br>
		 <br>   l_конфиг( _..Б..Л..Ч.._ ) :-      % L - конфигурация<br>    манх_расст( Б, Ч, 2),<br>    манх_расст( Л, Ч, 3).<br>
		 <br>   не дальше_от_ладьи( _..Б..Л.._, _..Б1..Л1.._ ) :-<br>    расст( Б, Л, P),<br>    расст( Б1, Л1, P1),<br>    P =&lt; P1.<br>
		 <br>   простр_больше_2( Поз) :-<br>    простр( Поз, Пр),<br>    Пр &gt; 2.<br>
		 <br>   наш_король_на_краю( _..X : Y.._ ) :-<br>     % Белый король на краю<br>    ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).<br>
		 <br>   король_противника_на_краю( _..Б..Л..X : Y.._ ) :-<br>     % Черный король на краю<br>    ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).<br>
		 <br>   короли_рядом( Поз) :-             % Расстояние между королями  &lt;  4<br>    бк( Поз, БК), чк( Поз, ЧК),<br>    расст( БК, ЧК, P),<br>    P &lt; 4.<br>
		 <br>   потеря_ладьи( _..Б..Л..Л.._ )- % Ладья взята<br>   потеря_ладьи( ч..Б..Л..Ч.._ ) :-<br>    сосед( Ч, Л),                 % Черный король напал на ладью<br>    not сосед( Б, Л).             % Белый король не защищает ладью<br>
		 <br>   расст( X : Y, X1 : Y1, P) :-   % Расстояние до короля<br>    абс_разн( X, X1, Рх),<br>    абс_разн( Y, Y1, Ру),<br>    макс( Рх, Ру, P).<br>
		 <br>   абс_разн( А, В, С) :-<br>    А &gt; В, !, С is A - В;<br>    С is В - А.<br>
		 <br>   макс( А, В, М) :-<br>    А &gt;= В, !, М = А;<br>    М = В.<br>
		 <br>   манх_расст( X : Y, X1 : Y1, P) :- % Манхеттеновское расстояние<br>    абс_разн( X, X1, Рх),<br>    абс_разн( Y, Y1, Ру),<br>    P is Рх + Ру.<br>
		 <br>   простр( Поз, Пр) :-<br>     % Область, в которой "заперт" черный король<br>    бл( Поз, Лх : Лу),<br>    чк( Поз, Чх : Чу),<br>    ( Чх &lt; Лх, СторонаХ is Лх - 1;<br>      Чх &gt; Лх, СторонаХ is 8 - Лх ),<br>    ( Чу &lt; Лу, СторонаY is Лу - 1;<br>      Чу &gt; Лу, СторонаY is 8 - Лу ),<br>    Пр is СторонаХ * СторонаY, !;<br>    Пр = 64. % Ладья и черный король на одной линии<br>
		 <br>   кк( _..Б..Лх : Лу.. Чх : Чу.._, Кх : Ку) :-<br>     % Критическая клетка<br>    ( Чх &lt; Лх, !, Кх is Лх - 1; Кх is Лх + 1),<br>    ( Чу &lt; Лу, !, Ку is Лу - 1; Ку is Лу + 1).<br>
		 <br>   % Процедуры для отображения позиций<br>   отобр( Поз) :-<br>    nl,<br>    коорд( Y), nl,<br>    коорд( X),<br>    печ_фиг( X : Y, Поз),<br>    fail.<br>   отобр( Поз) :-<br>    чей_ход( Поз, ЧХ), глуб( Поз, Г),<br>    nl, write( 'ЧейХод='), write( ЧХ),<br>    write( 'Глубина='), write( Г), nl.<br>
		 <br>   печ_фиг( Клетка, Поз):-<br>    бк( Поз, Клетка), !, write( 'Б');<br>    бл( Поз, Клетка), !, write( 'Л');<br>    чк( Поз, Клетка), !, write( 'Ч');<br>    write( '.').<br>
		 <br>   показать_ход( Ход) :-<br>    nl, write( Ход), nl.<br>   <b>Рис. 15.10.</b> Библиотека предикатов для окончания "король и ладья против короля".<br><h5>Проект</h5>   Рассмотрите какой-нибудь другой простой эндшпиль, например "король и пешка против короля", и напишите для него программу на языке AL0 (вместе с определениями соответствующих предикатов).<br></div>
</div>
<h3 align="center">
<a name="TOC_id3462300"></a>Резюме<br></h3>
<div>   • Игры двух лиц поддаются формальному представлению в виде И/ИЛИ-графов. Поэтому процедуры поиска в И/ИЛИ-графах применимы для поиска в игровых деревьях.<br>   • Простой алгоритм поиска в глубину в игровых деревьях легко программируется, но для игр, представляющих интерес, он не эффективен. Более реалистичный подход — минимаксный принцип в сочетании с оценочной функцией и поиском, ограниченным по глубине.<br>   • Альфа-бета алгоритм является эффективной реализацией минимаксного принципа. Эффективность альфа-бета алгоритма зависит от порядка, в котором просматриваются варианты ходов. Применение альфа-бета алгоритма приводит, в лучшем случае, к уменьшению коэффициента ветвления дерева поиска, соответствующему извлечению из него квадратного корня.<br>   • В альфа-бета алгоритм можно внести ряд усовершенствований. Среди них: продолжение поиска за пределы ограничения по глубине вплоть до спокойных позиций, последовательное углубление и эвристическое отсечение ветвей.<br>   • Численная оценка позиций является весьма ограниченной формой представления знаний о конкретной игре. Более богатый по своим возможностям метод представления знаний должен предусматривать внесение в программу знаний о типовых ситуациях. Язык Советов (Advice Language) реализует такой подход. На этом языке знания представляются в терминах целей и средств для их достижения.<br>   • В данной главе мы составили следующие программы: программная реализация минимаксного принципа и альфа-бета процедуры, интерпретатор языка AL0 и таблица советов для окончания "король и ладья против короля".<br>   • Были введены и обсуждены следующие понятия:<br>     игры двух лиц с полной информацией<br>     игровые деревья<br>     оценочная функция, минимаксный принцип<br>     статические оценки, рабочие оценки<br>     альфа-бета алгоритм<br>     последовательное углубление,<br>     эвристическое отсечение,<br>     эвристики для обнаружения спокойных позиций<br>   Языки Советов<br>     цели, ограничения, элементарные советы,<br>     таблица советов<br><h5>Литература</h5>   Минимаксный принцип, реализованный в форме альфа-бета алгоритма, — это наиболее популярный метод в игровом программировании. Особенно часто он применяется в шахматных программах. Минимаксный принцип был впервые предложен Шенноном (Shannon 1950). Возникновение и становление альфа-бета алгоритма имеет довольно запутанную историю. Несколько исследователей независимо друг от друга открыли либо реализовали этот метод полностью или частично. Эта интересная история описана в статье Knuth and Moore (1978). Там же приводится более компактная формулировка альфа-бета алгоритма, использующая вместо минимаксного принципа принцип "него-макса" ("neg-max" principle), и приводится математический анализ производительности алгоритма. Наиболее полный обзор различных минимаксных алгоритмов вместе с их теоретическим анализом содержится в книге Pearl (1984). Существует еще один интересный вопрос, относящийся к минимаксному принципу. Мы знаем, что статическим оценкам следует доверять только до некоторой степени. Можно ли считать, что рабочие оценки являются более надежными, чем исходные статические оценки, из которых они получены? В книге Pearl (1984) собран ряд математических результатов, имеющих отношение к ответу на этот вопрос. Приведенные в этой книге результаты, касающиеся распространения ошибок по минимаксному дереву, объясняют, в каких случаях и почему минимаксный принцип оказывается полезным.<br>   Сборник статей Bramer (1983) охватывает несколько аспектов игрового программирования. Frey (1983) — хороший сборник статей по шахматным программам. Текущие разработки в области машинных шахмат регулярно освещаются в серии Advances in Computer Chess и в журнале ICCA.<br>   Метод Языка Советов, позволяющий использовать знания о типовых ситуациях, был предложен Д. Мики. Дальнейшее развитие этого метода отражено в Bratko and Michi (1980 a, b) и Bratko (1982, 1984, 1985). Программа для игры в эндшпиле "король и ладья против короля", описанная в этой главе, совпадает с точностью до незначительных модификаций с таблицей советов, корректность которой была математически доказана в статье Bratko (1978). Ван Эмден также запрограммировал эту таблицу советов на Прологе (van Emden 1982).<br>   Среди других интересных экспериментов в области машинных шахмат, преследующих цель повысить эффективность знаний (а не перебора), следует отметить Berliner (1977), Pitrat (1977) и Wilkins (1980).<br>
		 <br>   <i>Advances in Computer Chess Series</i> (M.R.B. Clarke, ed). Edinburgh University Press (Vols. 1-2), Pergamon Press (Vol. 3).<br>   Berliner M. A. (1977); A representation and some mechanisms for a problem solving chess program. In: <i>Advances in Computer Chess 1</i> (M.R.B. Clarke, ed). Edinburgh University Press.<br>   Bramer M. A; (1983, ed). <i>Computer Game Playing: Theory and Practice.</i> Ellis Horwood and John Wiley.<br>   Bratko I. (1978) Proving correctness of strategies in the AL1 assertional language. <i>Information Processing Letters 7</i>: 223-230.<br>   Bratko I. (1982). Knowledge-based problem solving in AL3. In: <i>Machine Intelligence 10</i> (J. Hayes, D. Michie, J. H. Pao, eds.). Ellis Horwood (an abbreviated version also appears in Bramer 1983).<br>   Bratko I. (1984). Advise and planning in chess end-games. In: <i>Artificial and Human Intelligence</i> (S. Amarel, A. Elithorn, R. Banerji, eds.). North-Holland.<br>   Bratko I. (1985). Symbolic derivation of chess patterns. In: <i>Progress Artificial Intelligence</i> (L. Steels, J. A. Campbell, eds.). Ellis Horwood and John Wiley.<br>   Bratko I. and Michie D. (1980a). A representation of pattern-knowledge in chess end-games. In: <i>Advances in Computer Chess</i> 2 (M.R.B. Clarke, ed). Edinburgh University Press.<br>   Bratko I. and Michie D. (1980b). An advice program for a complex chess programming task. <i>Computer Journal</i> <b>23</b>: 353-359.<br>   Frey P. W. (1983, ed.). <i>Chess Skill in Man and Machine</i> (second edition). Springer-Verlag.<br>   Knuth D. E. and Moore R. W. (1975). An analysis of alpha-beta pruning. <i>Artificial Intelligence</i> <b>6</b>: 93-326.<br>   Pearl J. (1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley.<br>   Pitrat J. (1977). A chess combination program which uses plans <i>Artificial Intelligence</i> <b>8</b>: 275-321.<br>   Shannon C.E. (1950). Programming a computer for playing chess. <i>Philosophical Magazine</i> <b>41</b>: 256-275. [В сб. Шеннон К. Работы по теории информации и кибернетике. — М.: ИЛ., 1963.]<br>   van Emden M. (1982). Chess end-game advice: a case study in computer utilisation of knowledge. In: <i>Machine Intelligence 10</i> (J. Hayes, D. Michie, J.H. Pao, eds). Ellis Hordwood.<br>   Wilkins D.E. (1980). Using patterns and plans in chess. <i>Artificial Intelligence</i> <b>14</b>: 165-203. <br></div>
</div>
<h2 align="center">
<a name="TOC_id3462564"></a>Глава 16<br>Программирование в терминах типовых конфигураций<br></h2>
<div>
<div>   В этой главе мы будем заниматься системами, ориентированными на типовые конфигурации ("образцы"), рассматривая их как некоторый специальный подход к программированию. Языком, ориентированным на образцы, можно считать и сам Пролог. Мы реализуем небольшой интерпретатор для простых программ этого типа и постараемся передать дух такого "конфигурационной" программирования на нескольких примерах.<br></div>
<h3 align="center">
<a name="TOC_id3462582"></a>16.1. Архитектура, ориентированная на типовые конфигурации <br></h3>
<div>
<h4 align="center">
<a name="TOC_id3462588"></a>16.1.1. Основные понятия<br></h4>
<div>   Под <i>системами, ориентированными на типовые конфигурации (образцы)</i>, мы будем понимать программные системы специальной архитектуры. Для некоторых конкретных типов задач такая архитектура дает преимущества по сравнению с традиционным способом организации. Среди задач, которые естественным образом вписываются в этот вид архитектуры, находятся многие приложения искусственного интеллекта, в том числе экспертные системы. Основное различие между традиционными системами и системами, ориентированными на образцы, заключается в механизме запуска программных модулей. Традиционная архитектура предполагает, что модули системы обращаются друг к другу в соответствии с фиксированной, заранее заданной и явным образом сформулированной схемой. Каждый программный модуль сам принимает решение о том, какой из других модулей следует запустить в данный момент, причем в нем содержится <i>явное</i> обращение к этим модулям. Соответствующая временная структура передач управления от одних модулей к другим оказывается последовательной и детерминированной.<br>   В противоположность этому организация, ориентированная на образцы, не предполагает прямого обращения из одних модулей к другим. Модули запускаются <i>конфигурациями</i>, возникающими в их "информационной среде". Такие программные модули называют модулями, <i>управляемыми типовыми конфигурациями</i> (или <i>образцами</i>). Программа, управляемая образцами, представляет из себя набор модулей. Каждый модуль определяется<br>   (1) образцом, соответствующим предварительному условию запуска, и<br>   (2) тем действием, которое следует выполнить, если информационная среда согласуется с заданным образцом.<br>   Запуск модулей на выполнение происходит при появлении тех или иных конфигураций в информационной среде системы. Такую информационную среду обычно называют <i>базой данных</i>. Наглядное представление о системе рассматриваемого типа дает рис. 16.1.<br><div align="center"><img border="1" src="_111.png"></div>   <b>Рис. 16.1.</b> Система, управляемая типовыми конфигурациями (образцами)<br>   Следует сделать несколько важных замечаний относительно рис. 16.1. Совокупность модулей не имеет иерархической структуры. Отсутствуют явные указания на то, какие модули могут обращаться к каким-либо другим модулям. Модули связаны скорее с базой данных, чем непосредственно друг с другом. В принципе такая структура допускает параллельное выполнение сразу нескольких модулей, поскольку текущее состояние базы данных может прийти в соответствие сразу с несколькими предварительными условиями, а следовательно, в принципе могут запуститься несколько модулей одновременно. В связи с этим, подобную организацию можно рассматривать как естественную модель параллельных вычислений, имея в виду, что каждый модуль физически реализован на отдельном процессоре.<br>   Архитектура, ориентированная на образцы, обладает рядом достоинств. Одно из ее главных преимуществ состоит в том, что, разрабатывая подобную систему, мы не должны тщательно продумывать и заранее определять все связи между модулями. Следовательно, каждый модуль может быть разработан и реализован относительно автономно. Это придает системе высокую степень модульности, проявляющуюся, например, в том, что удаление из системы какого-либо модуля не обязательно приводит к фатальным последствиям. После удаления модуля система во многих случаях сохранит свою способность к решению задач, измениться может только <i>способ</i> их решения. Аналогичное соображение верно и в случае добавления новых модулей или изменения уже существующих. Заметим, что при введении подобных модификаций в традиционные системы потребовалось бы, как минимум, пересмотреть связи между модулями.<br>   Высокая степень модульности особенно желательна в системах со сложными базами знаний, поскольку очень трудно предсказать заранее все возможные взаимодействия между отдельными фрагментами знаний. Архитектура, ориентированная на образцы, обеспечивает простое решение этой проблемы: каждый фрагмент знаний, представленный в виде "если-то"-правила, можно считать отдельным модулем, запускаемым своим собственным образцом.<br>   Перейдем теперь к более детальной проработке нашей базовой схемы для систем, ориентированных на образцы, и рассмотрим вопросы реализации. Как следует из рис. 16.1, параллельная реализация была бы для нашей системы наиболее естественным решением. Тем не менее предположим, что нам предстоит реализовать ее на традиционном последовательном процессоре. Тогда если в базе знаний окажется сразу несколько "пусковых" конфигураций, относящихся к нескольким модулям, то возникнет конфликтная ситуация: нам придется принять решение о том, какой из этих потенциально активных модулей будет запущен в действительности. Совокупность всех потенциально активных модулей назовем <i>конфликтным множеством</i>. Очевидно, что реализация схемы рис. 16.1 на последовательном процессоре потребует введения в систему дополнительного,  <i>управляющего модуля</i>. Задача управляющего модуля — выбрать и активизировать один из модулей конфликтного множества и тем самым разрешить конфликт. Одно из возможных простых правил разрешения конфликта может основываться, например, на предварительном упорядочивании множества модулей системы.<br>   Основной цикл работы системы, ориентированной на образцы, состоит, таким образом, из трех шагов:<br>   (1) <i>Сопоставление с образцами</i>: найти в базе данных все конфигурации, сопоставимые с пусковыми образцами программных модулей. Результат — конфликтное множество.<br>   (2) <i>Разрешение конфликта</i>: выбрать один из модулей, входящих в конфликтное множество.<br>   (3) <i>Выполнение</i>: запустить модуль, выбранный на предыдущем шаге.<br>   Этот принцип реализации показан в виде схемы на рис. 16.2.<br></div>
<h4 align="center">
<a name="TOC_id3462768"></a>16.1.2. Прологовские программы как системы, управляемые образцами<br></h4>
<div>   Программы, написанные на Прологе, можно рассматривать как системы, управляемые образцами. Между пролог-программами и этими системами можно установить соответствие примерно следующим образом:<br>   • Каждое предложение прологовской программы можно считать отдельным модулем со своим пусковым образцом. Голова предложения соответствует образцу, тело - тому действию, которое выполняет модуль.<br>   • База данных системы — это текущий список целей, которые пролог-система пытается удовлетворить.<br>   • Предложение пролог-системы "запускается", если его голова сопоставима с целью, расположенной первой в базе данных.<br>   • Выполнить действие модуля (т.е. тело предложения) — это значит: поместить в базу данных вместо первой из целей весь список целей тела предложения (с соответствующей конкретизацией переменных).<br>   • Процесс активизации модулей (предложений) не детерминирован в том смысле, что с первой целью базы данных могут удачно сопоставить свою голову сразу несколько предложений, и, вообще говоря, любое из них может быть запущено. В Прологе этот недетерминизм реализован при помощи механизма возвратов.<br><div align="center"><img border="1" src="_112.png"></div>   <b>Рис. 16.2.</b> Основной цикл работы системы, управляемой образцами. В этом примере база данных согласуется с пусковыми образцами модулей 1, 3 и 4; для выполнения выбран модуль 3.<br></div>
<h4 align="center">
<a name="TOC_id3462818"></a>16.1.3. Пример составления программы<br></h4>
<div>   С системами, управляемыми образцами, связан свой особый стиль программирования, требующий специфического программистского мышления. Мы говорим в этом случае о <i>программировании в терминах образцов</i>.<br>   В качестве иллюстрации, рассмотрим элементарное упражнение по программированию — вычисление наибольшего общего делителя <i>D</i> двух целых чисел <i>А</i> и <i>В</i>. Рассмотрим классический алгоритм Евклида:<br><blockquote>   Для того, чтобы вычислить наибольший общий делитель <i>D</i> чисел <i>А</i> и <i>В</i>, необходимо:<br>    Повторять циклически, пока <i>А</i> и <i>В</i> не совпадут:<br>     если <i>А &gt; В</i>, то заменить <i>А</i> на <i>А - В</i>,<br>     иначе заменить <i>В</i> на <i>В - А</i>.<br>    После выхода из цикла <i>А</i> и <i>В</i> совпадают; наибольший общий делитель <i>D</i> равен <i>А</i> (или <i>В</i>).<br></blockquote>   Тот же самый процесс можно описать при помощи двух модулей, управляемых образцами:<br>   <b>Модуль 1</b><br>   <i>Условие</i> В базе данных существуют такие два числа <i>X</i> и <i>Y</i>, что <i>X &gt; Y</i>.<br>   <i>Действие</i> Заменить <i>X</i> на разность <i>X - Y</i>.<br>   <b>Модуль 2</b><br>   <i>Условие</i> В  базе данных имеется число <i>X</i>.<br>   <i>Действие</i> Выдать результат <i>X</i> и остановиться.<br>   Очевидно, что всегда, когда условие Модуля 1 удовлетворяется, удовлетворяется также и условие Модуля 2, и мы имеем конфликт. В нашем случае конфликт можно разрешить при помощи простого управляющего правила: всегда отдавать предпочтение Модулю 1. База данных первоначально содержит числа <i>А</i> и <i>В</i>.<br>   Здесь нас ждет приятный сюрприз: оказывается, что наша программа способна решать более общую задачу, а именно, она может вычислять наибольший общий делитель для любого количества чисел. Если в базу данных загрузить несколько целых чисел, то программа выведет их наибольший общий делитель. На рис. 16.3 показана возможная последовательность изменений, которые претерпевает база данных прежде, чем будет получен результат. Обратите внимание на то, что предварительные условия модулей могут удовлетворяться одновременно в нескольких местах базы данных.<br><div align="center"><img border="1" src="_113.png"></div>   <b>Рис. 16.3.</b> Процесс вычисления наибольшего общего делителя множества чисел. Первоначально база данных содержит числа 25, 10, 15 и 30. Вертикальная стрелка соединяет число с его "заменителем". Конечное состояние базы данных: 5, 5, 5, 5.<br>   В данной главе мы реализуем интерпретатор простого языка для описания систем, управляемых образцами, и проиллюстрируем на примерах дух программирования в терминах образцов.<br></div>
</div>
<h3 align="center">
<a name="TOC_id3463033"></a>16.2. Простой интерпретатор программ, управляемых образцами<br></h3>
<div>   Для описания модулей, управляемых образцами, мы применим следующую синтаксическую конструкцию:<br>   ЧастьУсловия ---&gt; ЧастьДействия<br>   Часть условия представляет собой список условий:<br>   [ Условие1, Условие2, Условие3, ...]<br>   где Условие1, Условие2 и т.д. — обычные прологовские цели. Предварительное условие запуска модуля считается выполненным, если все цели, содержащиеся в списке, достигнуты. Часть действия — это список действий:<br>   [ Действие1, Действие2, ...]<br>   Каждое отдельное действие — это, как и раньше, прологовская цель. Для того, чтобы выполнить список действий, нужно выполнить все действия из списка. Другими словами, все соответствующие цели должны быть удовлетворены. Среди допустимых действий будут действия, соответствующие манипулированию базой данных: добавить, удалить или заменить те или иные объекты базы данных.<br>   На рис. 16.4 показано, как выглядит наша программа вычисления наибольшего общего делителя, записанная в соответствии с введенным нами синтаксисом.<br>
		 <br>   % Продукционные правила для нахождения наибольшего общего<br>   % делителя (алгоритм Евклида)<br>   :- op( 300, fx, число).<br>
		 <br>   [ число X, число Y, X &gt; Y ] ---&gt;<br>    [ НовХ is X - Y, заменить( число X, число НовХ) ].<br>   [ число X ] ---&gt; [ write( X), стоп ].<br>
		 <br>   % Начальное состояние базы данных<br>   число 25.<br>   число 10.<br>   число 15.<br>   число 30.<br>   <b>Рис. 16.4.</b> Программа, управляемая образцами, для получения наибольшего общего делителя множества чисел.<br>
		 <br>   Самый простой способ реализации этого языка — использовать механизмы управления базой данных, встроенные в Пролог. Добавить объект в базу данных или удалить объект из базы данных можно, применяя встроенные процедуры<br>   assert ( Объект)   retract( Объект)<br>   Заменить один объект на другой также просто:<br>   заменить( Объект1, Объект2) :-<br>    retract( Объект1), !,<br>    assert( Объект2).<br>   Здесь задача оператора отсечения — не допустить, чтобы оператор retract удалил из базы данных более чем один объект (при возвратах).<br>
		 <br>   % Простой интерпретатор для программ, управляемых образцами<br>   % Работа с базой данных производится при помощи процедур<br>   % assert и retract<br>
		 <br>   :- op( 800, xfx, ---&gt;).<br>
		 <br>   пуск :-<br>    Условие ---&gt; Действие,          % правило<br>    проверить( Условие),            % Условие выполнено?<br>    выполнить( Действие).<br>
		 <br>   проверить( []).                  % Пустое условие<br>   проверить( [Усл | Остальные]) :- % проверить конъюнкцию<br>    call( Усл),                     % условий<br>    проверить( Остальные).<br>
		 <br>   выполнить( [ стоп] ) :- !. % Прекратить выполнение<br>   выполнить( []) :-          % Пустое действие (цикл завершен)<br>    пуск.                     % Перейти к следующему циклу<br>   выполнить [Д | Остальные] ) :-<br>    саll( Д),<br>    выполнить( Остальные).<br>
		 <br>   заменить( А, В) :-         % Заменить в базе данных А на В<br>    retract( A), !,<br>    assert( В).<br>   <b>Рис. 16.5.</b> Простой интерпретатор для программ, управляемых образцами.<br>
		 <br>   Простой интерпретатор для программ, управляемых образцами, показан на рис. 16.5. Следует признать, что в интерпретаторе допущены значительные упрощения. Так, например, в него заложено чрезвычайно простое и жесткое правило разрешения конфликтов: всегда запускать <i>первый</i> из потенциально активных модулей (в соответствии с тем порядком, в котором модули записаны в программе). Таким образом, программисту предоставлено единственное средство управления процессом интерпретации — он может указать тот или иной порядок следования модулей. Начальное состояние базы данных задается в виде прологовских предложений, записанных в исходной программе. Запуск программы производится при помощи вопроса<br>   ?- пуск.<br></div>
<h3 align="center">
<a name="TOC_id3463319"></a>16.3. Простая программа для автоматического доказательства теорем<br></h3>
<div>   В настоящем разделе мы реализуем простую программу для автоматического доказательства теорем в виде системы, управляемой образцами. Эта программа будет основана на <i>принципе резолюции</i> — популярном методе, обычно используемом в машинном доказательстве теорем. Мы ограничимся случаем <i>пропозициональной логики</i>, поскольку нашей целью будет дать всего лишь простую иллюстрацию используемого принципа. На самом деле, принцип резолюции можно легко обобщить на случай исчисления высказываний первого порядка (с применением логических формул, содержащих переменные). Базовый Пролог можно рассматривать как частный случай системы доказательства теорем, основанной на принципе резолюции.<br>   Задачу доказательства теорем можно сформулировать так: дана формула, необходимо показать, что эта формула является теоремой, т.е. она верна всегда, независимо от интерпретации встречающихся в ней символов. Например, утверждение, записанное в виде формулы<br>   <i>p</i>  v  <i>~ p</i><br>   и означающее "<i>p</i> или не <i>p</i>", верно всегда, независимо от смысла утверждения <i>p</i>.<br>   Мы будем использовать в качестве операторов следующие символы:<br>   ~     отрицание, читается как  "не"<br>   &amp;    конъюнкцию, читается как  "и"<br>   v    дизъюнкцию, читается как  "или"<br>   =&gt;  импликацию, читается как  "следует"<br>   Согласно правилам предпочтения операторов, оператор "не" связывает утверждения сильнее, чем "и", "или" и "следует".<br>   Метод резолюции предполагает, что мы рассматриваем отрицание исходной формулы и пытаемся показать, что полученная формула противоречива. Если это действительно так, то исходная формула представляет собой тавтологию. Таким образом, основную идею можно сформулировать так: доказательство противоречивости формулы с отрицанием эквивалентно доказательству того, что исходная формула (без отрицания) есть теорема (т.е. верна всегда). Процесс, приводящий к искомому противоречию, состоит из отдельных шагов, на каждом из которых применяется резолюция.<br>   Давайте проиллюстрируем этот принцип на примере. Предположим, что мы хотим доказать, что теоремой является следующая пропозициональная формула:<br>   (<i>а  =&gt;  b</i>) &amp; (<i>b  =&gt;  с</i>) =&gt; (<i>а  =&gt;  с</i>)<br>   Смысл этой формулы таков: если из <i>а</i> следует <i>b</i> и из <i>b</i> следует <i>с</i>, то из <i>а</i> следует <i>с</i>.<br>   Прежде чем начать применять процесс резолюции ("резолюционный процесс"), необходимо представить отрицание нашей формулы в наиболее приспособленной для этого форме. Такой формой является <i>конъюнктивная нормальная форма</i>, имеющая вид<br>   (<i>р</i><sub>1</sub>  v  <i>p</i><sub>2</sub>  v  …)  &amp;  (<i>q</i><sub>1</sub>  v  <i>q</i><sub>2</sub>  v  …)<br>         &amp;  (<i>r</i><sub>1</sub>  v  <i>r</i><sub>2</sub>  v  …)  &amp;  …<br>   Здесь <i>р<sub>i</sub></i>, <i>q<sub>i</sub></i>, <i>r<sub>i</sub></i> — элементарные утверждения или их отрицания. Конъюнктивная нормальная форма есть конъюнкция членов, называемых <i>дизъюнктами</i>, например (<i>p</i><sub>1</sub> v <i>p</i><sub>2</sub> v …) — это дизъюнкт.<br>   Любую пропозициональную формулу нетрудно преобразовать в такую форму. В нашем случае это делается следующим образом. У нас есть исходная формула<br>   (<i>а  =&gt;  b</i>)  &amp;  (<i>b  =&gt;  с</i>)  =&gt;  (<i>а  =&gt;  с</i>)<br>   Ее отрицание имеет вид<br>   ~((<i>а  =&gt;  b</i>) &amp; (<i>b  =&gt;  с</i>) =&gt; (<i>а  =&gt;  с</i>))<br>   Для преобразования этой формулы в конъюнктивную нормальную форму можно использовать следующие известные правила:<br>   (1) <i>x =&gt; у</i>  эквивалентно  <i>~x</i> v <i>у</i><br>   (2) <i>~</i>(<i>x</i> v <i>y</i>)  эквивалентно <i>~x</i> &amp; <i>~у</i><br>   (3) <i>~</i>(<i>x</i> &amp; <i>у</i>)  эквивалентно  <i>~x</i> v <i>~у</i><br>   (4) <i>~</i>(<i>~x</i>)  эквивалентно  <i>x</i><br>   Применяя правило 1, получаем<br>   ~(~((<i>a  =&gt;  b</i>)  &amp;  (<i>b  =&gt;  с</i>))  v  (<i>а  =&gt;  с</i>))<br>   Далее, правила 2 и 4 дают<br>   (<i>а  =&gt;  b</i>)  &amp;  (<i>b  =&gt;  с</i>)  &amp;  ~(<i>а  =&gt;  с</i>)<br>   Трижды применив правило 1, получаем<br>   (<i>~а</i>  v  <i>b</i>)  &amp;  (<i>~b</i>  v  <i>с</i>)  &amp;  <i>~</i>(<i>~а</i>  v  <i>с</i>)<br>   И наконец, после применения правила 2 получаем искомую конъюнктивную нормальную форму<br>   (<i>~а</i>  v  <i>b</i>)  &amp;  (<i>~b</i>  v  <i>с</i>)  &amp;  <i>а</i>  &amp;  <i>~с</i><br>   состоящую из четырех дизъюнктов. Теперь можно приступить к резолюционному процессу.<br>   Элементарный шаг резолюции выполняется всегда, когда имеется два дизъюнкта, в одном из которых встретилось элементарное утверждение <i>p</i>, а в другом — <i>~p</i>. Пусть этими двумя дизъюнктами будут<br>   <i>p</i> v <i>Y</i>  и  <i>~p</i> v <i>Z</i><br>   Шаг резолюции порождает третий дизъюнкт:<br>   <i>Y</i>  v  <i>Z</i><br>   Нетрудно показать, что этот дизъюнкт логически следует из тех двух дизъюнктов, из которых он получен. Таким образом, добавив выражение (<i>Y</i> v <i>Z</i>) к нашей исходной формуле, мы не изменим ее истинности. Резолюционный процесс порождает новые дизъюнкты. Появление "пустого дизъюнкта" (обычно записываемого как "nil") сигнализирует о противоречии. Действительно, пустой дизъюнкт <i>nil</i> порождается двумя дизъюнктами вида<br>   <i>x</i>  и  <i>~x</i><br>   которые явно противоречат друг другу.<br><div align="center"><img border="1" src="_114.png"></div>   <b>Рис. 16.6.</b> Доказательство теоремы (<i>а=&gt;b</i>)&amp;(<i>b=&gt;с</i>)=&gt;(<i>a=&gt;с</i>) методом резолюции. Верхняя строка — отрицание теоремы в конъюнктивной нормальной форме. Пустой дизъюнкт внизу сигнализирует, что отрицание теоремы противоречиво.<br>   На рис. 16.6 показан процесс применения резолюций, начинающийся с отрицания нашей предполагаемой теоремы и заканчивающийся пустым дизъюнктом.<br>   На рис. 16.7 мы видим, как резолюционный процесс можно сформулировать в форме программы, управляемой образцами. Программа работает с дизъюнктами, записанными в базе данных. В терминах образцов принцип резолюции формулируется следующим образом:<br>   <i>если</i><br>    существуют два таких дизъюнкта <i>C1</i> и <i>C2</i>, что <i>P</i> является (дизъюнктивным) подвыражением <i>C1</i>, а <i>~P</i> — подвыражением <i>C2</i><br>   <i>то</i><br>    удалить <i>P </i>из <i>C1 </i>(результат — <i>CA</i>), удалить <i>~P </i>из <i>C2 </i>(результат — <i>CB</i>) и добавить в базу данных новый дизъюнкт <i>CA</i> v <i>CB</i>.<br>   На нашем формальном языке это можно записать так:<br>   [ дизъюнкт( C1), удалить( P, C1, CA),<br>     дизъюнкт( C2), удалить( ~P, C2, CB) ] ---&gt;<br>    [ assert( дизъюнкт( СА v СВ) ) ].<br>   Это правило нуждается в небольшой доработке. Дело в том, что мы не должны допускать повторных взаимодействий между дизъюнктами, так как они порождают новые копии уже существующих формул. Для этого в программе рис. 16.7 предусматривается запись в базу данных информации об уже произведенных взаимодействиях в форме утверждений вида<br>   сделано( C1, C2, P)<br>   В условных частях правил производится распознавание подобных утверждений и обход соответствующих повторных действий.<br>   Правила, показанные на рис. 16.7, предусматривают также обработку специальных случаев, в которых требуется избежать явного представления пустого дизъюнкта. Кроме того, имеются два правила для упрощения дизъюнктов. Одно из них убирает избыточные подвыражения. Например, это правило превращает выражение<br>   <i>a</i>  v  <i>b</i>  v  <i>a</i><br>   в более простое выражение <i>a</i> v <i>b</i>. Другое правило распознает те дизъюнкты, которые всегда истинны, например,<br>   <i>a</i>  v  <i>b</i>  v  <i>~а</i><br>   и удаляет их из базы данных, поскольку они бесполезны при поиске противоречия.<br>
		 <br>   % Продукционные правила для задачи автоматического<br>   % доказательства теорем<br>
		 <br>   % Противоречие<br>   [ дизъюнкт( X), дизъзюнкт( ~X) ] ---&gt;<br>    [ write( 'Обнаружено противоречие'), стоп].<br>
		 <br>   % Удалить тривиально истинный дизъюнкт<br>   [ дизъюнкт( С), внутри( P, С), внутри( ~P, С) ] ---&gt;<br>    [ retract( С) ].<br>
		 <br>   % Упростить дизъюнкт<br>   [ дизъюнкт( С), удалить( P, С, C1), внутри( P, C1) ] ---&gt;<br>    [ заменить( дизъюнкт( С), дизъюнкт( C1) ) ].<br>
		 <br>   % Шаг резолюции, специальный случай<br>   [ дизъюнкт( P), дизъюнкт( С), удалить( ~P, С, C1),<br>     not сделано( P, С, P) ] ---&gt;<br>    [ аssеrt( дизъюнкт( C1)), аssert( сделано( P, С, P))].<br>
		 <br>   % Шаг резолюции, специальный случай<br>   [ дизъюнкт( ~P), дизъюнкт( С), удалить( P, С, C1),<br>     not сделано( ~P, С, P) ] ---&gt;<br>    [ assert( дизъюнкт( C1)), аssert( сделано( ~P, С, P))].<br>
		 <br>   % Шаг резолюции, общий случай<br>   [ дизъюнкт( C1), удалить( P, C1, CA),<br>     дизъюнкт( C2), удалить( ~P, C2, CB),<br>     not сделано( C1, C2, P) ] ---&gt;<br>    [ assert( дизъюнкт( CA v CB) ),<br>      assert( сделано( C1, C2, P) ) ].<br>
		 <br>   % Последнее правило: тупик<br>   [] ---&gt; [ write( 'Нет противоречия'), стоп ].<br>
		 <br>   % удалить( P, E, E1) означает, получить из выражения E<br>   % выражение E1, удалив из него подвыражение P<br>   удалить( X, X v Y, Y).<br>   удалить( X, Y v X, Y).<br>   удалить( X, Y v Z, Y v Z1) :-<br>    удалить( X, Z, Z1).<br>   удалить( X, Y v Z, Y1 v Z) :-<br>    удалить( X, Y, Y1).<br>
		 <br>   % внутри( P, E) означает P есть дизъюнктивное подвыражение<br>   % выражения E<br>   внутри( X, X).<br>   внутри( X, Y) :-<br>    удалить( X, Y, _ ).<br>   <b>Рис. 16.7.</b> Программа, управляемая образцами, для автоматического доказательства теорем.<br>
		 <br>   Остается еще один вопрос: как преобразовать заданную пропозициональную формулу в конъюнктивную нормальную форму? Это несложное преобразование выполняется с помощью программы, показанной на рис. 16.8. Процедура<br>   транс( Формула)<br>   транслирует заданную формулу в множество дизъюнктов C1, C2 и т.д. и записывает их при помощи assert в базу данных в виде утверждений<br>   дизъюнкт( C1).<br>   дизъюнкт( C2).<br>   ...<br>   Программа, управляемая образцами, для автоматического доказательства теорем запускается при помощи цели пуск. Таким образом, для того чтобы доказать при помощи этой программы некоторую теорему, мы транслируем ее отрицание в конъюнктивную нормальную форму, а затем запускаем резолюционный процесс. В нашем примере это можно сделать так:<br>   ?- транс(~(( а=&gt;b) &amp; ( b=&gt;c) =&gt; ( а=&gt;с)) ), пуск.<br>   Ответ программы "Обнаружено противоречие" будет означать, что исходная формула является теоремой.<br>
		 <br>   % Преобразование пропозициональной формулы в множество<br>   % дизъюнктов с записью их в базу данных при помощи assert<br>   :- op( 100, fy, ~).           % Отрицание<br>   :- op( 110, xfy, &amp;).          % Конъюнкция<br>   :- op( 120, xfy, v).          % Дизъюнкция<br>   :- op( 130, xfy, =&gt;).         % Импликация<br>
		 <br>   транс( F &amp; G) :- !,     % Транслировать конъюнктивную формулу<br>    транс( F),<br>    транс( G).<br>   транс( Формула) :-<br>    тр( Формула, НовФ), !, % Шаг трансформации<br>    транс( НовФ).<br>   транс( Формула) :-      % Дальнейшая трансформация невозможна<br>    assert( дизъюнкт( Формула) ).<br>
		 <br>   % Правила трансформаций для пропозициональных формул<br>   тр( ~( ~X), X) :- !.          % Двойное отрицание<br>   тр( X =&gt; Y, ~X v Y) :- !.     % Устранение импликации<br>   тр( ~( X &amp; Y), ~X v ~Y) :- !. % Закон де Моргана<br>   тр( ~( X v Y), ~X &amp; ~Y) :- !. % Закон де Моргана<br>   тр( X &amp; Y v Z, (X v Z) &amp; (Y v Z) ) :- !.<br>     % Распределительный закон<br>   тр( X v Y &amp; Z, (X v Y) &amp; (X v Z) ) :- !.<br>     % Распределительный закон<br>   тр( X v Y, X1 v Y) :-         % Трансформация подвыражения<br>    тр( X, X1), !.<br>   тр( X v Y, X v Y1) :-         % Трансформация подвыражения<br>    тр( Y, Y1), !.<br>   тр( ~X, ~Х1) :-               % Трансформация подвыражения<br>    тр( X, X1).<br>   <b>Рис. 16.8.</b> Преобразование пропозициональных формул в множество дизъюнктов с записью их в базу данных при помощи assert.<br></div>
<h3 align="center">
<a name="TOC_id3464404"></a>16.4. Заключительные замечания<br></h3>
<div>   Нашего простого интерпретатора было вполне достаточно для того, чтобы проиллюстрировать некоторые идеи, лежащие в основе программирования в терминах образцов. Применение этого интерпретатора для более сложных приложений потребовало бы его доработки в целом ряде направлений. Ниже приводится несколько критических замечаний, а также ряд конкретных предложений по усовершенствованию алгоритма интерпретации.<br>   Задача разрешения конфликтов была сведена в нашем интерпретаторе к введению заранее заданного фиксированного порядка рассмотрения модулей. Часто возникает необходимость в более гибких механизмах. Для обеспечения более тонкого управления интерпретацией следует подавать все обнаруженные потенциально активные модули на вход специального управляющего модуля, запрограммированного пользователем.<br>   Когда база данных велика, а программа содержит большое количество модулей, процесс сопоставления с образцами становится крайне неэффективным. Неэффективность можно уменьшить, усложнив организацию базы данных. В частности, можно ввести индексирование информации, записанной в базе данных, или разбить эту информацию на отдельные "подбазы данных", или же разбить все множество модулей на отдельные подмножества. Идея разбиения — в каждый момент дать доступ только к некоторому <i>подмножеству</i> базы данных или набора модулей, ограничив тем самым сопоставление образцов только этим подмножеством. Разумеется, в этом случае механизм управления должен усложниться, поскольку он должен будет обеспечить переход от одних подмножеств к другим с целью их активизации либо деактивизации. Для этого можно применить специальные метаправила.<br>   К сожалению, наш интерпретатор запрограммирован таким образом, что он блокирует механизм автоматических возвратов, так как для манипулирования базой данных он использует процедуры assert и retract. Это положение можно исправить, применив другой способ реализации базы данных, не требующий обращения к этим встроенным процедурам. Например, все состоять базы данных можно представить одним прологовским термом, передаваемым в процедуру пуск в качестве аргумента. Простейший способ реализации этой идеи — организовать этот терм в виде списка объектов базы данных. Тогда верхний уровень базы данных примет вид:<br>   пуск( Состояние) :-<br>    Условие ---&gt; Действие,<br>    проверить( Условие, Состояние),<br>    выполнить( Действие, Состояние).<br>   Задача процедуры выполнить — получить новое состояние базы данных и обратиться к процедуре пуск, подав на ее вход это новое состояние.<br><h5>Проект</h5>   Запрограммируйте интерпретатор, который, в соответствии с приведенным выше замечанием, реализует базу данных как аргумент пусковой процедуры и не использует для этого внутренней базы данных пролог-системы (т.е. обходится без assert и retract). Эта новая версия интерпретатора будет допускать автоматические возвраты. Попытайтесь разработать такое представление базы данных, которое облегчало бы сопоставление с образцами.<br></div>
<h3 align="center">
<a name="TOC_id3464518"></a>Резюме<br></h3>
<div>   • Архитектура, ориентированная на типовые конфигурации (образцы), хорошо приспособлена для решения многих задач искусственного интеллекта.<br>   • Программа, управляемая образцами, состоит из модулей, запускаемых при возникновении в базе данных тех или иных конфигураций.<br>   • Прологовские программы можно рассматривать как частный случай систем, управляемых образцами.<br>   • Параллельная реализация — наиболее естественный способ реализации систем, управляемых образцами. Реализация на последовательной машине требует разрешения конфликтов между модулями, содержащимися в конфликтном множестве.<br>   • В этой главе был реализован простой интерпретатор для программ, управляемых образцами. Он был затем применен к задаче автоматического доказательства теорем пропозициональной логики.<br>   • Были рассмотрены следующие понятия:<br>      системы, управляемые образцами<br>      архитектуры, ориентированные на образцы<br>      программирование в терминах образцов<br>      модули, управляемые образцами<br>      конфликтное множество, разрешение конфликтов<br>      принцип резолюции<br>      автоматическое доказательство теорем на основе принципа резолюции<br><h5>Литература</h5>   Waterman and Hayes-Roth (1978) — классическая книга по системам, управляемым образцами. В книге Nilsson (1980) можно найти фундаментальные понятия, относящиеся к задаче автоматического доказательства теорем, включая алгоритм преобразования логических формул в конъюнктивную нормальную форму. Прологовская программа для выполнения этого преобразования приведена в Clocksin and Mellish (1981).<br>
		 <br>   Clocksin F. W. and Mellish С S. (1981). <i>Programming in Prolog.</i> Springer-Verlag. [Имеется перевод: Клоксин У., Мелиш К. Программирование на языке Пролог. — М.: Мир, 1987.]<br>   Nilsson N. J. (1980). <i>Principles of Artificial Intelligence.</i> Tioga; Springer-Verlag.<br>   Waterman D. A. and Hayes-Roth F. (1978, eds). <i>Pattern-Directed Inference Systems.</i> Academic Press.<br></div>
</div>
</div>
<h1 align="center">
<a name="TOC_id3464607"></a>Ответы к некоторым упражнениям<br></h1>
<div>
<h5>Глава 1</h5>   <b>1.1</b><br>   (a) no<br>   (b) X = пат<br>   (c) X = боб<br>   (d) X = боб, Y = пат<br>   <b>1.2</b><br>   (a) ?- родитель( X, пат).<br>   (b) ?- родитель( лиз, X).<br>   (c) ?- родитель( Y, пат), родитель( X, Y).<br>   <b>1.3</b><br>   (a) счастлив( X) :- <br>       родитель( X, Y).<br>   (b) имеетдвухдетей( X) :- <br>       родитель( X, Y),<br>       сестра( Z, Y).<br>   <b>1.4</b><br>   внук( X, Z) :-<br>    родитель( Y, X),<br>    родитель( Z, Y).<br>   <b>1.5</b><br>   тетя( X, Y) :-<br>    родитель( Z, Y),<br>    сестра( X, Z).<br>   <b>1.6</b><br>   Да. (Определение верно)<br>   <b>1.7</b><br>   (a) возвратов не будет<br>   (b) возвратов не будет<br>   (c) возвратов не будет<br>   (d) возвраты будут<br><h5>Глава 2</h5>   <b>2.1</b><br>   (a) переменная<br>   (b) атом<br>   (c) атом<br>   (d) переменная<br>   (e) атом<br>   (f) структура<br>   (g) число<br>   (h) синтаксически неправильное выражение<br>   (i) структура<br>   (j) структура<br>   <b>2.3</b><br>   (a) успех<br>   (b) неуспех<br>   (c) неуспех<br>   (d) D = 2, E = 2<br>   (e) P1 = точка(-1, 0) <br>      Р2 = точка( 1, 0)<br>      Р3 = точка( 0, Y)<br>   Такая конкретизация определяет семейство треугольников, у которых две вершины располагаются на оси <i>x</i> в точках 1 и -1, а третья — в произвольной точке оси <i>у</i>.<br>   <b>2.4</b><br>   отр( точка( 5, Y1), точка( 5, Y2) )<br>   <b>2.5</b><br>   регулярный( прямоугольник( точка( X1, Y1),<br>    точка( Х2, Y1), точкa( X2, Y3),<br>    точка( X1, Y3) ) ).<br>   Здесь предполагается, что первая точка соответствует нижней левой вершине прямоугольника.<br>   <b>2.6</b><br>   (a) А = два<br>   (b) no<br>   (c) С = один<br>   (d) D = s(s(1));<br>      D = s(s(s(s(s(1)))))<br>   <b>2.7</b><br>   родственники( X, Y) :-<br>    предок( X, Y);<br>    предок( Y, X);<br>    предок( Z, X),<br>    предок( Z, Y);<br>    предок( X, Z),<br>    предок( Y, Z).<br>   <b>2.8</b><br>   преобразовать( 1, один).<br>   преобразовать( 2, два).<br>   преобразовать( 3, три).<br>   <b>2.9</b><br>   В случае, изображенном на рис. 2.10, пролог-система выполняет несколько больший объем работы.<br>   <b>2.10</b><br>   В соответствии с определением сопоставления, приведенном в разд. 2.2, данное сопоставление будет успешным. X приобретает вид циклической структуры, в которой сам X присутствует в качестве одного из аргументов.<br><h5>Глава 3</h5>   <b>3.1</b><br>   (a) конк( L1, [ _, _, _ ], L)<br>   (b) конк( [ _, _, _ ], L1, L),<br>        % Удалить 3 первые элемента L<br>       конк( L2, [ _, _, _ ], L1)<br>        % Удалить 3 последние элемента L1<br>   Вот более короткий вариант, предложенный I. Tvrdy:<br>   конк( [ _, _, _ | L2], [ _, _, _ ], L)<br>   <b>3.2</b><br>   (а) последний( Элемент, Список) :- <br>      конк( _, [Элемент], Список).<br>   (b) последний( Элемент, [Элемент]).<br>      последний( Элемент, [Первый | Остальные]):-<br>       последний( Элемент, Остальные). <br>   <b>3.3</b><br>   четнаядлина( [] ).<br>   четнаядлина( [Первый | Остальные] ) :-<br>    нечетнаядлина( Остальные).<br>   нечетнаядлина( [ _ ] ).<br>   нечетнаядлина( [Первый | Остальные] ) :-<br>    четнаядлина( Остальные).<br>   <b>3.4</b><br>   обращение( [], []).<br>   обращение( [Первый | Остальные], ОбращСпис): -<br>    обращение( Остальные, ОбращСписОстальных),<br>    конк( О6ращСписОстальных, [Первый], ОбращСпис).<br>   <b>3.5</b><br>   % Такой предикат легко определить при помощи отношения обратить<br>   палиндром( Список) :-<br>    обратить( Список, Список).<br>
		 <br>   % Вот другое решение, не использующее обратить<br>   палиндром1( [] ).<br>   палиндром1( [ _ ] ).<br>   палиндром1 [Первый | Остальные] ) :-<br>    конк( Середина, [Первый], Остальные),<br>    палиндром1( Середина).<br>   <b>3.6</b><br>   сдвиг( [Первый | Остальные], Сдвинут) :-<br>    конк( Остальные, [Первый], Сдвинут).<br>   <b>3.7</b><br>   перевод( [], []).<br>   перевод( [Голова | Хвост], [Голова1 | Хвост1]) :-<br>    означает( Голова, Голова1),<br>    перевод( Хвост, Хвост1).<br>   <b>3.8</b><br>   подмножество( [], [] ).<br>   подмножество( [Первый | Остальные], [Первый | Подмн]):-<br>     % Оставить первый элемент в подмножестве<br>    подмножество( Остальные, Подмн).<br>   подмножество( [Первый | Остальные], Подмн) :-<br>     % Убрать первый элемент из подмножества<br>    подмножество( Остальные, Подмн).<br>   <b>3.9</b><br>   разбиениесписка( [], [], []). % Разбивать нечего<br>   разбиениесписка( [X], [X], []).<br>    % Разбиение одноэлементного списка<br>   разбиениесписка( [X, Y | Список], [X | Список1],<br>    [Y | Список2]) :-<br>    разбиениесписка( Список, Список1, Список2).<br>   <b>3.10</b><br>   можетзавладеть( состояние( _, _, _, имеет), [] ).<br>     % Ничего не надо делать<br>   можетзавладеть( Состояние, [Действие | Действия]):-<br>    ход( Состояние, Действие, НовоеСостояние),<br>     % Первое действие<br>    можетзавладеть( НовоеСостояние, Действия).<br>     % Оставшиеся действия<br>   <b>3.11</b><br>   линеаризация( [Голова | Хвост], ЛинейныйСписок ) :-<br>     % Линеаризация непустого списка<br>    линеаризация( Голова, ЛинейнаяГолова ),<br>    линеаризация( Хвост, ЛинейныйХвост ),<br>    конк( ЛинейнаяГолова, ЛинейныйХвост,<br>    ЛинейныйСписок ).<br>   линеаризация( [], [] ). % Линеаризация пустого списка<br>   линеаризация( X, [X] ).<br>    % Линеаризация объекта, не являющегося списком<br>
		 <br>   % Замечание: при попытке получить от этой программы более<br>   % одного варианта решения выдается бессмыслица<br>   <b>3.12</b><br>   Терм1 = играет_в( джимми, и( футбол, сквош) )<br>   Терм2 = играет_в( сьюзан, и( теннис,<br>    и( баскетбол, волейбол) ) )<br>   <b>3.13</b><br>   :- op( 300, xfx, работает)<br>   :- op( 200, xfx, в)<br>   :- op( 100, xfx, нашем)<br>   <b>3.14</b><br>   (a) А = 1 + 0<br>   (b) В = 1 + 1 + 0<br>   (c) С = 1 + 1 + 1 + 1 + 0<br>   (d) D = 1 + 1 + 0 + 1<br>   <b>3.15</b><br>   :- op( 100, xfx, входит_в)<br>   :- op( 300, fx, конкатенация_списков)<br>   :- op( 200, xfx, дает)<br>   :- op( 100, xfx, и)<br>   :- op( 300, fx, удаление_элемента)<br>   :- op( 100, xfx, из_списка) % Принадлежность к списку<br>
		 <br>   Элемент входит_в [Элемент | Список].<br>   Элемент входит_в [Первый | СписокОстальных] :-<br>    Элемент входит_в СписокОстальных.<br>
		 <br>   % Конкатенация списков<br>   конкатенация_списков [] и Список дает Список.<br>   конкатенация_списков [X | L1] и L2 дает [X | L3] :-<br>    конкатенация_списков L1 и L2 дает L3.<br>
		 <br>   % Удаление элемента из списка<br>   удаление_элемента Элемент из_списка<br>    [Элемент | ОстальныеЭлементы]<br>    дает ОстальныеЭлементы.<br>   удаление_элемента Элемент из_списка<br>    [Первый | ОстальныеЭлементы]<br>    дает [Первый | НовСписОстЭлементов] :-<br>    удаление_элемента Элемент из_списка<br>    ОстальныеЭлементы дает НовСписОстЭлементов.<br>   <b>3.16</b><br>   max( X, Y, X) :-<br>    X &gt;= Y.<br>   max( X, Y, Y) :-<br>    X &lt;Y.<br>   <b>3.17</b><br>   максспис( [X], X).<br>     % Максимум в одноэлементном списке<br>   максспис( [X, Y | Остальные], Мах) :-<br>     % В списке есть по крайней мере два элемента?<br>   максспис( [Y | Остальные], МаксОстальные),<br>    mах( X, МаксОстальные, Мах).<br>     % Мах наибольшее из чисел X и МаксОстальные<br>   <b>3.18</b><br>   сумспис( [], 0).<br>   сумспис( [Первый | Остальные], Сумма) :-<br>    сумспис( Остальные, СуммаОстальных),<br>    Сумма is Первый + СуммаОстальных.<br>   <b>3.19</b><br>   упорядоченный ([]).<br>     % Одноэлементный список является упорядоченным<br>   упорядоченный( [X, Y | Остальные] :-<br>    X =&lt; Y,<br>    упорядоченный( [Y | Остальные] ).<br>   <b>3.20</b><br>   подсумма( [], 0, []).<br>   подсумма( [N | Список], Сумма, [N | Подмн]) :-<br>     % N принадлежит подмножеству<br>
		 <br>   Сумма1 is Сумма - N,<br>    подсумма( Список, Сумма1, Подмн).<br>
		 <br>   подсумма( [N | Список], Сумма, Подмн) :-<br>     % N не принадлежит подмножеству<br>    подсумма( Список, Сумма, Подмн).<br>   <b>3.21</b><br>   между( N1, N2, N1) :-<br>    N1 =&lt; N2.<br>   между( N1, N2, X) :-<br>    N1 &lt; N2,<br>    HoвoeN1 is N1 + 1,<br>    между( HoвoeN1, N2, X).<br>   <b>3.22</b><br>   :- op( 900, fx, если).<br>   :- op( 800, xfx, то).<br>   :- op( 700, xfx, иначе).<br>   :- op( 600, xfx, :=).<br>
		 <br>   если Вел1 &gt; Вел2 то Перем := Вел3<br>    иначе ЧтоУгодно :-<br>    Вел1 &gt; Вел2,<br>    Перем = Вел3.<br>   если Вел1 &gt; Вел2 то ЧтоУгодно<br>    иначе Перем := Вел4 :-<br>    Вел1 =&lt; Вел2,<br>    Перем = Вел4.<br><h5>Глава 4</h5>   <b>4.1</b><br>   (a) ?- семья(членсемьи( _, Фамилия, _, _ ), _, []).<br>   (b) ?- ребенок( членсемьи( Имя, Фамилия, _, <br>       работает( _, _ ) )).<br>   (c) семья(членсемьи( _, Фамилия, _, неработает),<br>       членсемьи( _, _, _, работает( _, _ ) ),_ ).<br>   (d) ?- семья( Муж, Жена, Дети),<br>       датарождения( Муж, дата( _, _, Год1) ),<br>       датарождения( Жена, дата( _, _, Год2) ),<br>       ( Год1 - Год2 &gt;= 15;<br>         Год2 - Год1 &gt;= 15 ),<br>       принадлежит( Ребенок, Дети).<br>   <b>4.2</b><br>   близнецы( Ребенок1, Ребенок2) :-<br>    семья( _, _, Дети),<br>    удалить( Ребенок1, Дети, ДругиеДети),<br>     % Выделить первого ребенка<br>    принадлежит( Ребенок2, ДругиеДети),<br>    принадлежит( Ребенок1, Дата),<br>    принадлежит( Ребенок2, Дата).<br>   <b>4.3</b><br>   <i>n</i>_элемент( 1, [X | L], X).<br>     % X - первый элемент списка [X | L]<br>   <i>n</i>_элемент( N, [Y | L], X) :-<br>     % X - n-й элемент [Y | L]<br>    N1 is N - 1,<br>   <i> n</i>_элемент( N1, L, X).<br>   <b>4.4</b><br>   Входная цепочка укорачивается на каждом неспонтанном цикле, а укорачиваться бесконечно она не может.<br>   <b>4.5</b><br>   допускается( S, [], _ ) :-<br>    конечное( S).<br>   допускается( S, [X | Остальные], Макс_переходов) :-<br>    Макс_переходов &gt; 0,<br>    переход( S, X, S1),<br>    НовыйМакс is Макс_переходов - 1,<br>    допускается( S1, Остальные, НовыйМакс).<br>   допускается( S, Цепочка, Макс_переходов) :-<br>    Макс_переходов &gt; 0,<br>    спонтанный( S, S1),<br>    НовыйМакс is Макс_переходов - 1,<br>    допускается( S1, Цепочка, НовыйМакс).<br>   <b>4.7</b><br>   (а) ходконя( X/Y, X1/Y1) :-<br>        % Ход коня с поля X/Y на поле X1/Y1<br>       ( dxy( DX, DY);<br>        % Расстояния по направлениям X и Y<br>       dxy( DY, DX) ),<br>        % Или расстояния по направлениям Y и X<br>       X1 is X + DX,<br>        % X1 расположен в пределах шахматной доски<br>       надоске( X1),<br>       Y1 is Y + DY,<br>        % Y1 расположен в пределах шахматной доски<br>       надоске( Y1).<br>
		 <br>      dxy( 2, 1).   % 2 поля вправо, 1 поле вперед<br>      dxy( 2, -1).  % 2 поля вправо, 1 поле назад<br>      dxy( -2, 1).  % 2 поля влево, 1 поле вперед<br>      dxy( -2, -1). % 2 поля влево, 1 поле назад<br>
		 <br>      надоске( Коорд) :-<br>        % Координаты в пределах доски<br>       0 &lt; Коорд,<br>       Коорд &lt; 9.<br>   (b) путьконя( [ Поле]). % Конь стоит на поле Поле<br>      путьконя( [S1, S2 | Остальные] ) :-<br>       ходконя( S1, S2),<br>       путьконя( [S2 | Остальные]).<br>   (c) ?- путьконя( [2/1, R, 5/4, S, X/8] ).<br><h5>Глава 5</h5>   <b>5.1</b><br>   (a) X = 1;<br>      X = 2<br>   (b) X = 1;<br>      Y = 1;<br>
		 <br>      X = 1;<br>      Y = 2;<br>
		 <br>      X = 2;<br>      Y = 1;<br>
		 <br>      X = 2;<br>      Y = 2;<br>   (c) X = 1;<br>      Y = 1;<br>
		 <br>      X = 1;<br>      Y = 2;<br>   <b>5.2</b><br>   класс( Число, положительное) :-<br>    Число &gt; 0, !.<br>   класс( 0, нуль) :- !.<br>   класс( Число, отрицательное).<br>   <b>5.3</b><br>   разбить( [], [], []).<br>   разбить( [X | L], [X | L1], L2) :-<br>    X &gt;= 0, !,<br>    разбить( L, L1, L2).<br>   разбить( [X | L], L1, [X | L2]) .<br>    разбить( L, L1, L2).<br>   <b>5.4</b><br>   принадлежит( Некто, Кандидаты),<br>    not принадлежит( Некто, Исключенные)<br>   <b>5.5</b><br>   разность( [], _, []).<br>   разность( [X | L1], L2, L):-<br>    принадлежит( X, L2), !,<br>    разность( L1, L2, L).<br>   разность( [X | L1], L2, [X | L]) :-<br>    разность( L1, L2, L).<br>   <b>5.6</b><br>   унифицируемые( [], _, []).<br>   унифицируемые( [Первый | Остальные], Терм, Список) : -<br>    not( Первый = Терм), !,<br>    унифицируемые( Остальные, Терм, Список).<br>   унифицируемые( [Первый | Остальные], Терм,<br>    [Первый | Список] ) :-<br>    унифицируемые( Остальные, Терм, Список).<br><h5>Глава 6</h5>   <b>6.1</b><br>   найтитерм( Терм) :-<br>     % Пусть текущий входной поток - это файл f<br>    read( Терм), !,<br>     % Текущий терм из f сопоставим с Терм'ом?<br>    write( Терм);      % Если да - вывести его на терминал<br>     найтитерм( Терм). % В противном случае - обработать<br>   <b>6.2</b><br>   найтитермы( Терм) :-<br>    read( ТекущийТерм),<br>    обработать( ТекущийТерм, Терм).<br>
		 <br>   обработать( end_of_file, _ ) :- !.<br>   обработать( ТекущийТерм, Терм) :-<br>    ( not( ТекущийТерм = Терм), !;<br>       % Термы несопоставимы<br>    write( ТекущийТерм), nl),<br>     % В противном случае вывести текущий терм<br>    найтивсетермы( Терм).<br>     % Обработать оставшуюся часть файла<br>   <b>6.4</b><br>   начинается( Атом, Символ) :-<br>    name( Символ, [ Код]),<br>    name( Атом, [Код | _ ]).<br>   <b>6.5</b><br>   plural( Существительное, Существительные) :-<br>    name( Существительное, СписокКодов),<br>    name( s, КодS),<br>    конк( СписокКодов, КодS, НовыйСписокКодов),<br>    name( Существительные, НовыйСписокКодов).<br><h5>Глава 7</h5>   <b>7.2</b><br>   добавить( Элемент, Список) :-<br>    var( Список), !,<br>     % Переменная Список представляет пустой список<br>   Список = [Элемент | Хвост].<br>   добавить( Элемент, [ _ | Хвост]) :-<br>    добавить( Элемент, Хвост).<br>
		 <br>   принадлежит( X, Список) :-<br>    var( Список), !,<br>     % Переменная Список представляет пустой список,<br>     % поэтому X не может ему принадлежать<br>    fail.<br>   принадлежит( X, [X | Хвост]).<br>   принадлежит( X, [ _ | Хвост] ) :-<br>    принадлежит( X, Хвост).<br><h5>Глава 8</h5>   <b>8.2</b><br>   добавить_в_конец( L1-[Элемент | Z2], Элемент, L1 - Z2).<br>   <b>8.3</b><br>   обратить( А - Z, L - L) :-<br>     % Результатом является пустой список,<br>     % если A-Z представляет пустой список<br>    А == Z, !.<br>   обратить( [X | L] - Z, RL - RZ ) :-<br>     % Непустой список<br>    обратить( L - Z, RL - [X | RZ].<br><h5>Глава 9</h5>   <b>9.1</b><br>   список( []).<br>   список( [ _ | Хвост]) :-<br>    список( Хвост).<br>   <b>9.2</b><br>   принадлежит( X, X затем ЧтоУгодно).<br>   принадлежит( X, Y затем Спис) :-<br>    принадлежит( X, Спис).<br>   <b>9.3</b><br>   преобр( [ , ничего_не_делать).<br>   преобр( [Первый | Хвост], Первый затем Остальные):-<br>    преобр( Хвост, Остальные).<br>   <b>9.4</b><br>   преобр( [ , ПустСпис, _, ПустСпис).<br>     % Случай пустого списка<br>   преобр( [Первый | Хвост], НовСпис, Функтор, Пустой) :-<br>    НовСпис =.. [Функтор, Первый, НовХвост],<br>    преобр( Хвост, НовХвост, Функтор, Пустой).<br>   <b>9.8</b><br>   сорт1( [], []).<br>   сорт1( [X], [X]).<br>   сорт1( Спис, УпорСпис) :-<br>    разбить( Спис, Спис1, Спис2),<br>     % Разбить на 2 прибл. равных списка<br>    сорт1( Спис1, Упор1),<br>    сорт1( Спис2, Упор2),<br>    слить( Упор1, Упор2, УпорСпис).<br>     % Слить отсортированные списки<br>
		 <br>   разбить( [], [], []).<br>   разбить( [X], [X], []).<br>   разбить( [X, Y | L], [X | L1], [Y | L2]) :-<br>     % X и Y помещаются в разные списки<br>    разбить( L, L1, L2).<br>   <b>9.9</b><br>   (а) двдерево( nil).<br>      двдерево( д( Лев, Кор, Прав) ) :-<br>       двдерево( Лев),<br>       двдерево( Прав).<br>   <b>9.10</b><br>   глубина( пусто, 0).<br>   глубина( д( Лев, Кор, Прав), Г) :-<br>    глубина( Лев, ГЛ),<br>    глубина( Прав, ГП),<br>    макс( ГЛ, ГП, МГ),<br>    Г is МГ + 1.<br>
		 <br>   макс( А, В, А) :-<br>    А &gt;= В, !.<br>   макс( А, В, В).<br>   <b>9.11</b><br>   линеаризация( nil, []).<br>   линеаризация( д( Лев, Кор, Прав), Спис) :-<br>    линеаризация( Лев, Спис1),<br>    линеаризация( Прав, Спис2),<br>    конк( Спис1, [Кор | Спис2], Спис).<br>   <b>9.12</b><br>   максэлемент( д( _, Кор, nil), Кор) :- !.<br>     % Корень - самый правый элемент<br>   максэлемент( д( _, _, Прав,), Макс) :-<br>     % Правое поддерево непустое<br>    максэлемент( Прав, Макс).<br>   <b>9.13</b><br>   внутри( Элем, д( _, Элем, _ ), [ Элем]).<br>   внутри( Элем, д( Лев, Кор, _ ), [Кор | Путь]) :-<br>    больше( Кор, Элем),<br>    внутри( Элем, Лев, Путь).<br>   внутри( Элем,д( _, Кор, Прав), [Кор | Путь]) :-<br>    больше( Элем, Кор),<br>    внутри( Элем, Прав, Путь).<br>   <b>9.14</b><br>   % Отображение двоичного дерева, растущего сверху вниз<br>   % Предполагается, что каждая вершина занимает при печати<br>   % один символ<br>   отобр( Дер) :-<br>    уровни( Дер, 0, да).<br>     % Обработать все уровни<br>
		 <br>   уровни( Дер, Уров, нет) :- !.<br>     % Ниже уровня Уров больше нет вершин<br>   уровни( Дер, Уров, да) :-<br>     % Обработать все уровни, начиная с Уров<br>    вывод( Дер, Уров, 0, Дальше), nl,<br>     % Вывести вершины уровня Уров<br>    Уров1 is Уров + 1,<br>    уровни( Дер, Уров1, Дальше).<br>     % Обработать следующие уровни<br>
		 <br>   вывод( nil, _, _, _, _ ).<br>   вывод( д( Лев, X, Прав), Уров, ГлубХ, Дальше) :-<br>    Глуб1 is ГлубХ + 1,<br>    вывод( Лев, Уров, Глуб1, Дальше),<br>     % Вывод левого поддерева<br>    ( Уров = ГлубХ, !,<br>     % X на нашем уровне?<br>    write( X), Дальше = да;<br>     % Вывести вершину, продолжить<br>    write(' ') ),<br>     % Иначе - оставить место<br>    вывод( Прав, Уров, Глуб1, Дальше).<br>     % Вывод левого поддерева<br><h5>Глава 10</h5>   <b>10.1</b><br>   внутри( Элем, л( Элем)). % Элемент найден в листе<br>   внутри( Элем, в2( Д1, М, Д2) ):-<br>     % Вершина имеет два поддерева<br>    больше( М, Элем), !,    % Вершина не во втором поддереве<br>    внутри( Элем, Д1);      % Поиск в первом поддереве<br>    внутри( Элем, Д2).      % Иначе - во втором поддереве<br>   внутри( Элем, в3( Д1, M2, Д2, М3, Д3) ):-<br>     % Вершина имеет три поддерева<br>    больше( M2, Элем), !,<br>     % Элемент не во втором и не в третьем поддереве<br>    внутри( Элем, Д1);      % Поиск в первом поддереве<br>    больше( M3, Элем), !,   % Элемент не в третьем поддереве<br>    внутри( Элем, Д2);      % Поиск во втором поддереве<br>    внутри( Элем, Д3).      % Поиск в третьем поддереве<br>   <b>10.3</b><br>   avl( Дер) :-<br>    аvl( Дер, Глуб).  % Дер является AVL-деревом глубины Глуб<br>   avl( nil, 0).      % Пустое дерево - AVL -дерево глубины 0<br>   avl( д( Лев, Кор, Прав), Г) :-<br>    avl( Лев, ГЛ),<br>    avl( Прав, ГП),<br>    ( ГЛ is ГП; ГЛ is ГП + 1; ГЛ is ГП - 1),<br>     % Глубины поддеревьев примерно совпадают<br>    макс( ГЛ, ГП, Г).<br>
		 <br>   макс1( U, V, М) :- % М = 1 + макс( U, V)<br>    U &gt; V, !, М is U + 1;<br>    М is V + 1.<br><h5>Глава 11</h5>   <b>11.1</b><br>   вглубину1( [Верш | Путь], [Верш | Путь]) :-<br>    цель( Верш).<br>   вглубину1( [Верш | Путь], Решение) :-<br>    после( Верш, Верш1),<br>    not принадлежит( Верш1, Путь),<br>    вглубину1( [ Верш1, Верш | Путь], Решение).<br>   <b>11.6</b><br>   решить( СтартМнож, Решение) :-<br>     % СтартМнож - множество стартовых вершин<br>    bagof( [Верш], принадлежит( Верш, СтартМнож),<br>     Пути),<br>    вширину( Пути, Решение).<br></div>
<p align="center">   Спасибо, что скачали книгу в <a href="http://royallib.ru" title="">бесплатной электронной библиотеке Royallib.ru</a><br>   <a href="http://royallib.ru/comment/bratko_ivan/programmirovanie_na_yazike_prolog_dlya_iskusstvennogo_intellekta.html" title="">Оставить отзыв о книге</a><br>   <a href="http://royallib.ru/author/bratko_ivan.html" title="">Все книги автора</a><br></p>
<hr>
<h4>
<a name="#TOC_notes_id3731494"></a>Сноски</h4>
<h1>Примечания<br></h1>
<a name="n_1"></a><a name="n_1"></a><strong>1<br></strong><div>   Чем выше приоритет, тем меньше его номер. — <i>Прим. перев</i>.<br></div>
</body>
</html>
